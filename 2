#include "thorin/world.h"
#include "thorin/continuation.h"
#include "thorin/transform/mangle.h"
#include "thorin/transform/hls_channels.h"
#include "thorin/analyses/scope.h"
#include "thorin/analyses/schedule.h"
#include "thorin/util/log.h"
#include "thorin/type.h"

namespace thorin {

enum class ChannelMode : uint8_t {
    Read,       ///< Read-channel
    Write       ///< Write-channe
};

using Def2Mode = DefMap<ChannelMode>;

static void extract_kernel_channels(const Schedule& schedule, Def2Mode& def2mode) {
    for (const auto& block : schedule) {
        auto continuation = block.continuation();
        if (continuation->empty())
            continue;
        auto callee = continuation->callee()->isa_continuation();
        if (callee && callee->is_channel()) {
            if (continuation->arg(1)->order() == 0 && !(is_mem(continuation->arg(1)) || is_unit(continuation->arg(1)))) {
                auto def= continuation->arg(1);
                if (def->isa<PrimOp>() && is_const(def)) {
                    if (callee->name().str().find("write_channel") != std::string::npos) {
                        assert((!def2mode.contains(def) || def2mode[def] == ChannelMode::Write) &&
                                "Duplicated channel or \"READ\" mode channel redefined as WRITE!");
                        def2mode.emplace(def, ChannelMode::Write);
                    } else if (callee->name().str().find("read_channel") != std::string::npos) {
                        assert((!def2mode.contains(def) || def2mode[def] == ChannelMode::Read)  &&
                                "Duplicated channel or \"WRITE\" mode channel redefined as READ!");
                        def2mode.emplace(def, ChannelMode::Read);
                    } else {
                        ELOG("Not a channel / unsupported channel placeholder");
                    }
                }
            }
        }
    }
}

bool is_channel_type(const Type* type) {
    if (auto ptr_type = type->isa<PtrType>()) {
        if (auto struct_type = ptr_type->pointee()->isa<StructType>()) {
            if (struct_type->name().str().find("channel") != std::string::npos)
                return true;
        }
    }
    return false;
}


void hls_channels(World& world) {
    std::vector<Def2Mode> channels_map; // vector of channel->mode maps for each kernel
    std::vector<Continuation*> new_kernels;
    Def2Def param2global; // contains map from new kernel parameter to global channel

    Scope::for_each(world, [&] (Scope& scope) {
        auto kernel = scope.entry();
        Def2Mode def2mode;
        extract_kernel_channels(schedule(scope), def2mode);

        Array<const Type*> new_param_types(def2mode.size() + kernel->num_params());
        std::copy(kernel->type()->ops().begin(),
                  kernel->type()->ops().end(),
                  new_param_types.begin());
        size_t i = kernel->num_params();
        // This vector records pairs containing:
        // - The position of the channel parameter for the new kernel
        // - The old global definition for the channel
        std::vector<std::pair<size_t, const Def*>> index2def;
        for (auto map : def2mode) {
            index2def.emplace_back(i, map.first);
            new_param_types[i++] = map.first->type();
        }

        // new kernels signature
        // fn(mem, ret_cnt, ... , /channels/ )
        auto new_kernel = world.continuation(world.fn_type(new_param_types), kernel->debug());
        new_kernel->make_external();
        new_kernels.emplace_back(new_kernel);
        kernel->make_internal();

        Rewriter rewriter;
        // Map the parameters of the old kernel to the first N parameters of the new one
        // The channels used inside the kernel are mapped to the parameters N + 1, N + 2, ...
        for (auto pair : index2def) {
            auto param = new_kernel->param(pair.first);
            rewriter.old2new[pair.second] = param;
            param2global[param] = pair.second;
        }
        for (auto def : scope.defs()) {
            if (auto cont = def->isa_continuation()) {
                // Copy the basic block by calling stub
                // Or reuse the newly created kernel copy if def is the old kernel
                auto new_cont = def == kernel ? new_kernel : cont->stub();
                rewriter.old2new[cont] = new_cont;
                for (size_t i = 0; i < cont->num_params(); ++i)
                    rewriter.old2new[cont->param(i)] = new_cont->param(i);
            }
        }
        // Rewriting the basic blocks of the kernel using the map
        for (auto def : scope.defs()) {
            if (auto cont = def->isa_continuation()) { // all basic blocks of the scope
                auto new_cont = rewriter.old2new[cont]->as_continuation();
                auto new_callee = rewriter.instantiate(cont->callee());
                Array<const Def*> new_args(cont->num_args());
                for ( size_t i = 0; i < cont->num_args(); ++i)
                    new_args[i] = rewriter.instantiate(cont->arg(i));
                new_cont->jump(new_callee, new_args, cont->debug());
            }
        }

        channels_map.emplace_back(def2mode);
    });


    // Building Top types
    std::vector<const Type*> top_param_types;
    top_param_types.emplace_back(world.mem_type());                      //mem
    top_param_types.emplace_back(world.fn_type({ world.mem_type() }));   //ret_continuation
    size_t io_cnt = 0;
    for (auto kernel : new_kernels) {
        for (auto param : kernel->params()) {
            if (!is_channel_type(param->type())) {
                if( param != kernel->ret_param() && param != kernel->mem_param()) {
                    top_param_types.emplace_back(param->type());
                    io_cnt++;
                }
            }
        }
    }

    auto hls_top = world.continuation(world.fn_type(top_param_types), Debug("hls_top"));

    if (io_cnt > 2) {
        for (auto param : hls_top->params()) {
            if( param != hls_top->ret_param() && param != hls_top->mem_param() &&
                    !param->type()->as<PtrType>()->pointee()->isa<ArrayType>())
                WLOG("Top function has {} non-streaming input/output", (io_cnt-2));
        }
    }
    std::cout<< "kernel_count = " << channels_map.size() <<endl;

    auto enter   = world.enter(hls_top->mem_param());
    auto cur_mem = world.extract(enter, 0_s);
    auto frame   = world.extract(enter, 1_s);

    Def2Def global2slot;
    std::vector<const Def*> channel_slots;
    std::vector<const Global*> globals;
    for (auto primop : world.primops()) {
        if (auto global = primop->isa<Global>())
            globals.emplace_back(global);
    }
    // We need to iterate over globals twice because we cannot iterate over primops while creating new primops
    for (auto global : globals) {
        if (is_channel_type(global->type())) {
            channel_slots.emplace_back(world.slot(global->type()->as<PtrType>()->pointee(), frame));
            global2slot.emplace(global, channel_slots.back());
        }
    }

    std::cout <<"channel_count = " << channel_slots.size() <<endl;

    //dummy_val
    auto val = world.literal_qu8(20, {});

    size_t i=0;
    Array<Continuation*> continuations(new_kernels.size());
    for (auto kernel : new_kernels) {
        auto cont_type = kernel->ret_param()->type()->as<FnType>();
        continuations[i++] = world.continuation(cont_type, kernel->debug());
    }


//    auto cont_type_0 = new_kernels[0]->ret_param()->type()->as<FnType>();
//    auto cont_type_1 = new_kernels[1]->ret_param()->type()->as<FnType>();
//    auto continuation_0 = world.continuation(cont_type_0, new_kernels[0]->debug());
//    auto continuation_1 = world.continuation(cont_type_1, new_kernels[1]->debug());

    // via channel_map find each kernel uses which globals then use global2slot to map it on the slot the use that slot for the same new_kernel 
    // search on global2slot by the key for the first kernel on channel_map
    // args in array
    for (auto channels : channels_map) {
        for (auto channel : channels) {
            //channel->dump();
            global2slot.find(channel.first)->second->dump();
        }
    }
    hls_top->jump(new_kernels[0], {cur_mem, continuations[0], hls_top->param(2), channel_slots[0]});
    continuations[0]->jump(new_kernels[1], {continuations[0]->mem_param(), continuations[1], hls_top->param(3), channel_slots[0]});
    //last kernel should jump to top return
    continuations[1]->jump(hls_top->ret_param(), {continuations[1]->mem_param()});

    for (auto continuation : continuations) {
        continuation->dump();
    }
    //hls_top->jump(hls_top->ret_param(), { hls_top->mem_param() });
    //hls_top->jump(hls_top->ret_param(), {cur_mem});

    hls_top->make_external();

    channels_map.clear();
    world.cleanup();
    world.dump();
}

}
