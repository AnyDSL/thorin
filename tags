!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AMDGPU	src/thorin/continuation.h	/^    AMDGPU,                     \/\/\/< Internal AMDGPU-Backend.$/;"	m	class:thorin::Intrinsic
AMDGPUCodeGen	src/thorin/be/llvm/amdgpu.cpp	/^AMDGPUCodeGen::AMDGPUCodeGen(World& world, const Cont2Config& kernel_config)$/;"	f	class:thorin::AMDGPUCodeGen
AMDGPUCodeGen	src/thorin/be/llvm/amdgpu.h	/^class AMDGPUCodeGen : public CodeGen {$/;"	c	namespace:thorin
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	377;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	380;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	383;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	387;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	389;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	391;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	395;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	398;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	401;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	406;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	409;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	412;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	416;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	372;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	375;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	378;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	382;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	384;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	386;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	390;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	393;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	396;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	401;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	404;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	407;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	411;"	d	file:
Access	src/thorin/primop.h	/^    Access(NodeTag tag, const Type* type, Defs args, Debug dbg)$/;"	f	class:thorin::Access
Access	src/thorin/primop.h	/^class Access : public MemOp {$/;"	c	namespace:thorin
AddrSpace	src/thorin/type.h	/^enum class AddrSpace : uint32_t {$/;"	c	namespace:thorin
AggOp	src/thorin/primop.h	/^    AggOp(NodeTag tag, const Type* type, Defs args, Debug dbg)$/;"	f	class:thorin::AggOp
AggOp	src/thorin/primop.h	/^class AggOp : public PrimOp {$/;"	c	namespace:thorin
Aggregate	src/thorin/primop.h	/^    Aggregate(NodeTag tag, Defs args, Debug dbg)$/;"	f	class:thorin::Aggregate
Aggregate	src/thorin/primop.h	/^class Aggregate : public PrimOp {$/;"	c	namespace:thorin
Alloc	src/thorin/primop.cpp	/^Alloc::Alloc(const Type* type, const Def* mem, const Def* extra, Debug dbg)$/;"	f	class:thorin::Alloc
Alloc	src/thorin/primop.h	/^class Alloc : public MemOp {$/;"	c	namespace:thorin
App	src/thorin/type.h	/^    App(TypeTable& table, const Type* callee, const Type* arg)$/;"	f	class:thorin::App
App	src/thorin/type.h	/^class App : public Type {$/;"	c	namespace:thorin
ArgParser	src/thorin/util/args.h	/^    ArgParser() {}$/;"	f	class:thorin::ArgParser
ArgParser	src/thorin/util/args.h	/^class ArgParser {$/;"	c	namespace:thorin
ArgsIterator	src/thorin/util/args.h	/^    ArgsIterator(int pos, char** argv)$/;"	f	class:thorin::ArgsIterator
ArgsIterator	src/thorin/util/args.h	/^class ArgsIterator : public std::iterator<std::forward_iterator_tag, const char*> {$/;"	c	namespace:thorin
ArithOp	src/thorin/primop.h	/^    ArithOp(ArithOpTag tag, const Def* lhs, const Def* rhs, Debug dbg)$/;"	f	class:thorin::ArithOp
ArithOp	src/thorin/primop.h	/^class ArithOp : public BinOp {$/;"	c	namespace:thorin
ArithOpTag	src/thorin/enums.h	/^enum ArithOpTag {$/;"	g	namespace:thorin
Array	src/thorin/util/array.h	/^    Array()$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(Array&& other)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(ArrayRef<T> ref)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(const Array& other)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(const I begin, const I end)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(const std::vector<T>& other)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(size_t size, const T& val)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(size_t size, std::function<T(size_t)> f)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    Array(std::initializer_list<T> list)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^    explicit Array(size_t size)$/;"	f	class:thorin::Array
Array	src/thorin/util/array.h	/^class Array {$/;"	c	namespace:thorin
ArrayRef	src/thorin/util/array.h	/^    ArrayRef()$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(const Array<T>& array)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(const ArrayRef<T>& ref)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(const T* ptr, size_t size)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(const std::array<T, N>& array)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(const std::vector<T>& vector)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^    ArrayRef(std::initializer_list<T> list)$/;"	f	class:thorin::ArrayRef
ArrayRef	src/thorin/util/array.h	/^class ArrayRef {$/;"	c	namespace:thorin
ArrayType	src/thorin/type.h	/^    ArrayType(TypeTable& table, int tag, const Type* elem_type)$/;"	f	class:thorin::ArrayType
ArrayType	src/thorin/type.h	/^class ArrayType : public Type {$/;"	c	namespace:thorin
Assembly	src/thorin/primop.cpp	/^Assembly::Assembly(const Type *type, Defs inputs, std::string asm_template, ArrayRef<std::string> output_constraints, ArrayRef<std::string> input_constraints, ArrayRef<std::string> clobbers, Flags flags, Debug dbg)$/;"	f	class:thorin::Assembly
Assembly	src/thorin/primop.h	/^class Assembly : public MemOp {$/;"	c	namespace:thorin
Atomic	src/thorin/continuation.h	/^    Atomic,                     \/\/\/< Intrinsic atomic function$/;"	m	class:thorin::Intrinsic
BBMap	src/thorin/be/llvm/llvm.h	/^typedef ContinuationMap<llvm::BasicBlock*> BBMap;$/;"	t	namespace:thorin
B_CFG	src/thorin/analyses/scope.h	/^typedef CFG<false> B_CFG;$/;"	t	namespace:thorin
Backends	src/thorin/be/llvm/llvm.cpp	/^Backends::Backends(World& world)$/;"	f	class:thorin::Backends
Backends	src/thorin/be/llvm/llvm.h	/^struct Backends {$/;"	s	namespace:thorin
BasicOption	src/thorin/util/args.h	/^    BasicOption(std::string param, std::string domain, std::string help, T* target)$/;"	f	class:thorin::BasicOption
BasicOption	src/thorin/util/args.h	/^class BasicOption {$/;"	c	namespace:thorin
Begin_AllNodes	src/thorin/enums.h	/^    Begin_AllNodes  = Begin_Node,$/;"	e	enum:thorin::Markers
Begin_Node	src/thorin/enums.h	/^    Begin_Node = 0,$/;"	e	enum:thorin::Markers
Begin_PrimType	src/thorin/enums.h	/^    Begin_PrimType  = Begin_PrimType_bool,$/;"	e	enum:thorin::Markers
BinOp	src/thorin/primop.h	/^    BinOp(NodeTag tag, const Type* type, const Def* lhs, const Def* rhs, Debug dbg)$/;"	f	class:thorin::BinOp
BinOp	src/thorin/primop.h	/^class BinOp : public PrimOp {$/;"	c	namespace:thorin
Bitcast	src/thorin/primop.h	/^    Bitcast(const Type* to, const Def* from, Debug dbg)$/;"	f	class:thorin::Bitcast
Bitcast	src/thorin/primop.h	/^class Bitcast : public ConvOp {$/;"	c	namespace:thorin
Black	src/thorin/analyses/verify.cpp	/^        Gray, Black$/;"	e	enum:thorin::Cycles::Color	file:
Block	src/thorin/analyses/schedule.h	/^        Block& operator=(Block) = delete;$/;"	m	class:thorin::Schedule::Block
Block	src/thorin/analyses/schedule.h	/^        Block() {}$/;"	f	class:thorin::Schedule::Block
Block	src/thorin/analyses/schedule.h	/^    class Block {$/;"	c	class:thorin::Schedule
Body	src/thorin/be/llvm/runtime.h	/^        Body,$/;"	e	enum:thorin::LaunchArgs::__anon6
Body	src/thorin/be/llvm/vectorize.cpp	/^        Body,$/;"	e	enum:thorin::VectorizeArgs::__anon2	file:
Bottom	src/thorin/primop.h	/^    Bottom(const Type* type, Debug dbg)$/;"	f	class:thorin::Bottom
Bottom	src/thorin/primop.h	/^class Bottom : public Literal {$/;"	c	namespace:thorin
BottomException	src/thorin/util/types.h	/^struct BottomException {};$/;"	s	namespace:thorin
BottomToTop	src/thorin/util/ycomp.h	/^    BottomToTop,$/;"	e	enum:thorin::YCompOrientation
Box	src/thorin/util/types.h	/^    Box( s8 val) { reset();  s8_ = val; } Box( u8 val) { reset();  u8_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box() : u64_() {}$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(f16 val) { reset(); f16_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(f32 val) { reset(); f32_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(f64 val) { reset(); f64_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(s16 val) { reset(); s16_ = val; } Box(u16 val) { reset(); u16_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(s32 val) { reset(); s32_ = val; } Box(u32 val) { reset(); u32_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^    Box(s64 val) { reset(); s64_ = val; } Box(u64 val) { reset(); u64_ = val; }$/;"	f	union:thorin::Box
Box	src/thorin/util/types.h	/^union Box {$/;"	u	namespace:thorin
Branch	src/thorin/continuation.h	/^    Branch,                     \/\/\/< branch(cond, T, F).$/;"	m	class:thorin::Intrinsic
BreakHash	src/thorin/world.h	/^    struct BreakHash {$/;"	s	class:thorin::World
Breakpoints	src/thorin/world.h	/^    typedef HashSet<size_t, BreakHash> Breakpoints;$/;"	t	class:thorin::World
C	src/thorin/continuation.h	/^    C,          \/\/\/< C calling convention.$/;"	m	class:thorin::CC
C99	src/thorin/be/c.h	/^    C99,    \/\/\/< Flag for C99$/;"	m	class:thorin::Lang
CACHED	src/thorin/transform/resolve_loads.cpp	160;"	d	file:
CACHED	src/thorin/transform/resolve_loads.cpp	236;"	d	file:
CC	src/thorin/continuation.h	/^enum class CC : uint8_t {$/;"	c	namespace:thorin
CCodeGen	src/thorin/be/c.cpp	/^    CCodeGen(World& world, const Cont2Config& kernel_config, std::ostream& stream, Lang lang, bool debug)$/;"	f	class:thorin::CCodeGen
CCodeGen	src/thorin/be/c.cpp	/^class CCodeGen {$/;"	c	namespace:thorin	file:
CFA	src/thorin/analyses/cfg.cpp	/^CFA::CFA(const Scope& scope)$/;"	f	class:thorin::CFA
CFA	src/thorin/analyses/cfg.h	/^    CFA& operator= (CFA) = delete;$/;"	m	class:thorin::CFA
CFA	src/thorin/analyses/cfg.h	/^class CFA {$/;"	c	namespace:thorin
CFG	src/thorin/analyses/cfg.cpp	/^CFG<forward>::CFG(const CFA& cfa)$/;"	f	class:thorin::CFG
CFG	src/thorin/analyses/cfg.h	/^    CFG& operator= (CFG) = delete;$/;"	m	class:thorin::CFG
CFG	src/thorin/analyses/cfg.h	/^class CFG : public YComp {$/;"	c	namespace:thorin
CFNode	src/thorin/analyses/cfg.h	/^    CFNode(Continuation* continuation)$/;"	f	class:thorin::CFNode
CFNode	src/thorin/analyses/cfg.h	/^class CFNode : public RuntimeCast<CFNode>, public Streamable {$/;"	c	namespace:thorin
CFNodes	src/thorin/analyses/cfg.h	/^typedef GIDSet<const CFNode*> CFNodes;$/;"	t	namespace:thorin
CMAKE_BINARY_DIR	build/Makefile	/^CMAKE_BINARY_DIR = \/home\/amiri\/anydsl\/thorin\/build$/;"	m
CMAKE_BINARY_DIR	build/src/Makefile	/^CMAKE_BINARY_DIR = \/home\/amiri\/anydsl\/thorin\/build$/;"	m
CMAKE_BINARY_DIR	build/src/thorin/Makefile	/^CMAKE_BINARY_DIR = \/home\/amiri\/anydsl\/thorin\/build$/;"	m
CMAKE_COMMAND	build/Makefile	/^CMAKE_COMMAND = \/opt\/cmake\/3.4.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/src/Makefile	/^CMAKE_COMMAND = \/opt\/cmake\/3.4.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/src/thorin/Makefile	/^CMAKE_COMMAND = \/opt\/cmake\/3.4.3\/bin\/cmake$/;"	m
CMAKE_SOURCE_DIR	build/Makefile	/^CMAKE_SOURCE_DIR = \/home\/amiri\/anydsl\/thorin$/;"	m
CMAKE_SOURCE_DIR	build/src/Makefile	/^CMAKE_SOURCE_DIR = \/home\/amiri\/anydsl\/thorin$/;"	m
CMAKE_SOURCE_DIR	build/src/thorin/Makefile	/^CMAKE_SOURCE_DIR = \/home\/amiri\/anydsl\/thorin$/;"	m
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	103;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	110;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	117;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	124;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	132;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	137;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	144;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	147;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	14;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	150;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	153;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	168;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	182;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	192;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	210;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	219;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	222;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	229;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	247;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	250;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	253;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	37;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	45;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	51;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	57;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	66;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	75;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	89;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	96;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	101;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	108;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	115;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	122;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	129;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	137;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	13;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	142;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	149;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	152;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	155;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	170;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	184;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	194;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	19;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	212;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	221;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	224;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	242;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	245;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	248;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	42;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	50;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	56;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	62;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	71;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	80;"	d	file:
COMPILER_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	94;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	105;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	112;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	119;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	125;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	133;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	139;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	157;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	172;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	183;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	194;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	19;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	213;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	224;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	232;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	237;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	38;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	46;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	53;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	59;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	68;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	78;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	83;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	91;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	98;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	103;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	110;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	117;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	124;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	130;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	138;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	144;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	159;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	15;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	174;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	185;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	196;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	215;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	227;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	232;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	24;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	43;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	51;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	58;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	64;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	73;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	83;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	88;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	96;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	106;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	113;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	120;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	126;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	134;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	140;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	158;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	173;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	185;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	195;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	20;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	214;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	225;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	233;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	238;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	39;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	47;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	54;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	60;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	69;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	79;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	84;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	92;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	99;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	104;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	111;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	118;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	125;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	131;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	139;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	145;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	160;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	16;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	175;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	187;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	197;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	216;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	228;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	233;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	25;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	44;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	52;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	59;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	65;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	74;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	84;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	89;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	97;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	100;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	107;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	114;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	121;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	128;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	141;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	159;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	174;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	188;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	199;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	202;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	215;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	226;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	22;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	234;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	239;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	24;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	41;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	48;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	62;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	71;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	80;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	85;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	93;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	105;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	112;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	119;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	126;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	133;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	146;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	161;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	176;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	190;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	201;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	204;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	217;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	229;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	234;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	27;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	29;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	46;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	53;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	67;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	76;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	85;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	90;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	98;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	165;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	206;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	28;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	167;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	208;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	33;"	d	file:
CPUCodeGen	src/thorin/be/llvm/cpu.cpp	/^CPUCodeGen::CPUCodeGen(World& world)$/;"	f	class:thorin::CPUCodeGen
CPUCodeGen	src/thorin/be/llvm/cpu.h	/^class CPUCodeGen : public CodeGen {$/;"	c	namespace:thorin
CPU_PLATFORM	src/thorin/be/llvm/runtime.h	/^        CPU_PLATFORM,$/;"	e	enum:thorin::Runtime::Platform
CUDA	src/thorin/be/c.h	/^    CUDA,   \/\/\/< Flag for CUDA$/;"	m	class:thorin::Lang
CUDA	src/thorin/continuation.h	/^    CUDA = _Accelerator_Begin,  \/\/\/< Internal CUDA-Backend.$/;"	m	class:thorin::Intrinsic
CUDACodeGen	src/thorin/be/llvm/cuda.cpp	/^CUDACodeGen::CUDACodeGen(World& world, const Cont2Config& kernel_config)$/;"	f	class:thorin::CUDACodeGen
CUDACodeGen	src/thorin/be/llvm/cuda.h	/^class CUDACodeGen : public CodeGen {$/;"	c	namespace:thorin
CUDA_PLATFORM	src/thorin/be/llvm/runtime.h	/^        CUDA_PLATFORM,$/;"	e	enum:thorin::Runtime::Platform
Call	src/thorin/continuation.h	/^    Call() {}$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^    Call(Array<const Def*> ops)$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^    Call(Array<const Def*>&& ops)$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^    Call(Call&& call)$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^    Call(const Call& call)$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^    Call(size_t num_ops)$/;"	f	struct:thorin::Call
Call	src/thorin/continuation.h	/^struct Call {$/;"	s	namespace:thorin
Cast	src/thorin/primop.h	/^    Cast(const Type* to, const Def* from, Debug dbg)$/;"	f	class:thorin::Cast
Cast	src/thorin/primop.h	/^class Cast : public ConvOp {$/;"	c	namespace:thorin
Cleaner	src/thorin/transform/cleanup_world.cpp	/^    Cleaner(World& world)$/;"	f	class:thorin::Cleaner
Cleaner	src/thorin/transform/cleanup_world.cpp	/^class Cleaner {$/;"	c	namespace:thorin	file:
Closure	src/thorin/primop.h	/^    Closure(const ClosureType* closure_type, const Def* fn, const Def* env, Debug dbg)$/;"	f	class:thorin::Closure
Closure	src/thorin/primop.h	/^class Closure : public Aggregate {$/;"	c	namespace:thorin
ClosureConversion	src/thorin/transform/closure_conversion.cpp	/^    ClosureConversion(World& world)$/;"	f	class:thorin::ClosureConversion
ClosureConversion	src/thorin/transform/closure_conversion.cpp	/^class ClosureConversion {$/;"	c	namespace:thorin	file:
ClosureType	src/thorin/type.h	/^    ClosureType(TypeTable& table, Types ops)$/;"	f	class:thorin::ClosureType
ClosureType	src/thorin/type.h	/^class ClosureType : public FnType {$/;"	c	namespace:thorin
Cmp	src/thorin/primop.cpp	/^Cmp::Cmp(CmpTag tag, const Def* lhs, const Def* rhs, Debug dbg)$/;"	f	class:thorin::Cmp
Cmp	src/thorin/primop.h	/^class Cmp : public BinOp {$/;"	c	namespace:thorin
CmpTag	src/thorin/enums.h	/^enum CmpTag {$/;"	g	namespace:thorin
CmpXchg	src/thorin/continuation.h	/^    CmpXchg,                    \/\/\/< Intrinsic cmpxchg function$/;"	m	class:thorin::Intrinsic
CodeGen	src/thorin/be/llvm/llvm.cpp	/^CodeGen::CodeGen(World& world, llvm::CallingConv::ID function_calling_convention, llvm::CallingConv::ID device_calling_convention, llvm::CallingConv::ID kernel_calling_convention)$/;"	f	class:thorin::CodeGen
CodeGen	src/thorin/be/llvm/llvm.h	/^class CodeGen {$/;"	c	namespace:thorin
Color	src/thorin/analyses/verify.cpp	/^    enum Color {$/;"	g	class:thorin::Cycles	file:
CondEval	src/thorin/transform/partial_evaluation.cpp	/^    CondEval(Continuation* callee, Defs args, ContinuationMap<bool>& top_level)$/;"	f	class:thorin::CondEval
CondEval	src/thorin/transform/partial_evaluation.cpp	/^class CondEval {$/;"	c	namespace:thorin	file:
Config	src/thorin/be/llvm/runtime.h	/^        Config,$/;"	e	enum:thorin::LaunchArgs::__anon6
Constant	src/thorin/type.h	/^    Constant = 4,$/;"	m	class:thorin::AddrSpace
Cont2Config	src/thorin/be/kernel_config.h	/^typedef ContinuationMap<std::unique_ptr<KernelConfig>> Cont2Config;$/;"	t	namespace:thorin
Continuation	src/thorin/continuation.h	/^    Continuation(const FnType* fn, CC cc, Intrinsic intrinsic, Debug dbg)$/;"	f	class:thorin::Continuation
Continuation	src/thorin/continuation.h	/^class Continuation : public Def {$/;"	c	namespace:thorin
Continuations	src/thorin/continuation.h	/^typedef std::vector<Continuation*> Continuations;$/;"	t	namespace:thorin
ControlDeps	src/thorin/analyses/domfrontier.h	/^typedef DomFrontierBase<false> ControlDeps;$/;"	t	namespace:thorin
ConvOp	src/thorin/primop.h	/^    ConvOp(NodeTag tag, const Def* from, const Type* to, Debug dbg)$/;"	f	class:thorin::ConvOp
ConvOp	src/thorin/primop.h	/^class ConvOp : public PrimOp {$/;"	c	namespace:thorin
CreateEdge	src/thorin/continuation.h	/^    CreateEdge,                 \/\/\/< Internal Flow-Graph-Backend.$/;"	m	class:thorin::Intrinsic
CreateGraph	src/thorin/continuation.h	/^    CreateGraph,                \/\/\/< Internal Flow-Graph-Backend.$/;"	m	class:thorin::Intrinsic
CreateTask	src/thorin/continuation.h	/^    CreateTask,                 \/\/\/< Internal Flow-Graph-Backend.$/;"	m	class:thorin::Intrinsic
Cycles	src/thorin/analyses/verify.cpp	/^    Cycles(World& world)$/;"	f	class:thorin::Cycles
Cycles	src/thorin/analyses/verify.cpp	/^class Cycles {$/;"	c	namespace:thorin	file:
DEC	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	420;"	d	file:
DEC	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	415;"	d	file:
DLOG	src/thorin/util/log.h	73;"	d
DLOG	src/thorin/util/log.h	75;"	d
Debug	src/thorin/util/location.h	/^    Debug(Location location)$/;"	f	class:thorin::Debug
Debug	src/thorin/util/location.h	/^    Debug(Location location, Symbol name)$/;"	f	class:thorin::Debug
Debug	src/thorin/util/location.h	/^    Debug(Symbol name)$/;"	f	class:thorin::Debug
Debug	src/thorin/util/location.h	/^class Debug : public Location {$/;"	c	namespace:thorin
Debug	src/thorin/util/log.h	/^        Debug, Verbose, Info, Warn, Error,$/;"	e	enum:thorin::Log::Level
Def	src/thorin/def.cpp	/^Def::Def(NodeTag tag, const Type* type, size_t size, Debug dbg)$/;"	f	class:thorin::Def
Def	src/thorin/def.h	/^class Def : public RuntimeCast<Def>, public Streamable {$/;"	c	namespace:thorin
Def2CFNode	src/thorin/analyses/schedule.cpp	/^typedef DefMap<const CFNode*> Def2CFNode;$/;"	t	namespace:thorin	file:
DefiniteArray	src/thorin/primop.cpp	/^DefiniteArray::DefiniteArray(World& world, const Type* elem, Defs args, Debug dbg)$/;"	f	class:thorin::DefiniteArray
DefiniteArray	src/thorin/primop.h	/^class DefiniteArray : public Aggregate {$/;"	c	namespace:thorin
DefiniteArrayType	src/thorin/type.h	/^    DefiniteArrayType(TypeTable& table, const Type* elem_type, u64 dim)$/;"	f	class:thorin::DefiniteArrayType
DefiniteArrayType	src/thorin/type.h	/^class DefiniteArrayType : public ArrayType {$/;"	c	namespace:thorin
Defs	src/thorin/def.h	/^typedef ArrayRef<const Def*> Defs;$/;"	t	namespace:thorin
Device	src/thorin/be/llvm/runtime.h	/^        Device,$/;"	e	enum:thorin::LaunchArgs::__anon6
Device	src/thorin/continuation.h	/^    Device,     \/\/\/< Device calling convention. These are special functions only available on a particular device.$/;"	m	class:thorin::CC
DomFrontierBase	src/thorin/analyses/domfrontier.h	/^    DomFrontierBase& operator=(DomFrontierBase) = delete;$/;"	m	class:thorin::DomFrontierBase
DomFrontierBase	src/thorin/analyses/domfrontier.h	/^    explicit DomFrontierBase(const CFG<forward> &cfg)$/;"	f	class:thorin::DomFrontierBase
DomFrontierBase	src/thorin/analyses/domfrontier.h	/^class DomFrontierBase : public YComp {$/;"	c	namespace:thorin
DomFrontiers	src/thorin/analyses/domfrontier.h	/^typedef DomFrontierBase<true>  DomFrontiers;$/;"	t	namespace:thorin
DomTree	src/thorin/analyses/domtree.h	/^typedef DomTreeBase<true>  DomTree;$/;"	t	namespace:thorin
DomTreeBase	src/thorin/analyses/domtree.h	/^    DomTreeBase& operator=(DomTreeBase) = delete;$/;"	m	class:thorin::DomTreeBase
DomTreeBase	src/thorin/analyses/domtree.h	/^    explicit DomTreeBase(const CFG<forward>& cfg)$/;"	f	class:thorin::DomTreeBase
DomTreeBase	src/thorin/analyses/domtree.h	/^class DomTreeBase : public YComp {$/;"	c	namespace:thorin
EDEF	src/thorin/util/log.h	63;"	d
ELOG	src/thorin/util/log.h	67;"	d
EQUALS	build/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/src/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/src/thorin/Makefile	/^EQUALS = =$/;"	m
Early	src/thorin/analyses/schedule.h	/^    enum Tag { Early, Late, Smart };$/;"	e	enum:thorin::Schedule::Tag
EndScope	src/thorin/continuation.h	/^    EndScope,                   \/\/\/< Dummy function which marks the end of a @p Scope.$/;"	m	class:thorin::Intrinsic
End_AllNodes	src/thorin/enums.h	/^    End_AllNodes    = End_Cmp,$/;"	e	enum:thorin::Markers
End_Cmp	src/thorin/enums.h	/^    End_Cmp,$/;"	e	enum:thorin::Markers
End_PrimType	src/thorin/enums.h	/^    End_PrimType    = End_PrimType_qf,$/;"	e	enum:thorin::Markers
Enter	src/thorin/primop.cpp	/^Enter::Enter(const Def* mem, Debug dbg)$/;"	f	class:thorin::Enter
Enter	src/thorin/primop.h	/^class Enter : public MemOp {$/;"	c	namespace:thorin
Error	src/thorin/util/log.h	/^        Debug, Verbose, Info, Warn, Error,$/;"	e	enum:thorin::Log::Level
ExecuteGraph	src/thorin/continuation.h	/^    ExecuteGraph,               \/\/\/< Internal Flow-Graph-Backend.$/;"	m	class:thorin::Intrinsic
Extract	src/thorin/primop.h	/^    Extract(const Def* agg, const Def* index, Debug dbg)$/;"	f	class:thorin::Extract
Extract	src/thorin/primop.h	/^class Extract : public AggOp {$/;"	c	namespace:thorin
FNV1	src/thorin/util/hash.h	/^struct FNV1 {$/;"	s	namespace:thorin
F_CFG	src/thorin/analyses/scope.h	/^typedef CFG<true>  F_CFG;$/;"	t	namespace:thorin
Flags	src/thorin/primop.h	/^    enum Flags {$/;"	g	class:thorin::Assembly
Float	src/thorin/util/types.h	/^    Float(FT data)$/;"	f	class:thorin::Float
Float	src/thorin/util/types.h	/^class Float {$/;"	c	namespace:thorin
FnType	src/thorin/type.h	/^    FnType(TypeTable& table, Types ops, int tag = Node_FnType)$/;"	f	class:thorin::FnType
FnType	src/thorin/type.h	/^class FnType : public Type {$/;"	c	namespace:thorin
FrameType	src/thorin/type.h	/^    FrameType(TypeTable& table)$/;"	f	class:thorin::FrameType
FrameType	src/thorin/type.h	/^class FrameType : public Type {$/;"	c	namespace:thorin
GIDHash	src/thorin/util/type_table.h	/^struct GIDHash {$/;"	s	namespace:thorin
GIDLt	src/thorin/util/type_table.h	/^struct GIDLt {$/;"	s	namespace:thorin
GPUKernelConfig	src/thorin/be/kernel_config.h	/^    GPUKernelConfig(std::tuple<int, int, int> block, bool has_restrict = false)$/;"	f	class:thorin::GPUKernelConfig
GPUKernelConfig	src/thorin/be/kernel_config.h	/^class GPUKernelConfig : public KernelConfig {$/;"	c	namespace:thorin
Generic	src/thorin/type.h	/^    Generic  = 0,$/;"	m	class:thorin::AddrSpace
Global	src/thorin/primop.cpp	/^Global::Global(const Def* init, bool is_mutable, Debug dbg)$/;"	f	class:thorin::Global
Global	src/thorin/primop.h	/^class Global : public PrimOp {$/;"	c	namespace:thorin
Global	src/thorin/type.h	/^    Global   = 1,$/;"	m	class:thorin::AddrSpace
Gray	src/thorin/analyses/verify.cpp	/^        Gray, Black$/;"	e	enum:thorin::Cycles::Color	file:
HALF_ROUND_STYLE	src/thorin/util/types.h	14;"	d
HALF_ROUND_TIES_TO_EVEN	src/thorin/util/types.h	15;"	d
HEX	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	431;"	d	file:
HEX	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	426;"	d	file:
HLS	src/thorin/be/c.h	/^    HLS,    \/\/\/< Flag for HLS$/;"	m	class:thorin::Lang
HLS	src/thorin/continuation.h	/^    HLS,                        \/\/\/< Internal HLS-Backend.$/;"	m	class:thorin::Intrinsic
HLSCodeGen	src/thorin/be/llvm/hls.cpp	/^HLSCodeGen::HLSCodeGen(World& world, const Cont2Config& kernel_config)$/;"	f	class:thorin::HLSCodeGen
HLSCodeGen	src/thorin/be/llvm/hls.h	/^class HLSCodeGen : public CodeGen {$/;"	c	namespace:thorin
HLSKernelConfig	src/thorin/be/kernel_config.h	/^    HLSKernelConfig(const Param2Size& param_sizes)$/;"	f	class:thorin::HLSKernelConfig
HLSKernelConfig	src/thorin/be/kernel_config.h	/^class HLSKernelConfig : public KernelConfig {$/;"	c	namespace:thorin
HSA_PLATFORM	src/thorin/be/llvm/runtime.h	/^        HSA_PLATFORM$/;"	e	enum:thorin::Runtime::Platform
HasSideEffects	src/thorin/primop.h	/^        HasSideEffects = 1 << 0,$/;"	e	enum:thorin::Assembly::Flags
Hash	src/thorin/continuation.h	/^    struct Hash {$/;"	s	struct:thorin::Call
Hash	src/thorin/util/symbol.h	/^    struct Hash {$/;"	s	class:thorin::Symbol
HashMap	src/thorin/util/hash.h	/^    HashMap()$/;"	f	class:thorin::HashMap
HashMap	src/thorin/util/hash.h	/^    HashMap(InputIt first, InputIt last)$/;"	f	class:thorin::HashMap
HashMap	src/thorin/util/hash.h	/^    HashMap(size_t capacity)$/;"	f	class:thorin::HashMap
HashMap	src/thorin/util/hash.h	/^    HashMap(std::initializer_list<value_type> ilist)$/;"	f	class:thorin::HashMap
HashMap	src/thorin/util/hash.h	/^class HashMap : public detail::HashTable<Key, T, H> {$/;"	c	namespace:thorin
HashSet	src/thorin/util/hash.h	/^    HashSet() {}$/;"	f	class:thorin::HashSet
HashSet	src/thorin/util/hash.h	/^    HashSet(InputIt first, InputIt last)$/;"	f	class:thorin::HashSet
HashSet	src/thorin/util/hash.h	/^    HashSet(size_t capacity)$/;"	f	class:thorin::HashSet
HashSet	src/thorin/util/hash.h	/^    HashSet(std::initializer_list<value_type> ilist)$/;"	f	class:thorin::HashSet
HashSet	src/thorin/util/hash.h	/^class HashSet : public detail::HashTable<Key, void, H> {$/;"	c	namespace:thorin
HashTable	src/thorin/util/hash.h	/^    HashTable()$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^    HashTable(HashTable&& other)$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^    HashTable(InputIt first, InputIt last)$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^    HashTable(const HashTable& other)$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^    HashTable(size_t capacity)$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^    HashTable(std::initializer_list<value_type> ilist)$/;"	f	class:thorin::detail::HashTable
HashTable	src/thorin/util/hash.h	/^class HashTable {$/;"	c	namespace:thorin::detail
Head	src/thorin/analyses/looptree.cpp	/^    typedef typename LoopTree<forward>::Head Head;$/;"	t	class:thorin::LoopTreeBuilder	file:
Head	src/thorin/analyses/looptree.h	/^        Head(Head* parent, int depth, const std::vector<const CFNode*>& cf_nodes)$/;"	f	class:thorin::LoopTree::Head
Head	src/thorin/analyses/looptree.h	/^    class Head : public Node {$/;"	c	class:thorin::LoopTree
Hlt	src/thorin/primop.h	/^    Hlt(const Def* def, Debug dbg)$/;"	f	class:thorin::Hlt
Hlt	src/thorin/primop.h	/^class Hlt : public PrimOp {$/;"	c	namespace:thorin
IDEF	src/thorin/util/log.h	65;"	d
ID_VOID_MAIN	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	6;"	d	file:
ILOG	src/thorin/util/log.h	69;"	d
ImplicitOption	src/thorin/util/args.h	/^    ImplicitOption(std::string domain, std::string help, target_type& target)$/;"	f	struct:thorin::ImplicitOption
ImplicitOption	src/thorin/util/args.h	/^struct ImplicitOption : BasicOption<std::vector<std::string>> {$/;"	s	namespace:thorin
Importer	src/thorin/transform/importer.h	/^    Importer(World& src)$/;"	f	class:thorin::Importer
Importer	src/thorin/transform/importer.h	/^class Importer {$/;"	c	namespace:thorin
InSCC	src/thorin/analyses/looptree.cpp	/^    InSCC    = 1, \/\/ is in current walk_scc run?$/;"	e	enum:thorin::__anon1	file:
IndefiniteArray	src/thorin/primop.cpp	/^IndefiniteArray::IndefiniteArray(World& world, const Type* elem, const Def* dim, Debug dbg)$/;"	f	class:thorin::IndefiniteArray
IndefiniteArray	src/thorin/primop.h	/^class IndefiniteArray : public Aggregate {$/;"	c	namespace:thorin
IndefiniteArrayType	src/thorin/type.h	/^    IndefiniteArrayType(TypeTable& table, const Type* elem_type)$/;"	f	class:thorin::IndefiniteArrayType
IndefiniteArrayType	src/thorin/type.h	/^class IndefiniteArrayType : public ArrayType {$/;"	c	namespace:thorin
IndexHash	src/thorin/transform/split_slots.cpp	/^struct IndexHash {$/;"	s	namespace:thorin	file:
IndexMap	src/thorin/util/indexmap.h	/^    IndexMap(IndexMap&& other)$/;"	f	class:thorin::IndexMap
IndexMap	src/thorin/util/indexmap.h	/^    IndexMap(const IndexMap& other)$/;"	f	class:thorin::IndexMap
IndexMap	src/thorin/util/indexmap.h	/^    IndexMap(const Indexer& indexer, ArrayRef<Value> array)$/;"	f	class:thorin::IndexMap
IndexMap	src/thorin/util/indexmap.h	/^    IndexMap(const Indexer& indexer, const I begin, const I end)$/;"	f	class:thorin::IndexMap
IndexMap	src/thorin/util/indexmap.h	/^    IndexMap(const Indexer& indexer, const Value& value = Value())$/;"	f	class:thorin::IndexMap
IndexMap	src/thorin/util/indexmap.h	/^class IndexMap {$/;"	c	namespace:thorin
IndexSet	src/thorin/util/indexset.h	/^    IndexSet(IndexSet&& other)$/;"	f	class:thorin::IndexSet
IndexSet	src/thorin/util/indexset.h	/^    IndexSet(const IndexSet& other)$/;"	f	class:thorin::IndexSet
IndexSet	src/thorin/util/indexset.h	/^    IndexSet(const Indexer& indexer)$/;"	f	class:thorin::IndexSet
IndexSet	src/thorin/util/indexset.h	/^class IndexSet {$/;"	c	namespace:thorin
Info	src/thorin/util/log.h	/^        Debug, Verbose, Info, Warn, Error,$/;"	e	enum:thorin::Log::Level
Insert	src/thorin/primop.h	/^    Insert(const Def* agg, const Def* index, const Def* value, Debug dbg)$/;"	f	class:thorin::Insert
Insert	src/thorin/primop.h	/^class Insert : public AggOp {$/;"	c	namespace:thorin
Intrinsic	src/thorin/continuation.h	/^enum class Intrinsic : uint8_t {$/;"	c	namespace:thorin
IsAlignStack	src/thorin/primop.h	/^        IsAlignStack   = 1 << 1,$/;"	e	enum:thorin::Assembly::Flags
IsHead	src/thorin/analyses/looptree.cpp	/^    IsHead   = 4, \/\/ all heads are marked, so subsequent runs can ignore backedges when searching for SCCs$/;"	e	enum:thorin::__anon1	file:
IsIntelDialect	src/thorin/primop.h	/^        IsIntelDialect = 1 << 2,$/;"	e	enum:thorin::Assembly::Flags
IsValidPred	src/thorin/util/indexmap.h	/^    struct IsValidPred {$/;"	s	class:thorin::IndexMap
IsValidPred	src/thorin/util/indexmap.h	/^    struct IsValidPred<T*> {$/;"	s	class:thorin::IndexMap
KernelConfig	src/thorin/be/kernel_config.h	/^class KernelConfig : public RuntimeCast<KernelConfig> {$/;"	c	namespace:thorin
Known	src/thorin/primop.cpp	/^Known::Known(const Def* def, Debug dbg)$/;"	f	class:thorin::Known
Known	src/thorin/primop.h	/^class Known : public PrimOp {$/;"	c	namespace:thorin
LEA	src/thorin/primop.cpp	/^LEA::LEA(const Def* ptr, const Def* index, Debug dbg)$/;"	f	class:thorin::LEA
LEA	src/thorin/primop.h	/^class LEA : public PrimOp {$/;"	c	namespace:thorin
Lambda	src/thorin/type.h	/^    Lambda(TypeTable& table, const Type* body, const char* name)$/;"	f	class:thorin::Lambda
Lambda	src/thorin/type.h	/^class Lambda : public Type {$/;"	c	namespace:thorin
Lang	src/thorin/be/c.h	/^enum class Lang : uint8_t {$/;"	c	namespace:thorin
Late	src/thorin/analyses/schedule.h	/^    enum Tag { Early, Late, Smart };$/;"	e	enum:thorin::Schedule::Tag
LaunchArgs	src/thorin/be/llvm/runtime.h	/^struct LaunchArgs {$/;"	s	namespace:thorin
Leaf	src/thorin/analyses/looptree.cpp	/^    typedef typename LoopTree<forward>::Leaf Leaf;$/;"	t	class:thorin::LoopTreeBuilder	file:
Leaf	src/thorin/analyses/looptree.h	/^        Leaf(size_t index, Head* parent, int depth, const std::vector<const CFNode*>& cf_nodes)$/;"	f	class:thorin::LoopTree::Leaf
Leaf	src/thorin/analyses/looptree.h	/^    class Leaf : public Node {$/;"	c	class:thorin::LoopTree
LeftToRight	src/thorin/util/ycomp.h	/^    LeftToRight = 0,$/;"	e	enum:thorin::YCompOrientation
Length	src/thorin/be/llvm/vectorize.cpp	/^        Length,$/;"	e	enum:thorin::VectorizeArgs::__anon2	file:
Level	src/thorin/util/log.h	/^    enum Level {$/;"	g	class:thorin::Log
Literal	src/thorin/primop.h	/^    Literal(NodeTag tag, const Type* type, Debug dbg)$/;"	f	class:thorin::Literal
Literal	src/thorin/primop.h	/^class Literal : public PrimOp {$/;"	c	namespace:thorin
Load	src/thorin/primop.cpp	/^Load::Load(const Def* mem, const Def* ptr, Debug dbg)$/;"	f	class:thorin::Load
Load	src/thorin/primop.h	/^class Load : public Access {$/;"	c	namespace:thorin
Location	src/thorin/util/location.h	/^    Location(Location front, Location back)$/;"	f	class:thorin::Location
Location	src/thorin/util/location.h	/^    Location(const char* filename, uint32_t front_line, uint32_t front_col, uint32_t back_line, uint32_t back_col)$/;"	f	class:thorin::Location
Location	src/thorin/util/location.h	/^    Location(const char* filename, uint32_t line, uint32_t col)$/;"	f	class:thorin::Location
Location	src/thorin/util/location.h	/^class Location {$/;"	c	namespace:thorin
Log	src/thorin/util/log.h	/^class Log {$/;"	c	namespace:thorin
LoopTree	src/thorin/analyses/looptree.cpp	/^LoopTree<forward>::LoopTree(const CFG<forward>& cfg)$/;"	f	class:thorin::LoopTree
LoopTree	src/thorin/analyses/looptree.h	/^    LoopTree& operator=(LoopTree) = delete;$/;"	m	class:thorin::LoopTree
LoopTree	src/thorin/analyses/looptree.h	/^class LoopTree : public YComp {$/;"	c	namespace:thorin
LoopTreeBuilder	src/thorin/analyses/looptree.cpp	/^    LoopTreeBuilder(LoopTree<forward>& looptree)$/;"	f	class:thorin::LoopTreeBuilder
LoopTreeBuilder	src/thorin/analyses/looptree.cpp	/^class LoopTreeBuilder {$/;"	c	namespace:thorin	file:
Mangler	src/thorin/transform/mangle.cpp	/^Mangler::Mangler(const Scope& scope, Defs args, Defs lift)$/;"	f	class:thorin::Mangler
Mangler	src/thorin/transform/mangle.h	/^class Mangler {$/;"	c	namespace:thorin
Markers	src/thorin/enums.h	/^enum Markers {$/;"	g	namespace:thorin
Match	src/thorin/continuation.h	/^    Match,                      \/\/\/< match(val, otherwise, (case1, cont1), (case2, cont2), ...)$/;"	m	class:thorin::Intrinsic
Mem	src/thorin/be/llvm/runtime.h	/^        Mem = 0,$/;"	e	enum:thorin::LaunchArgs::__anon6
Mem	src/thorin/be/llvm/vectorize.cpp	/^        Mem = 0,$/;"	e	enum:thorin::VectorizeArgs::__anon2	file:
MemOp	src/thorin/primop.h	/^    MemOp(NodeTag tag, const Type* type, Defs args, Debug dbg)$/;"	f	class:thorin::MemOp
MemOp	src/thorin/primop.h	/^class MemOp : public PrimOp {$/;"	c	namespace:thorin
MemType	src/thorin/type.h	/^    MemType(TypeTable& table)$/;"	f	class:thorin::MemType
MemType	src/thorin/type.h	/^class MemType : public Type {$/;"	c	namespace:thorin
MinHeapCapacity	src/thorin/util/hash.h	/^    enum { MinHeapCapacity = StackCapacity*4 };$/;"	e	enum:thorin::detail::HashTable::__anon9
NVVM	src/thorin/continuation.h	/^    NVVM,                       \/\/\/< Internal NNVM-Backend.$/;"	m	class:thorin::Intrinsic
NVVMCodeGen	src/thorin/be/llvm/nvvm.cpp	/^NVVMCodeGen::NVVMCodeGen(World& world, const Cont2Config& kernel_config)$/;"	f	class:thorin::NVVMCodeGen
NVVMCodeGen	src/thorin/be/llvm/nvvm.h	/^class NVVMCodeGen : public CodeGen {$/;"	c	namespace:thorin
NoFlag	src/thorin/primop.h	/^        NoFlag         = 0,$/;"	e	enum:thorin::Assembly::Flags
Node	src/thorin/analyses/looptree.cpp	/^    typedef typename LoopTree<forward>::Node Node;$/;"	t	class:thorin::LoopTreeBuilder	file:
Node	src/thorin/analyses/looptree.cpp	/^LoopTree<forward>::Node::Node(Head* parent, int depth, const std::vector<const CFNode*>& cf_nodes)$/;"	f	class:thorin::LoopTree::Node
Node	src/thorin/analyses/looptree.h	/^    class Node : public RuntimeCast<Node>, public Streamable {$/;"	c	class:thorin::LoopTree
NodeTag	src/thorin/enums.h	/^enum NodeTag {$/;"	g	namespace:thorin
None	src/thorin/continuation.h	/^    None,                       \/\/\/< Not an intrinsic.$/;"	m	class:thorin::Intrinsic
Num	src/thorin/be/llvm/runtime.h	/^        Num$/;"	e	enum:thorin::LaunchArgs::__anon6
Num	src/thorin/be/llvm/vectorize.cpp	/^        Num$/;"	e	enum:thorin::VectorizeArgs::__anon2	file:
Num	src/thorin/util/ycomp.h	/^    Num$/;"	e	enum:thorin::YCompOrientation
Num	src/thorin/util/ycomp.h	/^static_assert(sizeof(YCompOrientation_Names)\/sizeof(char*) == YCompOrientation::Num, "Sizes do not match!");$/;"	m	class:thorin::YCompOrientation
Num_AllNodes	src/thorin/enums.h	/^    Num_AllNodes    = End_AllNodes   - Begin_AllNodes,$/;"	e	enum:thorin::Markers
Num_ArithOps	src/thorin/enums.h	/^    Num_ArithOps    = End_ArithOp    - Begin_ArithOp,$/;"	e	enum:thorin::Markers
Num_Cmps	src/thorin/enums.h	/^    Num_Cmps        = End_Cmp        - Begin_Cmp,$/;"	e	enum:thorin::Markers
Num_Nodes	src/thorin/enums.h	/^    Num_Nodes       = End_Node       - Begin_Node,$/;"	e	enum:thorin::Markers
Num_PrimTypes	src/thorin/enums.h	/^    Num_PrimTypes   = End_PrimType_qf - Begin_PrimType_bool,$/;"	e	enum:thorin::Markers
Number	src/thorin/analyses/looptree.cpp	/^        Number()$/;"	f	struct:thorin::LoopTreeBuilder::Number
Number	src/thorin/analyses/looptree.cpp	/^        Number(size_t i)$/;"	f	struct:thorin::LoopTreeBuilder::Number
Number	src/thorin/analyses/looptree.cpp	/^    struct Number {$/;"	s	class:thorin::LoopTreeBuilder	file:
OPENCL_PLATFORM	src/thorin/be/llvm/runtime.h	/^        OPENCL_PLATFORM,$/;"	e	enum:thorin::Runtime::Platform
OnStack	src/thorin/analyses/looptree.cpp	/^    OnStack  = 2, \/\/ is in current SCC stack?$/;"	e	enum:thorin::__anon1	file:
OpenCL	src/thorin/continuation.h	/^    OpenCL,                     \/\/\/< Internal OpenCL-Backend.$/;"	m	class:thorin::Intrinsic
OpenCLCodeGen	src/thorin/be/llvm/opencl.cpp	/^OpenCLCodeGen::OpenCLCodeGen(World& world, const Cont2Config& kernel_config)$/;"	f	class:thorin::OpenCLCodeGen
OpenCLCodeGen	src/thorin/be/llvm/opencl.h	/^class OpenCLCodeGen : public CodeGen {$/;"	c	namespace:thorin
Option	src/thorin/util/args.h	/^    Option()$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, Data* target, const Data& init = Data())$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, OptionStringVector* target, const OptionStringVector& init)$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, YCompCommandLine* target, const YCompCommandLine& init)$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, bool* target, bool init)$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, int* target, int init)$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^    Option(const T& previous, std::string param, std::string domain, std::string help, std::string* target, std::string init)$/;"	f	struct:thorin::Option
Option	src/thorin/util/args.h	/^struct Option : public OptionBase<Data, T, Option<Data, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<OptionStringVector, T> : public OptionBase<OptionStringVector, T, Option<OptionStringVector, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<YCompCommandLine, T> : public OptionBase<YCompCommandLine, T, Option<YCompCommandLine, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<bool, T> : public OptionBase<bool, T, Option<bool, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<int, T> : public OptionBase<int, T, Option<int, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<std::string, T> : public OptionBase<std::string, T, Option<std::string, T>> {$/;"	s	namespace:thorin
Option	src/thorin/util/args.h	/^struct Option<void, void> : public BasicOption<void> {$/;"	s	namespace:thorin
OptionBase	src/thorin/util/args.h	/^    OptionBase(const T& previous, std::string param, std::string domain, std::string help, Data* target, const Data& init)$/;"	f	class:thorin::OptionBase
OptionBase	src/thorin/util/args.h	/^class OptionBase : public BasicOption<Data> {$/;"	c	namespace:thorin
OptionStringVector	src/thorin/util/args.h	/^typedef std::vector<std::string> OptionStringVector;$/;"	t	namespace:thorin
PAR_ARG_BODY	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_BODY,$/;"	e	enum:thorin::__anon3	file:
PAR_ARG_LOWER	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_LOWER,$/;"	e	enum:thorin::__anon3	file:
PAR_ARG_MEM	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_MEM,$/;"	e	enum:thorin::__anon3	file:
PAR_ARG_NUMTHREADS	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_NUMTHREADS,$/;"	e	enum:thorin::__anon3	file:
PAR_ARG_RETURN	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_RETURN,$/;"	e	enum:thorin::__anon3	file:
PAR_ARG_UPPER	src/thorin/be/llvm/parallel.cpp	/^    PAR_ARG_UPPER,$/;"	e	enum:thorin::__anon3	file:
PAR_NUM_ARGS	src/thorin/be/llvm/parallel.cpp	/^    PAR_NUM_ARGS$/;"	e	enum:thorin::__anon3	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	274;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	277;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	280;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	283;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	286;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	289;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	292;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	295;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	298;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	301;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	304;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	307;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	310;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	313;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	316;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	319;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	322;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	325;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	328;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	331;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	334;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	337;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	340;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	343;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	346;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	350;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	353;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	356;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	359;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	362;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	366;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	269;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	272;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	275;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	278;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	281;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	284;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	287;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	290;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	293;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	296;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	299;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	302;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	305;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	308;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	311;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	314;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	317;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	320;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	323;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	326;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	329;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	332;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	335;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	338;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	341;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	345;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	348;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	351;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	354;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	357;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	361;"	d	file:
Parallel	src/thorin/continuation.h	/^    Parallel,                   \/\/\/< Internal Parallel-CPU-Backend.$/;"	m	class:thorin::Intrinsic
Param	src/thorin/continuation.h	/^    Param(const Type* type, Continuation* continuation, size_t index, Debug dbg)$/;"	f	class:thorin::Param
Param	src/thorin/continuation.h	/^class Param : public Def {$/;"	c	namespace:thorin
Param2Size	src/thorin/be/kernel_config.h	/^    typedef GIDMap<const Param*, uint32_t> Param2Size;$/;"	t	class:thorin::HLSKernelConfig
PartialEvaluator	src/thorin/transform/partial_evaluation.cpp	/^    PartialEvaluator(World& world, bool lower2cff)$/;"	f	class:thorin::PartialEvaluator
PartialEvaluator	src/thorin/transform/partial_evaluation.cpp	/^class PartialEvaluator {$/;"	c	namespace:thorin	file:
PeInfo	src/thorin/continuation.h	/^    PeInfo,                     \/\/\/< Partial evaluation debug info.$/;"	m	class:thorin::Intrinsic
Peek	src/thorin/continuation.h	/^        Peek() {}$/;"	f	class:thorin::Param::Peek
Peek	src/thorin/continuation.h	/^        Peek(const Def* def, Continuation* from)$/;"	f	class:thorin::Param::Peek
Peek	src/thorin/continuation.h	/^    class Peek {$/;"	c	class:thorin::Param
Pipeline	src/thorin/continuation.h	/^    Pipeline,                   \/\/\/< Intrinsic loop-piplining-HLS-Backend$/;"	m	class:thorin::Intrinsic
PipelineContinue	src/thorin/continuation.h	/^    PipelineContinue,           \/\/\/< Intrinsic loop-pipelining-HLS-Backend$/;"	m	class:thorin::Intrinsic
Platform	src/thorin/be/llvm/runtime.h	/^    enum Platform {$/;"	g	class:thorin::Runtime
PostDomTree	src/thorin/analyses/domtree.h	/^typedef DomTreeBase<false> PostDomTree;$/;"	t	namespace:thorin
PrimLit	src/thorin/primop.cpp	/^PrimLit::PrimLit(World& world, PrimTypeTag tag, Box box, Debug dbg)$/;"	f	class:thorin::PrimLit
PrimLit	src/thorin/primop.h	/^class PrimLit : public Literal {$/;"	c	namespace:thorin
PrimOp	src/thorin/primop.h	/^    PrimOp(NodeTag tag, const Type* type, Defs args, Debug dbg)$/;"	f	class:thorin::PrimOp
PrimOp	src/thorin/primop.h	/^class PrimOp : public Def {$/;"	c	namespace:thorin
PrimOpHash	src/thorin/primop.h	/^struct PrimOpHash {$/;"	s	namespace:thorin
PrimOpSet	src/thorin/world.h	/^    typedef HashSet<const PrimOp*, PrimOpHash> PrimOpSet;$/;"	t	class:thorin::World
PrimType	src/thorin/type.h	/^    PrimType(TypeTable& table, PrimTypeTag tag, size_t length)$/;"	f	class:thorin::PrimType
PrimType	src/thorin/type.h	/^class PrimType : public VectorType {$/;"	c	namespace:thorin
PrimTypeTag	src/thorin/enums.h	/^enum PrimTypeTag {$/;"	g	namespace:thorin
PtrType	src/thorin/type.h	/^    PtrType(TypeTable& table, const Type* pointee, size_t length, int32_t device, AddrSpace addr_space)$/;"	f	class:thorin::PtrType
PtrType	src/thorin/type.h	/^class PtrType : public VectorType {$/;"	c	namespace:thorin
Push	src/thorin/util/utility.h	/^    Push(T& t, T new_val)$/;"	f	struct:thorin::Push
Push	src/thorin/util/utility.h	/^struct Push {$/;"	s	namespace:thorin
RM	build/Makefile	/^RM = \/opt\/cmake\/3.4.3\/bin\/cmake -E remove -f$/;"	m
RM	build/src/Makefile	/^RM = \/opt\/cmake\/3.4.3\/bin\/cmake -E remove -f$/;"	m
RM	build/src/thorin/Makefile	/^RM = \/opt\/cmake\/3.4.3\/bin\/cmake -E remove -f$/;"	m
Range	src/thorin/util/iterator.h	/^    Range(I begin, I end)$/;"	f	struct:thorin::Range
Range	src/thorin/util/iterator.h	/^struct Range {$/;"	s	namespace:thorin
Reserve	src/thorin/continuation.h	/^    Reserve = _Accelerator_End, \/\/\/< Intrinsic memory reserve function$/;"	m	class:thorin::Intrinsic
ResolveLoads	src/thorin/transform/resolve_loads.cpp	/^    ResolveLoads(World& world)$/;"	f	class:thorin::ResolveLoads
ResolveLoads	src/thorin/transform/resolve_loads.cpp	/^class ResolveLoads {$/;"	c	namespace:thorin	file:
Return	src/thorin/be/llvm/runtime.h	/^        Return,$/;"	e	enum:thorin::LaunchArgs::__anon6
Return	src/thorin/be/llvm/vectorize.cpp	/^        Return,$/;"	e	enum:thorin::VectorizeArgs::__anon2	file:
Rewriter	src/thorin/transform/mangle.h	/^struct Rewriter {$/;"	s	namespace:thorin
RightToLeft	src/thorin/util/ycomp.h	/^    RightToLeft,$/;"	e	enum:thorin::YCompOrientation
Run	src/thorin/primop.h	/^    Run(const Def* def, Debug dbg)$/;"	f	class:thorin::Run
Run	src/thorin/primop.h	/^class Run : public PrimOp {$/;"	c	namespace:thorin
Runtime	src/thorin/be/llvm/runtime.cpp	/^Runtime::Runtime(llvm::LLVMContext& context,$/;"	f	class:thorin::Runtime
Runtime	src/thorin/be/llvm/runtime.h	/^class Runtime {$/;"	c	namespace:thorin
RuntimeCast	src/thorin/util/cast.h	/^class RuntimeCast {$/;"	c	namespace:thorin
SHELL	build/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/src/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/src/thorin/Makefile	/^SHELL = \/bin\/sh$/;"	m
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	155;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	16;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	170;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	157;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	172;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	21;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	162;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	177;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	32;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	164;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	179;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	37;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	163;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	178;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	33;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	165;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	180;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	38;"	d	file:
SInt	src/thorin/util/types.h	/^    SInt(ST data)$/;"	f	class:thorin::SInt
SInt	src/thorin/util/types.h	/^class SInt {$/;"	c	namespace:thorin
SPAWN_ARG_BODY	src/thorin/be/llvm/parallel.cpp	/^    SPAWN_ARG_BODY,$/;"	e	enum:thorin::__anon4	file:
SPAWN_ARG_MEM	src/thorin/be/llvm/parallel.cpp	/^    SPAWN_ARG_MEM,$/;"	e	enum:thorin::__anon4	file:
SPAWN_ARG_RETURN	src/thorin/be/llvm/parallel.cpp	/^    SPAWN_ARG_RETURN,$/;"	e	enum:thorin::__anon4	file:
SPAWN_NUM_ARGS	src/thorin/be/llvm/parallel.cpp	/^    SPAWN_NUM_ARGS$/;"	e	enum:thorin::__anon4	file:
STRINGIFY	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	270;"	d	file:
STRINGIFY	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	265;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	269;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	264;"	d	file:
SUFFIXES	build/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/src/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/src/thorin/Makefile	/^SUFFIXES =$/;"	m
SYNC_ARG_ID	src/thorin/be/llvm/parallel.cpp	/^    SYNC_ARG_ID,$/;"	e	enum:thorin::__anon5	file:
SYNC_ARG_MEM	src/thorin/be/llvm/parallel.cpp	/^    SYNC_ARG_MEM,$/;"	e	enum:thorin::__anon5	file:
SYNC_ARG_RETURN	src/thorin/be/llvm/parallel.cpp	/^    SYNC_ARG_RETURN,$/;"	e	enum:thorin::__anon5	file:
SYNC_NUM_ARGS	src/thorin/be/llvm/parallel.cpp	/^    SYNC_NUM_ARGS$/;"	e	enum:thorin::__anon5	file:
Schedule	src/thorin/analyses/schedule.cpp	/^Schedule::Schedule(const Scope& scope, Tag tag)$/;"	f	class:thorin::Schedule
Schedule	src/thorin/analyses/schedule.h	/^    Schedule& operator=(Schedule) = delete;$/;"	m	class:thorin::Schedule
Schedule	src/thorin/analyses/schedule.h	/^    Schedule(Schedule&& other)$/;"	f	class:thorin::Schedule
Schedule	src/thorin/analyses/schedule.h	/^class Schedule : public Streamable {$/;"	c	namespace:thorin
Scheduler	src/thorin/analyses/schedule.cpp	/^    Scheduler(const Scope& scope, Schedule& schedule)$/;"	f	class:thorin::Scheduler
Scheduler	src/thorin/analyses/schedule.cpp	/^class Scheduler {$/;"	c	namespace:thorin	file:
Scope	src/thorin/analyses/scope.cpp	/^Scope::Scope(Continuation* entry)$/;"	f	class:thorin::Scope
Scope	src/thorin/analyses/scope.h	/^    Scope& operator=(Scope) = delete;$/;"	m	class:thorin::Scope
Scope	src/thorin/analyses/scope.h	/^class Scope : public Streamable {$/;"	c	namespace:thorin
Select	src/thorin/primop.h	/^    Select(const Def* cond, const Def* tval, const Def* fval, Debug dbg)$/;"	f	class:thorin::Select
Select	src/thorin/primop.h	/^class Select : public PrimOp {$/;"	c	namespace:thorin
Shared	src/thorin/type.h	/^    Shared   = 3,$/;"	m	class:thorin::AddrSpace
SizeOf	src/thorin/primop.cpp	/^SizeOf::SizeOf(const Def* def, Debug dbg)$/;"	f	class:thorin::SizeOf
SizeOf	src/thorin/primop.h	/^class SizeOf : public PrimOp {$/;"	c	namespace:thorin
Slot	src/thorin/primop.cpp	/^Slot::Slot(const Type* type, const Def* frame, Debug dbg)$/;"	f	class:thorin::Slot
Slot	src/thorin/primop.h	/^class Slot : public PrimOp {$/;"	c	namespace:thorin
Smart	src/thorin/analyses/schedule.h	/^    enum Tag { Early, Late, Smart };$/;"	e	enum:thorin::Schedule::Tag
Space	src/thorin/be/llvm/runtime.h	/^        Space,$/;"	e	enum:thorin::LaunchArgs::__anon6
Spawn	src/thorin/continuation.h	/^    Spawn,                      \/\/\/< Internal Parallel-CPU-Backend.$/;"	m	class:thorin::Intrinsic
Store	src/thorin/primop.h	/^    Store(const Def* mem, const Def* ptr, const Def* value, Debug dbg)$/;"	f	class:thorin::Store
Store	src/thorin/primop.h	/^class Store : public Access {$/;"	c	namespace:thorin
StrHash	src/thorin/util/hash.h	/^struct StrHash {$/;"	s	namespace:thorin
StreamList	src/thorin/util/stream.h	/^    StreamList(const List& list, Emit emit, const char* sep)$/;"	f	class:thorin::StreamList
StreamList	src/thorin/util/stream.h	/^class StreamList {$/;"	c	namespace:thorin
Streamable	src/thorin/util/stream.h	/^class Streamable {$/;"	c	namespace:thorin
StructAgg	src/thorin/primop.h	/^    StructAgg(const StructType* struct_type, Defs args, Debug dbg)$/;"	f	class:thorin::StructAgg
StructAgg	src/thorin/primop.h	/^class StructAgg : public Aggregate {$/;"	c	namespace:thorin
StructType	src/thorin/type.h	/^    StructType(TypeTable& table, Symbol name, size_t size)$/;"	f	class:thorin::StructType
StructType	src/thorin/type.h	/^class StructType : public Type {$/;"	c	namespace:thorin
Super	src/thorin/analyses/looptree.h	/^        typedef Node Super;$/;"	t	class:thorin::LoopTree::Head
Super	src/thorin/analyses/looptree.h	/^        typedef Node Super;$/;"	t	class:thorin::LoopTree::Leaf
Super	src/thorin/util/hash.h	/^    typedef detail::HashTable<Key, T, H> Super;$/;"	t	class:thorin::HashMap
Super	src/thorin/util/hash.h	/^    typedef detail::HashTable<Key, void, H> Super;$/;"	t	class:thorin::HashSet
Symbol	src/thorin/util/symbol.h	/^    Symbol() { insert(""); }$/;"	f	class:thorin::Symbol
Symbol	src/thorin/util/symbol.h	/^    Symbol(const char* str) { insert(str); }$/;"	f	class:thorin::Symbol
Symbol	src/thorin/util/symbol.h	/^    Symbol(const std::string& str) { insert(str.c_str()); }$/;"	f	class:thorin::Symbol
Symbol	src/thorin/util/symbol.h	/^    Symbol(int \/* just a dummy *\/)$/;"	f	class:thorin::Symbol
Symbol	src/thorin/util/symbol.h	/^class Symbol {$/;"	c	namespace:thorin
Sync	src/thorin/continuation.h	/^    Sync,                       \/\/\/< Internal Parallel-CPU-Backend.$/;"	m	class:thorin::Intrinsic
T	src/thorin/util/utility.h	/^    typedef typename Set::value_type T;$/;"	t	class:thorin::unique_queue
T	src/thorin/util/utility.h	/^    typedef typename Set::value_type T;$/;"	t	class:thorin::unique_stack
THORIN_ALL_TYPE	src/thorin/enums.h	49;"	d
THORIN_ALL_TYPE	src/thorin/enums.h	90;"	d
THORIN_ALL_TYPE	src/thorin/enums.h	94;"	d
THORIN_ALL_TYPE	src/thorin/primop.cpp	283;"	d	file:
THORIN_ALL_TYPE	src/thorin/primop.cpp	359;"	d	file:
THORIN_ALL_TYPE	src/thorin/primop.h	104;"	d
THORIN_ALL_TYPE	src/thorin/tables/primtypetable.h	100;"	d
THORIN_ALL_TYPE	src/thorin/type.cpp	173;"	d	file:
THORIN_ALL_TYPE	src/thorin/type.cpp	191;"	d	file:
THORIN_ALL_TYPE	src/thorin/type.h	377;"	d
THORIN_ALL_TYPE	src/thorin/type.h	404;"	d
THORIN_ALL_TYPE	src/thorin/type.h	425;"	d
THORIN_ALL_TYPE	src/thorin/util/types.h	236;"	d
THORIN_ALL_TYPE	src/thorin/util/types.h	248;"	d
THORIN_ALL_TYPE	src/thorin/util/types.h	270;"	d
THORIN_ALL_TYPE	src/thorin/world.cpp	118;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	124;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	130;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	136;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	142;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	438;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	444;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	450;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	456;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	529;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	536;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	543;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	550;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	557;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	564;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	571;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	578;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	585;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	592;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	599;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.cpp	606;"	d	file:
THORIN_ALL_TYPE	src/thorin/world.h	61;"	d
THORIN_ANALYSES_CFG_H	src/thorin/analyses/cfg.h	2;"	d
THORIN_ANALYSES_DOMFRONTIER_H	src/thorin/analyses/domfrontier.h	2;"	d
THORIN_ANALYSES_DOMTREE_H	src/thorin/analyses/domtree.h	2;"	d
THORIN_ANALYSES_FREE_DEFS_H	src/thorin/analyses/free_defs.h	2;"	d
THORIN_ANALYSES_LOOPTREE_H	src/thorin/analyses/looptree.h	2;"	d
THORIN_ANALYSES_SCHEDULE_H	src/thorin/analyses/schedule.h	2;"	d
THORIN_ANALYSES_SCOPE_H	src/thorin/analyses/scope.h	2;"	d
THORIN_ANALYSES_VERIFY_H	src/thorin/analyses/verify.h	2;"	d
THORIN_ARITHOP	src/thorin/enums.cpp	17;"	d	file:
THORIN_ARITHOP	src/thorin/enums.cpp	8;"	d	file:
THORIN_ARITHOP	src/thorin/enums.h	15;"	d
THORIN_ARITHOP	src/thorin/enums.h	27;"	d
THORIN_ARITHOP	src/thorin/enums.h	54;"	d
THORIN_ARITHOP	src/thorin/primop.cpp	239;"	d	file:
THORIN_ARITHOP	src/thorin/tables/allnodes.h	51;"	d
THORIN_ARITHOP	src/thorin/tables/arithoptable.h	17;"	d
THORIN_ARITHOP	src/thorin/world.h	84;"	d
THORIN_BE_C_H	src/thorin/be/c.h	2;"	d
THORIN_BE_GRAPHS_H	src/thorin/util/ycomp.h	2;"	d
THORIN_BE_KERNEL_CONFIG_H	src/thorin/be/kernel_config.h	2;"	d
THORIN_BE_LLVM_AMDGPU_H	src/thorin/be/llvm/amdgpu.h	2;"	d
THORIN_BE_LLVM_CPU_H	src/thorin/be/llvm/cpu.h	2;"	d
THORIN_BE_LLVM_CUDA_H	src/thorin/be/llvm/cuda.h	2;"	d
THORIN_BE_LLVM_HLS_H	src/thorin/be/llvm/hls.h	2;"	d
THORIN_BE_LLVM_LLVM_H	src/thorin/be/llvm/llvm.h	2;"	d
THORIN_BE_LLVM_NVVM_H	src/thorin/be/llvm/nvvm.h	2;"	d
THORIN_BE_LLVM_OPENCL_H	src/thorin/be/llvm/opencl.h	2;"	d
THORIN_BE_LLVM_RUNTIME_H	src/thorin/be/llvm/runtime.h	2;"	d
THORIN_BOOL_TYPE	src/thorin/tables/allnodes.h	23;"	d
THORIN_BOOL_TYPE	src/thorin/tables/primtypetable.h	32;"	d
THORIN_BOOL_TYPE	src/thorin/tables/primtypetable.h	4;"	d
THORIN_BOOL_TYPE	src/thorin/tables/primtypetable.h	95;"	d
THORIN_BOOL_TYPE	src/thorin/world.cpp	149;"	d	file:
THORIN_BOOL_TYPE	src/thorin/world.cpp	156;"	d	file:
THORIN_BOOL_TYPE	src/thorin/world.cpp	163;"	d	file:
THORIN_BOOL_TYPE	src/thorin/world.cpp	73;"	d	file:
THORIN_BREAK	src/thorin/world.cpp	26;"	d	file:
THORIN_BREAK	src/thorin/world.cpp	28;"	d	file:
THORIN_CALL_ONCE	src/thorin/util/utility.h	21;"	d
THORIN_CALL_ONCE	src/thorin/util/utility.h	24;"	d
THORIN_CHECK_BREAK	src/thorin/world.cpp	32;"	d	file:
THORIN_CHECK_BREAK	src/thorin/world.cpp	35;"	d	file:
THORIN_CLEANUP_WORLD_H	src/thorin/transform/cleanup_world.h	2;"	d
THORIN_CMP	src/thorin/enums.cpp	18;"	d	file:
THORIN_CMP	src/thorin/enums.cpp	9;"	d	file:
THORIN_CMP	src/thorin/enums.h	16;"	d
THORIN_CMP	src/thorin/enums.h	28;"	d
THORIN_CMP	src/thorin/enums.h	59;"	d
THORIN_CMP	src/thorin/primop.cpp	247;"	d	file:
THORIN_CMP	src/thorin/tables/allnodes.h	52;"	d
THORIN_CMP	src/thorin/tables/cmptable.h	12;"	d
THORIN_CMP	src/thorin/world.h	93;"	d
THORIN_CONFIG_H	build/include/thorin/config.h	2;"	d
THORIN_CONTINUATION_H	src/thorin/continuation.h	2;"	d
THORIN_DEF_H	src/thorin/def.h	2;"	d
THORIN_ENABLE_CHECKS	build/include/thorin/config.h	4;"	d
THORIN_ENABLE_PROFILING	build/include/thorin/config.h	5;"	d
THORIN_ENABLE_RV	build/include/thorin/config.h	6;"	d
THORIN_ENUMS_H	src/thorin/enums.h	2;"	d
THORIN_F_TYPE	src/thorin/def.cpp	125;"	d	file:
THORIN_F_TYPE	src/thorin/tables/primtypetable.h	99;"	d
THORIN_F_TYPE	src/thorin/world.cpp	389;"	d	file:
THORIN_GLUE	src/thorin/enums.cpp	14;"	d	file:
THORIN_GLUE	src/thorin/enums.cpp	5;"	d	file:
THORIN_GLUE	src/thorin/enums.h	12;"	d
THORIN_GLUE	src/thorin/enums.h	21;"	d
THORIN_GLUE	src/thorin/tables/allnodes.h	48;"	d
THORIN_IMPLIES	src/thorin/util/utility.h	28;"	d
THORIN_I_TYPE	src/thorin/def.cpp	103;"	d	file:
THORIN_I_TYPE	src/thorin/def.cpp	124;"	d	file:
THORIN_I_TYPE	src/thorin/primop.h	127;"	d
THORIN_I_TYPE	src/thorin/tables/primtypetable.h	98;"	d
THORIN_I_TYPE	src/thorin/world.cpp	148;"	d	file:
THORIN_I_TYPE	src/thorin/world.cpp	155;"	d	file:
THORIN_I_TYPE	src/thorin/world.cpp	162;"	d	file:
THORIN_I_TYPE	src/thorin/world.cpp	169;"	d	file:
THORIN_I_TYPE	src/thorin/world.cpp	175;"	d	file:
THORIN_I_TYPE	src/thorin/world.cpp	71;"	d	file:
THORIN_LNAME	src/thorin/util/utility.h	123;"	d
THORIN_LNAME_	src/thorin/util/utility.h	122;"	d
THORIN_LNAME__	src/thorin/util/utility.h	121;"	d
THORIN_NODE	src/thorin/enums.cpp	16;"	d	file:
THORIN_NODE	src/thorin/enums.cpp	6;"	d	file:
THORIN_NODE	src/thorin/enums.h	13;"	d
THORIN_NODE	src/thorin/enums.h	25;"	d
THORIN_NODE	src/thorin/primop.cpp	231;"	d	file:
THORIN_NODE	src/thorin/tables/allnodes.h	49;"	d
THORIN_NODE	src/thorin/tables/nodetable.h	61;"	d
THORIN_PASTER	src/thorin/util/utility.h	31;"	d
THORIN_PF_TYPE	src/thorin/tables/allnodes.h	38;"	d
THORIN_PF_TYPE	src/thorin/tables/primtypetable.h	10;"	d
THORIN_PF_TYPE	src/thorin/tables/primtypetable.h	27;"	d
THORIN_PF_TYPE	src/thorin/tables/primtypetable.h	74;"	d
THORIN_PF_TYPE	src/thorin/tables/primtypetable.h	93;"	d
THORIN_PRIMOP_H	src/thorin/primop.h	2;"	d
THORIN_PRIMTYPE	src/thorin/enums.cpp	15;"	d	file:
THORIN_PRIMTYPE	src/thorin/enums.cpp	7;"	d	file:
THORIN_PRIMTYPE	src/thorin/enums.h	14;"	d
THORIN_PRIMTYPE	src/thorin/enums.h	26;"	d
THORIN_PRIMTYPE	src/thorin/tables/allnodes.h	50;"	d
THORIN_PS_TYPE	src/thorin/tables/allnodes.h	26;"	d
THORIN_PS_TYPE	src/thorin/tables/primtypetable.h	20;"	d
THORIN_PS_TYPE	src/thorin/tables/primtypetable.h	38;"	d
THORIN_PS_TYPE	src/thorin/tables/primtypetable.h	89;"	d
THORIN_PS_TYPE	src/thorin/tables/primtypetable.h	8;"	d
THORIN_PUSH	src/thorin/util/utility.h	125;"	d
THORIN_PU_TYPE	src/thorin/tables/allnodes.h	29;"	d
THORIN_PU_TYPE	src/thorin/tables/primtypetable.h	21;"	d
THORIN_PU_TYPE	src/thorin/tables/primtypetable.h	47;"	d
THORIN_PU_TYPE	src/thorin/tables/primtypetable.h	90;"	d
THORIN_PU_TYPE	src/thorin/tables/primtypetable.h	9;"	d
THORIN_P_TYPE	src/thorin/tables/primtypetable.h	2;"	d
THORIN_P_TYPE	src/thorin/tables/primtypetable.h	96;"	d
THORIN_QF_TYPE	src/thorin/tables/allnodes.h	41;"	d
THORIN_QF_TYPE	src/thorin/tables/primtypetable.h	16;"	d
THORIN_QF_TYPE	src/thorin/tables/primtypetable.h	28;"	d
THORIN_QF_TYPE	src/thorin/tables/primtypetable.h	82;"	d
THORIN_QF_TYPE	src/thorin/tables/primtypetable.h	94;"	d
THORIN_QS_TYPE	src/thorin/tables/allnodes.h	32;"	d
THORIN_QS_TYPE	src/thorin/tables/primtypetable.h	14;"	d
THORIN_QS_TYPE	src/thorin/tables/primtypetable.h	22;"	d
THORIN_QS_TYPE	src/thorin/tables/primtypetable.h	56;"	d
THORIN_QS_TYPE	src/thorin/tables/primtypetable.h	91;"	d
THORIN_QU_TYPE	src/thorin/tables/allnodes.h	35;"	d
THORIN_QU_TYPE	src/thorin/tables/primtypetable.h	15;"	d
THORIN_QU_TYPE	src/thorin/tables/primtypetable.h	23;"	d
THORIN_QU_TYPE	src/thorin/tables/primtypetable.h	65;"	d
THORIN_QU_TYPE	src/thorin/tables/primtypetable.h	92;"	d
THORIN_Q_TYPE	src/thorin/tables/primtypetable.h	3;"	d
THORIN_Q_TYPE	src/thorin/tables/primtypetable.h	97;"	d
THORIN_REWRITE_FLOW_GRAPHS_H	src/thorin/transform/rewrite_flow_graphs.h	2;"	d
THORIN_TRANSFORM_CLONE_BODIES_H	src/thorin/transform/clone_bodies.h	2;"	d
THORIN_TRANSFORM_CODEGEN_PREPARE_H	src/thorin/transform/codegen_prepare.h	2;"	d
THORIN_TRANSFORM_DEAD_LOAD_OPT_H	src/thorin/transform/dead_load_opt.h	2;"	d
THORIN_TRANSFORM_HOIST_ENTERS_H	src/thorin/transform/hoist_enters.h	2;"	d
THORIN_TRANSFORM_IMPORT_H	src/thorin/transform/importer.h	2;"	d
THORIN_TRANSFORM_INLINER_H	src/thorin/transform/inliner.h	2;"	d
THORIN_TRANSFORM_LIFT_BUILTINS_H	src/thorin/transform/lift_builtins.h	2;"	d
THORIN_TRANSFORM_MANGLE_H	src/thorin/transform/mangle.h	2;"	d
THORIN_TRANSFORM_PARTIAL_EVALUATION_H	src/thorin/transform/partial_evaluation.h	2;"	d
THORIN_TRANSFORM_RESOLVE_LOADS_H	src/thorin/transform/resolve_loads.h	2;"	d
THORIN_TRANSFORM_SPLIT_SLOTS_H	src/thorin/transform/split_slots.h	2;"	d
THORIN_TYPE_H	src/thorin/type.h	2;"	d
THORIN_UNREACHABLE	src/thorin/util/utility.h	14;"	d
THORIN_UNREACHABLE	src/thorin/util/utility.h	17;"	d
THORIN_UTILITY_H	src/thorin/util/utility.h	2;"	d
THORIN_UTILS_H	src/thorin/util/args.h	2;"	d
THORIN_UTIL_ARRAY_H	src/thorin/util/array.h	2;"	d
THORIN_UTIL_CAST_H	src/thorin/util/cast.h	2;"	d
THORIN_UTIL_HASH_H	src/thorin/util/hash.h	2;"	d
THORIN_UTIL_INDEXMAP_H	src/thorin/util/indexmap.h	2;"	d
THORIN_UTIL_INDEXSET_H	src/thorin/util/indexset.h	2;"	d
THORIN_UTIL_ITERATOR_H	src/thorin/util/iterator.h	2;"	d
THORIN_UTIL_LOCATION_H	src/thorin/util/location.h	2;"	d
THORIN_UTIL_LOG_H	src/thorin/util/log.h	2;"	d
THORIN_UTIL_STREAM_H	src/thorin/util/stream.h	2;"	d
THORIN_UTIL_SYMBOL_H	src/thorin/util/symbol.h	2;"	d
THORIN_UTIL_TYPES_H	src/thorin/util/types.h	2;"	d
THORIN_UTIL_TYPE_TABLE_H	src/thorin/util/type_table.h	2;"	d
THORIN_WORLD_H	src/thorin/world.h	2;"	d
Table	src/thorin/util/symbol.h	/^    struct Table {$/;"	s	class:thorin::Symbol
Tag	src/thorin/analyses/schedule.h	/^    enum Tag { Early, Late, Smart };$/;"	g	class:thorin::Schedule
TaggedPtr	src/thorin/util/utility.h	/^    TaggedPtr() {}$/;"	f	class:thorin::TaggedPtr
TaggedPtr	src/thorin/util/utility.h	/^    TaggedPtr(T* ptr, I index)$/;"	f	class:thorin::TaggedPtr
TaggedPtr	src/thorin/util/utility.h	/^class TaggedPtr {$/;"	c	namespace:thorin
Texture	src/thorin/type.h	/^    Texture  = 2,$/;"	m	class:thorin::AddrSpace
Top	src/thorin/primop.h	/^    Top(const Type* type, Debug dbg)$/;"	f	class:thorin::Top
Top	src/thorin/primop.h	/^class Top : public Literal {$/;"	c	namespace:thorin
TopToBottom	src/thorin/util/ycomp.h	/^    TopToBottom,$/;"	e	enum:thorin::YCompOrientation
Tracker	src/thorin/def.h	/^    Tracker()$/;"	f	class:thorin::Tracker
Tracker	src/thorin/def.h	/^    Tracker(const Def* def)$/;"	f	class:thorin::Tracker
Tracker	src/thorin/def.h	/^class Tracker {$/;"	c	namespace:thorin
Tuple	src/thorin/primop.cpp	/^Tuple::Tuple(World& world, Defs args, Debug dbg)$/;"	f	class:thorin::Tuple
Tuple	src/thorin/primop.h	/^class Tuple : public Aggregate {$/;"	c	namespace:thorin
TupleType	src/thorin/type.h	/^    TupleType(TypeTable& table, Types ops)$/;"	f	class:thorin::TupleType
TupleType	src/thorin/type.h	/^class TupleType : public Type {$/;"	c	namespace:thorin
TypeBase	src/thorin/util/type_table.h	/^TypeBase<TypeTable>::TypeBase(TypeTable& table, int tag, Types ops)$/;"	f	class:thorin::TypeBase
TypeBase	src/thorin/util/type_table.h	/^class TypeBase : public RuntimeCast<TypeBase<TypeTable>>, public Streamable {$/;"	c	namespace:thorin
TypeHash	src/thorin/util/type_table.h	/^    struct TypeHash {$/;"	s	class:thorin::TypeTableBase
TypeSet	src/thorin/util/type_table.h	/^    typedef thorin::HashSet<const Type*, TypeHash> TypeSet;$/;"	t	class:thorin::TypeTableBase
TypeTable	src/thorin/type.cpp	/^TypeTable::TypeTable()$/;"	f	class:thorin::TypeTable
TypeTable	src/thorin/type.h	/^class TypeTable : public TypeTableBase<Type> {$/;"	c	namespace:thorin
TypeTableBase	src/thorin/util/type_table.h	/^    TypeTableBase() {}$/;"	f	class:thorin::TypeTableBase
TypeTableBase	src/thorin/util/type_table.h	/^class TypeTableBase {$/;"	c	namespace:thorin
UInt	src/thorin/util/types.h	/^    UInt(UT data)$/;"	f	class:thorin::UInt
UInt	src/thorin/util/types.h	/^class UInt {$/;"	c	namespace:thorin
UT	src/thorin/util/types.h	/^    typedef typename std::make_unsigned<ST>::type UT;$/;"	t	class:thorin::SInt
Undef	src/thorin/continuation.h	/^    Undef,                      \/\/\/< Intrinsic undef function$/;"	m	class:thorin::Intrinsic
Use	src/thorin/def.h	/^    Use() {}$/;"	f	class:thorin::Use
Use	src/thorin/def.h	/^    Use(size_t index, const Def* def)$/;"	f	class:thorin::Use
Use	src/thorin/def.h	/^class Use {$/;"	c	namespace:thorin
UseHash	src/thorin/def.h	/^struct UseHash {$/;"	s	namespace:thorin
Uses	src/thorin/def.h	/^typedef HashSet<Use, UseHash> Uses;$/;"	t	namespace:thorin
VLOG	src/thorin/util/log.h	70;"	d
Var	src/thorin/type.h	/^    Var(TypeTable& table, int depth)$/;"	f	class:thorin::Var
Var	src/thorin/type.h	/^class Var : public Type {$/;"	c	namespace:thorin
Variant	src/thorin/primop.h	/^    Variant(const VariantType* variant_type, const Def* value, Debug dbg)$/;"	f	class:thorin::Variant
Variant	src/thorin/primop.h	/^class Variant : public PrimOp {$/;"	c	namespace:thorin
VariantType	src/thorin/type.h	/^    VariantType(TypeTable& table, Types ops)$/;"	f	class:thorin::VariantType
VariantType	src/thorin/type.h	/^class VariantType : public Type {$/;"	c	namespace:thorin
Vector	src/thorin/primop.cpp	/^Vector::Vector(World& world, Defs args, Debug dbg)$/;"	f	class:thorin::Vector
Vector	src/thorin/primop.h	/^class Vector : public Aggregate {$/;"	c	namespace:thorin
VectorType	src/thorin/type.h	/^    VectorType(TypeTable& table, int tag, Types ops, size_t length)$/;"	f	class:thorin::VectorType
VectorType	src/thorin/type.h	/^class VectorType : public Type {$/;"	c	namespace:thorin
Vectorize	src/thorin/continuation.h	/^    Vectorize,                  \/\/\/< External vectorizer.$/;"	m	class:thorin::Intrinsic
VectorizeArgs	src/thorin/be/llvm/vectorize.cpp	/^struct VectorizeArgs {$/;"	s	namespace:thorin	file:
Verbose	src/thorin/util/log.h	/^        Debug, Verbose, Info, Warn, Error,$/;"	e	enum:thorin::Log::Level
WDEF	src/thorin/util/log.h	64;"	d
WLOG	src/thorin/util/log.h	68;"	d
Warn	src/thorin/util/log.h	/^        Debug, Verbose, Info, Warn, Error,$/;"	e	enum:thorin::Log::Level
World	src/thorin/world.cpp	/^World::World(std::string name)$/;"	f	class:thorin::World
World	src/thorin/world.h	/^class World : public TypeTable, public Streamable {$/;"	c	namespace:thorin
YComp	src/thorin/util/ycomp.h	/^    YComp(const Scope& scope, const char* name)$/;"	f	class:thorin::YComp
YComp	src/thorin/util/ycomp.h	/^class YComp {$/;"	c	namespace:thorin
YCompCommandLine	src/thorin/util/ycomp.h	/^    YCompCommandLine() {}$/;"	f	class:thorin::YCompCommandLine
YCompCommandLine	src/thorin/util/ycomp.h	/^class YCompCommandLine {$/;"	c	namespace:thorin
YCompOrientation	src/thorin/util/ycomp.h	/^enum YCompOrientation {$/;"	g	namespace:thorin
YCompOrientation_Names	src/thorin/util/ycomp.h	/^static const char* YCompOrientation_Names[] = { "left_to_right", "right_to_left", "bottom_to_top", "top_to_bottom" };$/;"	m	namespace:thorin
YCompScope	src/thorin/util/ycomp.h	/^    YCompScope(std::ostream& ostream, YCompOrientation orientation)$/;"	f	class:thorin::YCompScope
YCompScope	src/thorin/util/ycomp.h	/^    YCompScope(std::ostream& ostream, const Scope& scope, Range<I> range,$/;"	f	class:thorin::YCompScope
YCompScope	src/thorin/util/ycomp.h	/^class YCompScope {$/;"	c	namespace:thorin
_Accelerator_Begin	src/thorin/continuation.h	/^    _Accelerator_Begin,$/;"	m	class:thorin::Intrinsic
_Accelerator_End	src/thorin/continuation.h	/^    _Accelerator_End,$/;"	m	class:thorin::Intrinsic
_s	src/thorin/util/utility.h	/^constexpr size_t operator""_s(unsigned long long int i) { return size_t(i); }$/;"	f	namespace:thorin
_u32	src/thorin/util/utility.h	/^constexpr uint32_t operator""_u32(unsigned long long int i) { return uint32_t(i); }$/;"	f	namespace:thorin
_u64	src/thorin/util/utility.h	/^constexpr uint64_t operator""_u64(unsigned long long int i) { return uint64_t(i); }$/;"	f	namespace:thorin
abs	src/thorin/util/types.h	/^    SInt abs() const { return is_neg() ? minus() : *this; }$/;"	f	class:thorin::SInt
abs	src/thorin/util/types.h	/^    UInt abs() const { return is_neg() ? minus() : *this; }$/;"	f	class:thorin::UInt
add	src/thorin/util/ycomp.cpp	/^void YCompCommandLine::add(std::string graph, bool temp, std::string file) {$/;"	f	class:thorin::YCompCommandLine
addScope	src/thorin/util/ycomp.h	/^    void addScope(const Scope& scope, Range<I> range, SuccFct succs) {$/;"	f	class:thorin::YCompScope
add_external	src/thorin/world.h	/^    void add_external(Continuation* continuation) { externals_.insert(continuation); }$/;"	f	class:thorin::World
add_option	src/thorin/util/args.h	/^    Option<NData, Class> add_option(std::string param, std::string domain, std::string help, NData& target, const NData& init = {}) const {$/;"	f	class:thorin::OptionBase
add_option	src/thorin/util/args.h	/^    Option<NData, ImplicitOption> add_option(std::string param, std::string domain, std::string help, NData& target, const NData& init = {}) const {$/;"	f	struct:thorin::ImplicitOption
add_option	src/thorin/util/args.h	/^    Option<NData, Option<void, void>> add_option(std::string param, std::string domain, std::string help, NData& target, const NData& init = {}) const {$/;"	f	struct:thorin::Option
addr_space	src/thorin/type.h	/^    AddrSpace addr_space() const { return addr_space_; }$/;"	f	class:thorin::PtrType
addr_space_	src/thorin/type.h	/^    AddrSpace addr_space_;$/;"	m	class:thorin::PtrType
agg	src/thorin/primop.h	/^    const Def* agg() const { return op(0); }$/;"	f	class:thorin::AggOp
alloc	src/thorin/util/hash.h	/^    value_type* alloc() {$/;"	f	class:thorin::detail::HashTable
alloc	src/thorin/world.cpp	/^const Def* World::alloc(const Type* type, const Def* mem, const Def* extra, Debug dbg) {$/;"	f	class:thorin::World
alloc	src/thorin/world.h	/^    const Def* alloc(const Type* type, const Def* mem, Debug dbg = {}) { return alloc(type, mem, literal_qu64(0, dbg), dbg); }$/;"	f	class:thorin::World
alloced_type	src/thorin/primop.h	/^    const Type* alloced_type() const { return out_ptr_type()->pointee(); }$/;"	f	class:thorin::Alloc
alloced_type	src/thorin/primop.h	/^    const Type* alloced_type() const { return type()->pointee(); }$/;"	f	class:thorin::Global
alloced_type	src/thorin/primop.h	/^    const Type* alloced_type() const { return type()->pointee(); }$/;"	f	class:thorin::Slot
allset	src/thorin/world.cpp	/^const Def* World::allset(PrimTypeTag tag, Debug dbg, size_t length) {$/;"	f	class:thorin::World
allset	src/thorin/world.h	/^    const Def* allset(const Type* type, Debug dbg = {}, size_t length = 1) { return allset(type->as<PrimType>()->primtype_tag(), dbg, length); }$/;"	f	class:thorin::World
amdgpu	src/thorin/be/llvm/llvm.h	/^    Importer amdgpu;$/;"	m	struct:thorin::Backends
amdgpu_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> amdgpu_cg;$/;"	m	struct:thorin::Backends
analyze	src/thorin/analyses/verify.cpp	/^void Cycles::analyze(ParamSet& params, const Continuation* continuation, const Def* def) {$/;"	f	class:thorin::Cycles
analyze_call	src/thorin/analyses/verify.cpp	/^void Cycles::analyze_call(const Continuation* continuation) {$/;"	f	class:thorin::Cycles
app	src/thorin/type.cpp	/^const Type* TypeTable::app(const Type* callee, const Type* op) {$/;"	f	class:thorin::TypeTable
append_param	src/thorin/continuation.cpp	/^const Param* Continuation::append_param(const Type* param_type, Debug dbg) {$/;"	f	class:thorin::Continuation
arg	src/thorin/continuation.h	/^    const Def* arg(size_t i) const { return args()[i]; }$/;"	f	class:thorin::Continuation
arg	src/thorin/continuation.h	/^    const Def* arg(size_t i) const { return args()[i]; }$/;"	f	struct:thorin::Call
arg	src/thorin/continuation.h	/^    const Def*& arg(size_t i) { return ops_[i+1]; }$/;"	f	struct:thorin::Call
arg	src/thorin/type.h	/^    const Type* arg() const { return Type::op(1); }$/;"	f	class:thorin::App
arg_fn_type	src/thorin/continuation.cpp	/^const FnType* Continuation::arg_fn_type() const {$/;"	f	class:thorin::Continuation
args	src/thorin/continuation.h	/^    Defs args() const { return num_ops() == 0 ? Defs(0, 0) : ops().skip_front(); }$/;"	f	class:thorin::Continuation
args	src/thorin/continuation.h	/^    Defs args() const { return ops_.skip_front(); }$/;"	f	struct:thorin::Call
args_	src/thorin/transform/mangle.h	/^    Defs args_;$/;"	m	class:thorin::Mangler
args_	src/thorin/transform/partial_evaluation.cpp	/^    Defs args_;$/;"	m	class:thorin::CondEval	file:
argv_	src/thorin/util/args.h	/^    char** argv_;$/;"	m	class:thorin::ArgsIterator
arithop	src/thorin/world.cpp	/^const Def* World::arithop(ArithOpTag tag, const Def* a, const Def* b, Debug dbg) {$/;"	f	class:thorin::World
arithop_minus	src/thorin/world.cpp	/^const Def* World::arithop_minus(const Def* def, Debug dbg) {$/;"	f	class:thorin::World
arithop_not	src/thorin/world.cpp	/^const Def* World::arithop_not(const Def* def, Debug dbg) { return arithop_xor(allset(def->type(), dbg, vector_length(def)), def, dbg); }$/;"	f	class:thorin::World
arithop_tag	src/thorin/primop.h	/^    ArithOpTag arithop_tag() const { return (ArithOpTag) tag(); }$/;"	f	class:thorin::ArithOp
array	src/thorin/util/indexmap.h	/^    Array<Value>& array() { return array_; }$/;"	f	class:thorin::IndexMap
array	src/thorin/util/indexmap.h	/^    Value& array(size_t i) { return array_[i]; }$/;"	f	class:thorin::IndexMap
array	src/thorin/util/indexmap.h	/^    const Array<Value>& array() const { return array_; }$/;"	f	class:thorin::IndexMap
array	src/thorin/util/indexmap.h	/^    const Value& array(size_t i) const { return array_[i]; }$/;"	f	class:thorin::IndexMap
array_	src/thorin/util/hash.h	/^    std::array<value_type, StackCapacity> array_;$/;"	m	class:thorin::detail::HashTable
array_	src/thorin/util/indexmap.h	/^    Array<Value> array_;$/;"	m	class:thorin::IndexMap
array_emplace	src/thorin/util/hash.h	/^    std::pair<iterator,bool> array_emplace(Args&&... args) {$/;"	f	class:thorin::detail::HashTable
array_erase	src/thorin/util/hash.h	/^    void array_erase(const_iterator pos) {$/;"	f	class:thorin::detail::HashTable
array_find	src/thorin/util/hash.h	/^    iterator array_find(const key_type& k) {$/;"	f	class:thorin::detail::HashTable
as	src/thorin/util/cast.h	/^    const To* as()  const { return thorin::scast<To>(static_cast<const Base*>(this)); }$/;"	f	class:thorin::RuntimeCast
as	src/thorin/util/cast.h	/^    template<class To> To* as() { return thorin::scast<To>(static_cast<Base*>(this)); }$/;"	f	class:thorin::RuntimeCast
as_class	src/thorin/util/args.h	/^    const Class* as_class() const { return static_cast<const Class*>(this); }$/;"	f	class:thorin::OptionBase
as_continuation	src/thorin/def.cpp	/^Continuation* Def::as_continuation() const { return const_cast<Continuation*>(scast<Continuation>(this)); }$/;"	f	class:thorin::Def
as_string	src/thorin/primop.cpp	/^std::string DefiniteArray::as_string() const {$/;"	f	class:thorin::DefiniteArray
asm_template	src/thorin/primop.h	/^    const std::string& asm_template() const { return asm_template_; }$/;"	f	class:thorin::Assembly
asm_template_	src/thorin/primop.h	/^    std::string asm_template_;$/;"	m	class:thorin::Assembly
assembly	src/thorin/world.cpp	/^const Assembly* World::assembly(Types types, const Def* mem, Defs inputs, std::string asm_template, ArrayRef<std::string> output_constraints, ArrayRef<std::string> input_constraints, ArrayRef<std::string> clobbers, Assembly::Flags flags, Debug dbg) {$/;"	f	class:thorin::World
assembly	src/thorin/world.cpp	/^const Assembly* World::assembly(const Type* type, Defs inputs, std::string asm_template, ArrayRef<std::string> output_constraints, ArrayRef<std::string> input_constraints, ArrayRef<std::string> clobbers, Assembly::Flags flags, Debug dbg) {$/;"	f	class:thorin::World
assert_unused	src/thorin/util/utility.h	22;"	d
assert_unused	src/thorin/util/utility.h	25;"	d
assertf	src/thorin/util/stream.h	143;"	d
assertf	src/thorin/util/stream.h	145;"	d
b_cfg	src/thorin/analyses/cfg.cpp	/^const B_CFG& CFA::b_cfg() const { return lazy_init(this, b_cfg_); }$/;"	f	class:thorin::CFA
b_cfg	src/thorin/analyses/scope.cpp	/^const B_CFG& Scope::b_cfg() const { return cfa().b_cfg(); }$/;"	f	class:thorin::Scope
b_cfg_	src/thorin/analyses/cfg.h	/^    mutable std::unique_ptr<const B_CFG> b_cfg_;$/;"	m	class:thorin::CFA
b_index_	src/thorin/analyses/cfg.h	/^    mutable size_t b_index_ = -1; \/\/\/< RPO index in a backwards @p CFG.$/;"	m	class:thorin::CFNode
back	src/thorin/util/array.h	/^    T const& back()  const { assert(!empty()); return ptr_[size_ - 1]; }$/;"	f	class:thorin::ArrayRef
back	src/thorin/util/array.h	/^    T& back()  const { assert(!empty()); return ptr_[size_ - 1]; }$/;"	f	class:thorin::Array
back	src/thorin/util/location.h	/^    Location back() const { return {filename_, back_line(), back_col(), back_line(), back_col()}; }$/;"	f	class:thorin::Location
back_col	src/thorin/util/location.h	/^    uint32_t back_col() const { return back_col_; }$/;"	f	class:thorin::Location
back_col_	src/thorin/util/location.h	/^    uint16_t front_line_ = 1, front_col_ = 1, back_line_ = 1, back_col_ = 1;$/;"	m	class:thorin::Location
back_line	src/thorin/util/location.h	/^    uint32_t back_line() const { return back_line_; }$/;"	f	class:thorin::Location
back_line_	src/thorin/util/location.h	/^    uint16_t front_line_ = 1, front_col_ = 1, back_line_ = 1, back_col_ = 1;$/;"	m	class:thorin::Location
bcast	src/thorin/util/cast.h	/^inline L bcast(const R& from) {$/;"	f	namespace:thorin
begin	src/thorin/analyses/schedule.h	/^        const_iterator begin() const { return primops().begin(); }$/;"	f	class:thorin::Schedule::Block
begin	src/thorin/analyses/schedule.h	/^    const_iterator begin() const { return blocks().begin(); }$/;"	f	class:thorin::Schedule
begin	src/thorin/util/array.h	/^    const_iterator begin() const { return ptr_; }$/;"	f	class:thorin::Array
begin	src/thorin/util/array.h	/^    const_iterator begin() const { return ptr_; }$/;"	f	class:thorin::ArrayRef
begin	src/thorin/util/array.h	/^    iterator begin() { return ptr_; }$/;"	f	class:thorin::Array
begin	src/thorin/util/hash.h	/^    const_iterator begin() const { return const_iterator(const_cast<HashTable*>(this)->begin()); }$/;"	f	class:thorin::detail::HashTable
begin	src/thorin/util/hash.h	/^    iterator begin() { return iterator::skip(nodes_, this); }$/;"	f	class:thorin::detail::HashTable
begin	src/thorin/util/indexmap.h	/^    const_iterator begin() const { return make_filter(array_.begin(), array_.end(), IsValidPred<Value>::is_valid); }$/;"	f	class:thorin::IndexMap
begin	src/thorin/util/iterator.h	/^    I begin() const { return begin_; }$/;"	f	struct:thorin::Range
begin_	src/thorin/util/iterator.h	/^    I begin_;$/;"	m	struct:thorin::Range
binop	src/thorin/world.cpp	/^const Def* World::binop(int tag, const Def* lhs, const Def* rhs, Debug dbg) {$/;"	f	class:thorin::World
bitcast	src/thorin/world.cpp	/^const Def* World::bitcast(const Type* to, const Def* from, Debug dbg) {$/;"	f	class:thorin::World
bitcount	src/thorin/util/utility.h	/^inline size_t bitcount(uint64_t v) {$/;"	f	namespace:thorin
bits_	src/thorin/util/indexset.h	/^    Array<uint64_t> bits_;$/;"	m	class:thorin::IndexSet
block_	src/thorin/be/kernel_config.h	/^    std::tuple<int, int, int> block_;$/;"	m	class:thorin::GPUKernelConfig
block_schedule	src/thorin/analyses/schedule.cpp	/^void Schedule::block_schedule() {$/;"	f	class:thorin::Schedule
block_size	src/thorin/be/kernel_config.h	/^    std::tuple<int, int, int> block_size() const { return block_; }$/;"	f	class:thorin::GPUKernelConfig
blocks	src/thorin/analyses/schedule.h	/^    ArrayRef<Block> blocks() const { return blocks_; }$/;"	f	class:thorin::Schedule
blocks_	src/thorin/analyses/schedule.h	/^    Array<Block> blocks_;$/;"	m	class:thorin::Schedule
body	src/thorin/type.h	/^    const Type* body() const { return op(0); }$/;"	f	class:thorin::Lambda
bool_	src/thorin/util/types.h	/^    bool bool_;$/;"	m	union:thorin::Box
bottom	src/thorin/world.h	/^    const Def* bottom(PrimTypeTag tag, Debug dbg = {}, size_t length = 1) { return bottom(type(tag), dbg, length); }$/;"	f	class:thorin::World
bottom	src/thorin/world.h	/^    const Def* bottom(const Type* type, Debug dbg = {}, size_t length = 1) { return splat(cse(new Bottom(type, dbg)), length); }$/;"	f	class:thorin::World
boundary_	src/thorin/transform/partial_evaluation.cpp	/^    size_t boundary_;$/;"	m	class:thorin::PartialEvaluator	file:
box_	src/thorin/primop.h	/^    Box box_;$/;"	m	class:thorin::PrimLit
branch	src/thorin/continuation.cpp	/^void Continuation::branch(const Def* cond, const Def* t, const Def* f, Debug dbg) {$/;"	f	class:thorin::Continuation
branch	src/thorin/world.h	/^    Continuation* branch() const { return branch_; }$/;"	f	class:thorin::World
branch_	src/thorin/world.h	/^    Continuation* branch_;$/;"	m	class:thorin::World
breakpoint	src/thorin/world.h	/^    void breakpoint(size_t number) { breakpoints_.insert(number); }$/;"	f	class:thorin::World
breakpoints	src/thorin/world.h	/^    const Breakpoints& breakpoints() const { return breakpoints_; }$/;"	f	class:thorin::World
breakpoints_	src/thorin/world.h	/^    Breakpoints breakpoints_;$/;"	m	class:thorin::World
build	src/thorin/analyses/looptree.cpp	/^void LoopTreeBuilder<forward>::build() {$/;"	f	class:thorin::LoopTreeBuilder
builder_	src/thorin/be/llvm/runtime.h	/^    llvm::IRBuilder<>& builder_;$/;"	m	class:thorin::Runtime
c_str	src/thorin/util/symbol.h	/^    const char* c_str() const { return str_; }$/;"	f	class:thorin::Symbol
cache_	src/thorin/transform/partial_evaluation.cpp	/^    HashMap<Call, Continuation*> cache_;$/;"	m	class:thorin::PartialEvaluator	file:
cache_	src/thorin/type.h	/^    mutable const Type* cache_ = nullptr;$/;"	m	class:thorin::App
callee	src/thorin/continuation.cpp	/^const Def* Continuation::callee() const {$/;"	f	class:thorin::Continuation
callee	src/thorin/continuation.h	/^    const Def* callee() const { return ops_.front(); }$/;"	f	struct:thorin::Call
callee	src/thorin/continuation.h	/^    const Def*& callee() { return ops_.front(); }$/;"	f	struct:thorin::Call
callee	src/thorin/type.h	/^    const Type* callee() const { return Type::op(0); }$/;"	f	class:thorin::App
callee_	src/thorin/transform/partial_evaluation.cpp	/^    Continuation* callee_;$/;"	m	class:thorin::CondEval	file:
callee_fn_type	src/thorin/continuation.h	/^    const FnType* callee_fn_type() const { return callee()->type()->as<FnType>(); }$/;"	f	class:thorin::Continuation
can_split	src/thorin/transform/split_slots.cpp	/^static bool can_split(const Slot* slot) {$/;"	f	namespace:thorin
capacity	src/thorin/util/hash.h	/^    size_t capacity() const { return capacity_; }$/;"	f	class:thorin::detail::HashTable
capacity	src/thorin/util/indexmap.h	/^    size_t capacity() const { return array_.size(); }$/;"	f	class:thorin::IndexMap
capacity	src/thorin/util/indexset.h	/^    size_t capacity() const { return indexer().size(); }$/;"	f	class:thorin::IndexSet
capacity_	src/thorin/util/hash.h	/^    uint32_t capacity_;$/;"	m	class:thorin::detail::HashTable
cast	src/thorin/world.cpp	/^const Def* World::cast(const Type* to, const Def* from, Debug dbg) {$/;"	f	class:thorin::World
cbegin	src/thorin/util/hash.h	/^    const_iterator cbegin() const { return begin(); }$/;"	f	class:thorin::detail::HashTable
cc	src/thorin/continuation.h	/^    CC cc() const { return cc_; }$/;"	f	class:thorin::Continuation
cc	src/thorin/continuation.h	/^    CC& cc() { return cc_; }$/;"	f	class:thorin::Continuation
cc_	src/thorin/continuation.h	/^    CC cc_;$/;"	m	class:thorin::Continuation
cend	src/thorin/util/hash.h	/^    const_iterator cend() const { return end(); }$/;"	f	class:thorin::detail::HashTable
cf_node	src/thorin/analyses/looptree.h	/^        const CFNode* cf_node() const { return Super::cf_nodes().front(); }$/;"	f	class:thorin::LoopTree::Leaf
cf_nodes	src/thorin/analyses/looptree.h	/^        ArrayRef<const CFNode*> cf_nodes() const { return cf_nodes_; }$/;"	f	class:thorin::LoopTree::Node
cf_nodes_	src/thorin/analyses/looptree.h	/^        std::vector<const CFNode*> cf_nodes_;$/;"	m	class:thorin::LoopTree::Node
cfa	src/thorin/analyses/cfg.h	/^    const CFA& cfa() const { return cfa_; }$/;"	f	class:thorin::CFG
cfa	src/thorin/analyses/schedule.h	/^    const CFA& cfa() const { return scope().cfa(); }$/;"	f	class:thorin::Schedule
cfa	src/thorin/analyses/scope.cpp	/^const CFA& Scope::cfa() const { return lazy_init(this, cfa_); }$/;"	f	class:thorin::Scope
cfa_	src/thorin/analyses/cfg.h	/^    const CFA& cfa_;$/;"	m	class:thorin::CFG
cfa_	src/thorin/analyses/scope.h	/^    mutable std::unique_ptr<const CFA> cfa_;$/;"	m	class:thorin::Scope
cfg	src/thorin/analyses/domfrontier.h	/^    const CFG<forward>& cfg() const { return cfg_; }$/;"	f	class:thorin::DomFrontierBase
cfg	src/thorin/analyses/domtree.h	/^    const CFG<forward>& cfg() const { return cfg_; }$/;"	f	class:thorin::DomTreeBase
cfg	src/thorin/analyses/looptree.cpp	/^    const CFG<forward>& cfg() const { return looptree_.cfg(); }$/;"	f	class:thorin::LoopTreeBuilder	file:
cfg	src/thorin/analyses/looptree.h	/^    const CFG<forward>& cfg() const { return cfg_; }$/;"	f	class:thorin::LoopTree
cfg	src/thorin/analyses/schedule.h	/^    const F_CFG& cfg() const { return scope().f_cfg(); }$/;"	f	class:thorin::Schedule
cfg_	src/thorin/analyses/domfrontier.h	/^    const CFG<forward>& cfg_;$/;"	m	class:thorin::DomFrontierBase
cfg_	src/thorin/analyses/domtree.h	/^    const CFG<forward>& cfg_;$/;"	m	class:thorin::DomTreeBase
cfg_	src/thorin/analyses/looptree.h	/^    const CFG<forward>& cfg_;$/;"	m	class:thorin::LoopTree
cfg_	src/thorin/analyses/schedule.cpp	/^    const F_CFG& cfg_;$/;"	m	class:thorin::Scheduler	file:
child	src/thorin/analyses/looptree.h	/^        const Super* child(size_t i) const { return children_[i].get(); }$/;"	f	class:thorin::LoopTree::Head
children	src/thorin/analyses/domtree.h	/^    const std::vector<const CFNode*>& children(const CFNode* n) const { return children_[n]; }$/;"	f	class:thorin::DomTreeBase
children	src/thorin/analyses/looptree.h	/^        ArrayRef<std::unique_ptr<Super>> children() const { return children_; }$/;"	f	class:thorin::LoopTree::Head
children_	src/thorin/analyses/domtree.h	/^    typename CFG<forward>::template Map<std::vector<const CFNode*>> children_;$/;"	m	class:thorin::DomTreeBase
children_	src/thorin/analyses/looptree.h	/^        std::vector<std::unique_ptr<Super>> children_;$/;"	m	class:thorin::LoopTree::Head
clean_pe_info	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::clean_pe_info(std::queue<Continuation*> queue, Continuation* cur) {$/;"	f	class:thorin::Cleaner
clean_pe_infos	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::clean_pe_infos() {$/;"	f	class:thorin::Cleaner
cleanup	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::cleanup() {$/;"	f	class:thorin::Cleaner
cleanup	src/thorin/world.cpp	/^void World::cleanup() { cleanup_world(*this); }$/;"	f	class:thorin::World
cleanup_fix_point	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::cleanup_fix_point() {$/;"	f	class:thorin::Cleaner
cleanup_world	src/thorin/transform/cleanup_world.cpp	/^void cleanup_world(World& world) { Cleaner(world).cleanup(); }$/;"	f	namespace:thorin
clear	src/thorin/util/hash.h	/^    void clear() {$/;"	f	class:thorin::detail::HashTable
clear	src/thorin/util/indexset.h	/^    void clear() { std::fill(bits_.begin(), bits_.end(), 0u); }$/;"	f	class:thorin::IndexSet
clear_type	src/thorin/def.h	/^    void clear_type() { type_ = nullptr; }$/;"	f	class:thorin::Def
clobbers	src/thorin/primop.h	/^    const ArrayRef<std::string> clobbers() const { return clobbers_; }$/;"	f	class:thorin::Assembly
clobbers_	src/thorin/primop.h	/^    Array<std::string> output_constraints_, input_constraints_, clobbers_;$/;"	m	class:thorin::Assembly
clone	src/thorin/transform/mangle.h	/^inline Continuation* clone(const Scope& scope) {$/;"	f	namespace:thorin
clone_bodies	src/thorin/transform/clone_bodies.cpp	/^void clone_bodies(World& world) {$/;"	f	namespace:thorin
closure	src/thorin/world.h	/^    const Def* closure(const ClosureType* closure_type, const Def* fn, const Def* env, Debug dbg = {}) { return cse(new Closure(closure_type, fn, env, dbg)); }$/;"	f	class:thorin::World
closure_conversion	src/thorin/transform/closure_conversion.cpp	/^void closure_conversion(World& world) {$/;"	f	namespace:thorin
closure_type	src/thorin/type.h	/^    const ClosureType* closure_type(Types args) { return unify(new ClosureType(*this, args)); }$/;"	f	class:thorin::TypeTable
cmp	src/thorin/world.cpp	/^const Def* World::cmp(CmpTag tag, const Def* a, const Def* b, Debug dbg) {$/;"	f	class:thorin::World
cmp_tag	src/thorin/primop.h	/^    CmpTag cmp_tag() const { return (CmpTag) tag(); }$/;"	f	class:thorin::Cmp
codegen_prepare	src/thorin/transform/codegen_prepare.cpp	/^void codegen_prepare(World& world) {$/;"	f	namespace:thorin
colorize	src/thorin/util/log.cpp	/^std::string Log::colorize(const std::string& str, int color) {$/;"	f	class:thorin::Log
compute_def2uses	src/thorin/analyses/schedule.cpp	/^void Scheduler::compute_def2uses() {$/;"	f	class:thorin::Scheduler
compute_variant_bits	src/thorin/be/llvm/llvm.cpp	/^unsigned CodeGen::compute_variant_bits(const VariantType* variant) {$/;"	f	class:thorin::CodeGen
compute_variant_op_bits	src/thorin/be/llvm/llvm.cpp	/^unsigned CodeGen::compute_variant_op_bits(const Type* type) {$/;"	f	class:thorin::CodeGen
cond	src/thorin/primop.h	/^    const Def* cond() const { return op(0); }$/;"	f	class:thorin::Select
const_iterator	src/thorin/analyses/schedule.h	/^        typedef ArrayRef<const PrimOp*>::const_iterator const_iterator;$/;"	t	class:thorin::Schedule::Block
const_iterator	src/thorin/analyses/schedule.h	/^    typedef ArrayRef<const Block>::const_iterator const_iterator;$/;"	t	class:thorin::Schedule
const_iterator	src/thorin/util/array.h	/^    typedef const T* const_iterator;$/;"	t	class:thorin::Array
const_iterator	src/thorin/util/array.h	/^    typedef const T* const_iterator;$/;"	t	class:thorin::ArrayRef
const_iterator	src/thorin/util/hash.h	/^    typedef iterator_base<true> const_iterator;$/;"	t	class:thorin::detail::HashTable
const_iterator	src/thorin/util/hash.h	/^    typedef typename Super::const_iterator const_iterator;$/;"	t	class:thorin::HashMap
const_iterator	src/thorin/util/hash.h	/^    typedef typename Super::const_iterator const_iterator;$/;"	t	class:thorin::HashSet
const_iterator	src/thorin/util/indexmap.h	/^    typedef filter_iterator<typename Array<Value>::const_iterator, bool (*)(Value)> const_iterator;$/;"	t	class:thorin::IndexMap
const_reverse_iterator	src/thorin/util/array.h	/^    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:thorin::Array
const_reverse_iterator	src/thorin/util/array.h	/^    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:thorin::ArrayRef
contains	src/thorin/analyses/scope.h	/^    bool contains(const Def* def) const { return defs_.contains(def); }$/;"	f	class:thorin::Scope
contains	src/thorin/util/hash.h	/^    bool contains(const key_type& key) const { return count(key) == 1; }$/;"	f	class:thorin::detail::HashTable
contains	src/thorin/util/indexset.h	/^    bool contains(Key key) const { return (*this)[key]; }$/;"	f	class:thorin::IndexSet
contains_continuation	src/thorin/def.h	/^    bool contains_continuation() const { return contains_continuation_; }$/;"	f	class:thorin::Def
contains_continuation_	src/thorin/def.h	/^    bool contains_continuation_;$/;"	m	class:thorin::Def
contains_ptrtype	src/thorin/be/llvm/runtime.cpp	/^static bool contains_ptrtype(const Type* type) {$/;"	f	namespace:thorin
context	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<llvm::LLVMContext>& context() { return context_; }$/;"	f	class:thorin::CodeGen
context_	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<llvm::LLVMContext> context_;$/;"	m	class:thorin::CodeGen
continuation	src/thorin/analyses/cfg.h	/^    Continuation* continuation() const { return continuation_; }$/;"	f	class:thorin::CFNode
continuation	src/thorin/analyses/schedule.h	/^        Continuation* continuation() const { return node()->continuation(); }$/;"	f	class:thorin::Schedule::Block
continuation	src/thorin/continuation.h	/^    Continuation* continuation() const { return continuation_; }$/;"	f	class:thorin::Param
continuation	src/thorin/world.cpp	/^Continuation* World::continuation(const FnType* fn, CC cc, Intrinsic intrinsic, Debug dbg) {$/;"	f	class:thorin::World
continuation	src/thorin/world.h	/^    Continuation* continuation(Debug dbg = {}) { return continuation(fn_type(), CC::C, Intrinsic::None, dbg); }$/;"	f	class:thorin::World
continuation	src/thorin/world.h	/^    Continuation* continuation(const FnType* fn, Debug dbg = {}) { return continuation(fn, CC::C, Intrinsic::None, dbg); }$/;"	f	class:thorin::World
continuation_	src/thorin/analyses/cfg.h	/^    Continuation* continuation_;$/;"	m	class:thorin::CFNode
continuation_	src/thorin/continuation.h	/^    Continuation* const continuation_;$/;"	m	class:thorin::Param
continuations	src/thorin/world.h	/^    const ContinuationSet& continuations() const { return continuations_; }$/;"	f	class:thorin::World
continuations_	src/thorin/world.h	/^    ContinuationSet continuations_;$/;"	m	class:thorin::World
convert	src/thorin/be/llvm/llvm.cpp	/^llvm::Type* CodeGen::convert(const Type* type) {$/;"	f	class:thorin::CodeGen
convert	src/thorin/transform/closure_conversion.cpp	/^    const Def* convert(const Def* def, bool as_callee = false) {$/;"	f	class:thorin::ClosureConversion
convert	src/thorin/transform/closure_conversion.cpp	/^    const Type* convert(const Type* type) {$/;"	f	class:thorin::ClosureConversion
convert	src/thorin/world.cpp	/^const Def* World::convert(const Type* dst_type, const Def* src, Debug dbg) {$/;"	f	class:thorin::World
convert_addr_space	src/thorin/be/llvm/amdgpu.cpp	/^unsigned AMDGPUCodeGen::convert_addr_space(const AddrSpace addr_space) {$/;"	f	class:thorin::AMDGPUCodeGen
convert_addr_space	src/thorin/be/llvm/llvm.cpp	/^unsigned CodeGen::convert_addr_space(const AddrSpace addr_space) {$/;"	f	class:thorin::CodeGen
convert_fn_type	src/thorin/be/llvm/llvm.cpp	/^llvm::FunctionType* CodeGen::convert_fn_type(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
convert_fn_type	src/thorin/be/llvm/nvvm.cpp	/^llvm::FunctionType* NVVMCodeGen::convert_fn_type(Continuation* continuation) {$/;"	f	class:thorin::NVVMCodeGen
convert_jump	src/thorin/transform/closure_conversion.cpp	/^    void convert_jump(Continuation* continuation) {$/;"	f	class:thorin::ClosureConversion
copy_continuations	src/thorin/world.cpp	/^Array<Continuation*> World::copy_continuations() const {$/;"	f	class:thorin::World
copy_uses	src/thorin/def.h	/^    Array<Use> copy_uses() const { return Array<Use>(uses_.begin(), uses_.end()); }$/;"	f	class:thorin::Def
count	src/thorin/util/hash.h	/^    size_t count(const key_type& key) const { return find(key) == end() ? 0 : 1; }$/;"	f	class:thorin::detail::HashTable
cpu_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> cpu_cg;$/;"	m	struct:thorin::Backends
create	src/thorin/analyses/domfrontier.cpp	/^void DomFrontierBase<forward>::create() {$/;"	f	class:thorin::DomFrontierBase
create	src/thorin/analyses/domtree.cpp	/^void DomTreeBase<forward>::create() {$/;"	f	class:thorin::DomTreeBase
create_loop	src/thorin/be/llvm/llvm.cpp	/^void CodeGen::create_loop(llvm::Value* lower, llvm::Value* upper, llvm::Value* increment, llvm::Function* entry, std::function<void(llvm::Value*)> fun) {$/;"	f	class:thorin::CodeGen
create_tmp_alloca	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::create_tmp_alloca(llvm::Type* type, std::function<llvm::Value* (llvm::AllocaInst*)> fun) {$/;"	f	class:thorin::CodeGen
cse	src/thorin/world.h	/^    template<class T> const T* cse(const T* primop) { return cse_base(primop)->template as<T>(); }$/;"	f	class:thorin::World
cse_base	src/thorin/world.cpp	/^const Def* World::cse_base(const PrimOp* primop) {$/;"	f	class:thorin::World
cuda	src/thorin/be/llvm/llvm.h	/^    Importer cuda;$/;"	m	struct:thorin::Backends
cuda_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> cuda_cg;$/;"	m	struct:thorin::Backends
cut	src/thorin/util/array.h	/^    Array<T> cut(ArrayRef<size_t> indices, size_t reserve = 0) const { return ArrayRef<T>(*this).cut(indices, reserve); }$/;"	f	class:thorin::Array
cut	src/thorin/util/array.h	/^Array<T> ArrayRef<T>::cut(ArrayRef<size_t> indices, size_t reserve) const {$/;"	f	class:thorin::ArrayRef
data	src/thorin/util/array.h	/^    T* data() { return ptr_; }$/;"	f	class:thorin::Array
data	src/thorin/util/array.h	/^    const T* data() const { return ptr_; }$/;"	f	class:thorin::Array
data	src/thorin/util/types.h	/^    FT data() const { return data_; }$/;"	f	class:thorin::Float
data	src/thorin/util/types.h	/^    ST data() const { return data_; }$/;"	f	class:thorin::SInt
data	src/thorin/util/types.h	/^    UT data() const { return data_; }$/;"	f	class:thorin::UInt
data_	src/thorin/util/types.h	/^    FT data_;$/;"	m	class:thorin::Float
data_	src/thorin/util/types.h	/^    ST data_;$/;"	m	class:thorin::SInt
data_	src/thorin/util/types.h	/^    UT data_;$/;"	m	class:thorin::UInt
dcast	src/thorin/util/cast.h	/^inline L* dcast(R* u) {$/;"	f	namespace:thorin
dcast	src/thorin/util/cast.h	/^inline const L* dcast(const R* r) { return const_cast<const L*>(dcast<L, R>(const_cast<R*>(r))); }$/;"	f	namespace:thorin
dead_load_opt	src/thorin/transform/dead_load_opt.cpp	/^static void dead_load_opt(const Scope& scope) {$/;"	f	namespace:thorin
dead_load_opt	src/thorin/transform/dead_load_opt.cpp	/^void dead_load_opt(World& world) {$/;"	f	namespace:thorin
debug	src/thorin/def.h	/^    Debug& debug() const { return debug_; }$/;"	f	class:thorin::Def
debug	src/thorin/util/hash.h	/^    void debug(size_t i) {$/;"	f	class:thorin::detail::HashTable
debug	src/thorin/util/hash.h	/^    void debug(size_t) {}$/;"	f	class:thorin::detail::HashTable
debug_	src/thorin/be/c.cpp	/^    bool debug_;$/;"	m	class:thorin::CCodeGen	file:
debug_	src/thorin/def.h	/^    mutable Debug debug_;$/;"	m	class:thorin::Def
debug_hash	src/thorin/util/hash.cpp	/^void debug_hash() {$/;"	f	namespace:thorin
debug_history	src/thorin/def.cpp	/^Debug Def::debug_history() const {$/;"	f	class:thorin::Def
debug_verify	src/thorin/analyses/verify.h	/^inline void debug_verify(World& world) { verify(world); }$/;"	f	namespace:thorin
debug_verify	src/thorin/analyses/verify.h	/^inline void debug_verify(World&) {}$/;"	f	namespace:thorin
dec_indent	src/thorin/util/stream.cpp	/^void dec_indent() { indent--; }$/;"	f	namespace:thorin::detail
def	src/thorin/continuation.h	/^        const Def* def() const { return def_; }$/;"	f	class:thorin::Param::Peek
def	src/thorin/def.h	/^    const Def* def() const { return def_; }$/;"	f	class:thorin::Use
def	src/thorin/def.h	/^    const Def* def() const {$/;"	f	class:thorin::Use
def	src/thorin/def.h	/^    const Def* def() {$/;"	f	class:thorin::Tracker
def	src/thorin/primop.h	/^    const Def* def() const { return op(0); }$/;"	f	class:thorin::Hlt
def	src/thorin/primop.h	/^    const Def* def() const { return op(0); }$/;"	f	class:thorin::Known
def	src/thorin/primop.h	/^    const Def* def() const { return op(0); }$/;"	f	class:thorin::Run
def2color_	src/thorin/analyses/verify.cpp	/^    DefMap<Color> def2color_;$/;"	m	class:thorin::Cycles	file:
def2def	src/thorin/transform/mangle.h	/^    const Def* def2def(const Def* def) { return find(def2def_, def); }$/;"	f	class:thorin::Mangler
def2def_	src/thorin/transform/mangle.h	/^    Def2Def def2def_;$/;"	m	class:thorin::Mangler
def2early_	src/thorin/analyses/schedule.cpp	/^    Def2CFNode def2early_;$/;"	m	class:thorin::Scheduler	file:
def2late_	src/thorin/analyses/schedule.cpp	/^    Def2CFNode def2late_;$/;"	m	class:thorin::Scheduler	file:
def2smart_	src/thorin/analyses/schedule.cpp	/^    Def2CFNode def2smart_;$/;"	m	class:thorin::Scheduler	file:
def2str_	src/thorin/be/c.cpp	/^    DefMap<std::string> def2str_;$/;"	m	class:thorin::CCodeGen	file:
def2uses_	src/thorin/analyses/schedule.cpp	/^    DefMap<Uses> def2uses_;$/;"	m	class:thorin::Scheduler	file:
def_	src/thorin/continuation.h	/^        const Def* def_;$/;"	m	class:thorin::Param::Peek
def_	src/thorin/def.h	/^    const Def* def_;$/;"	m	class:thorin::Tracker
def_	src/thorin/def.h	/^    const Def* def_;$/;"	m	class:thorin::Use
def_old2new_	src/thorin/transform/importer.h	/^    Def2Def def_old2new_;$/;"	m	class:thorin::Importer
definite_array	src/thorin/world.h	/^    const Def* definite_array(Defs args, Debug dbg = {}) {$/;"	f	class:thorin::World
definite_array	src/thorin/world.h	/^    const Def* definite_array(const Type* elem, Defs args, Debug dbg = {}) {$/;"	f	class:thorin::World
definite_array_type	src/thorin/type.h	/^    const DefiniteArrayType*   definite_array_type(const Type* elem, u64 dim) { return unify(new DefiniteArrayType(*this, elem, dim)); }$/;"	f	class:thorin::TypeTable
defs	src/thorin/analyses/scope.h	/^    const DefSet& defs() const { return defs_; }$/;"	f	class:thorin::Scope
defs_	src/thorin/analyses/scope.h	/^    DefSet defs_;$/;"	m	class:thorin::Scope
defs_	src/thorin/transform/mangle.h	/^    DefSet defs_;$/;"	m	class:thorin::Mangler
depth	src/thorin/analyses/domtree.cpp	/^void DomTreeBase<forward>::depth(const CFNode* n, int i) {$/;"	f	class:thorin::DomTreeBase
depth	src/thorin/analyses/domtree.h	/^    int depth(const CFNode* n) const { return depth_[n]; }$/;"	f	class:thorin::DomTreeBase
depth	src/thorin/analyses/looptree.h	/^        int depth() const { return depth_; }$/;"	f	class:thorin::LoopTree::Node
depth	src/thorin/type.h	/^    int depth() const { return depth_; }$/;"	f	class:thorin::Var
depth_	src/thorin/analyses/domtree.h	/^    typename CFG<forward>::template Map<int> depth_;$/;"	m	class:thorin::DomTreeBase
depth_	src/thorin/analyses/looptree.h	/^        int depth_;$/;"	m	class:thorin::LoopTree::Node
depth_	src/thorin/type.h	/^    int depth_;$/;"	m	class:thorin::Var
desired_pos	src/thorin/util/hash.h	/^    size_t desired_pos(const key_type& key) const { return mod(H::hash(key)); }$/;"	f	class:thorin::detail::HashTable
destroy_body	src/thorin/continuation.cpp	/^void Continuation::destroy_body() {$/;"	f	class:thorin::Continuation
destroy_filter	src/thorin/continuation.h	/^    void destroy_filter() { filter_.shrink(0); }$/;"	f	class:thorin::Continuation
detail	src/thorin/def.h	/^namespace detail {$/;"	n	namespace:thorin
detail	src/thorin/util/hash.h	/^namespace detail {$/;"	n	namespace:thorin
detail	src/thorin/util/stream.cpp	/^namespace detail {$/;"	n	namespace:thorin	file:
detail	src/thorin/util/stream.h	/^namespace detail {$/;"	n	namespace:thorin
device	src/thorin/type.h	/^    int32_t device() const { return device_; }$/;"	f	class:thorin::PtrType
device_	src/thorin/type.h	/^    int32_t device_;$/;"	m	class:thorin::PtrType
device_calling_convention_	src/thorin/be/llvm/llvm.h	/^    llvm::CallingConv::ID device_calling_convention_;$/;"	m	class:thorin::CodeGen
dfs	src/thorin/analyses/looptree.cpp	/^        size_t dfs; \/\/ depth-first-search number$/;"	m	struct:thorin::LoopTreeBuilder::Number	file:
dfs	src/thorin/analyses/looptree.cpp	/^    size_t& dfs(const CFNode* n) { return number(n).dfs; }$/;"	f	class:thorin::LoopTreeBuilder	file:
dibuilder_	src/thorin/be/llvm/llvm.h	/^    llvm::DIBuilder dibuilder_;$/;"	m	class:thorin::CodeGen
difference_type	src/thorin/util/hash.h	/^        typedef std::ptrdiff_t difference_type;$/;"	t	class:thorin::detail::HashTable::iterator_base
difference_type	src/thorin/util/iterator.h	/^    typedef typename std::iterator_traits<I>::difference_type difference_type;$/;"	t	class:thorin::filter_iterator
difference_type	src/thorin/util/iterator.h	/^    typedef typename std::iterator_traits<I>::difference_type difference_type;$/;"	t	class:thorin::map_iterator
dim	src/thorin/type.h	/^    u64 dim() const { return dim_; }$/;"	f	class:thorin::DefiniteArrayType
dim_	src/thorin/type.h	/^    u64 dim_;$/;"	m	class:thorin::DefiniteArrayType
distance	src/thorin/util/iterator.h	/^    size_t distance() const { return std::distance(begin(), end()); }$/;"	f	struct:thorin::Range
div_check	src/thorin/util/types.h	/^    void div_check(SInt other) const {$/;"	f	class:thorin::SInt
div_check	src/thorin/util/types.h	/^    void div_check(UInt other) const { if (other.data_ == UT(0u)) throw BottomException(); }$/;"	f	class:thorin::UInt
domain	src/thorin/util/args.h	/^    const std::string& domain() const { return domain_; }$/;"	f	class:thorin::BasicOption
domain_	src/thorin/util/args.h	/^    std::string domain_;$/;"	m	class:thorin::BasicOption
domfrontier	src/thorin/analyses/cfg.cpp	/^template<bool forward> const DomFrontierBase<forward>& CFG<forward>::domfrontier() const { return lazy_init(this, domfrontier_); }$/;"	f	class:thorin::CFG
domfrontier_	src/thorin/analyses/cfg.h	/^    mutable std::unique_ptr<const DomFrontierBase<forward>> domfrontier_;$/;"	m	class:thorin::CFG
domtree	src/thorin/analyses/cfg.cpp	/^template<bool forward> const DomTreeBase<forward>& CFG<forward>::domtree() const { return lazy_init(this, domtree_); }$/;"	f	class:thorin::CFG
domtree_	src/thorin/analyses/cfg.h	/^    mutable std::unique_ptr<const DomTreeBase<forward>> domtree_;$/;"	m	class:thorin::CFG
domtree_	src/thorin/analyses/schedule.cpp	/^    const DomTree& domtree_;$/;"	m	class:thorin::Scheduler	file:
done_	src/thorin/transform/partial_evaluation.cpp	/^    ContinuationSet done_;$/;"	m	class:thorin::PartialEvaluator	file:
done_	src/thorin/util/utility.h	/^    Set done_;$/;"	m	class:thorin::unique_queue
done_	src/thorin/util/utility.h	/^    Set done_;$/;"	m	class:thorin::unique_stack
down	src/thorin/util/stream.h	/^std::basic_ostream<charT,traits>& down(std::basic_ostream<charT,traits>& os) { detail::dec_indent(); return os; }$/;"	f	namespace:thorin
down_endl	src/thorin/util/stream.h	/^std::basic_ostream<charT,traits>& down_endl(std::basic_ostream<charT,traits>& os) { return os << down << endl; }$/;"	f	namespace:thorin
drop	src/thorin/transform/mangle.cpp	/^Continuation* drop(const Call& call) {$/;"	f	namespace:thorin
drop	src/thorin/transform/mangle.h	/^inline Continuation* drop(const Scope& scope, Defs args) {$/;"	f	namespace:thorin
dump	src/thorin/def.cpp	/^void Def::dump() const {$/;"	f	class:thorin::Def
dump	src/thorin/util/array.h	/^    void dump() const { ref().dump(); }$/;"	f	class:thorin::Array
dump	src/thorin/util/array.h	/^    void dump() const { stream(std::cout) << "\\n"; }$/;"	f	class:thorin::ArrayRef
dump	src/thorin/util/hash.h	/^    void dump() const { stream_list(std::cout, *this, [&] (const auto& elem) { std::cout << elem; }, "{", "}\\n"); }$/;"	f	class:thorin::HashSet
dump	src/thorin/util/hash.h	/^    void dump() const {$/;"	f	class:thorin::HashMap
dump	src/thorin/util/stream.cpp	/^void Streamable::dump() const { stream(std::cout) << thorin::endl; }$/;"	f	class:thorin::Streamable
dump_head	src/thorin/continuation.cpp	/^void Continuation::dump_head() const { stream_head(std::cout) << endl; }$/;"	f	class:thorin::Continuation
dump_jump	src/thorin/continuation.cpp	/^void Continuation::dump_jump() const { stream_jump(std::cout) << endl; }$/;"	f	class:thorin::Continuation
duplicate	src/thorin/util/symbol.cpp	/^static const char* duplicate(const char* s) { return _strdup(s); }$/;"	f	namespace:thorin
duplicate	src/thorin/util/symbol.cpp	/^static const char* duplicate(const char* s) { return strdup(s); }$/;"	f	namespace:thorin
eat_pe_info	src/thorin/transform/partial_evaluation.cpp	/^void PartialEvaluator::eat_pe_info(Continuation* cur) {$/;"	f	class:thorin::PartialEvaluator
elem_type	src/thorin/primop.h	/^    const Type* elem_type() const { return type()->elem_type(); }$/;"	f	class:thorin::DefiniteArray
elem_type	src/thorin/primop.h	/^    const Type* elem_type() const { return type()->elem_type(); }$/;"	f	class:thorin::IndefiniteArray
elem_type	src/thorin/type.h	/^    const Type* elem_type() const { return op(0); }$/;"	f	class:thorin::ArrayType
eliminate_params	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::eliminate_params() {$/;"	f	class:thorin::Cleaner
eliminate_tail_rec	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::eliminate_tail_rec() {$/;"	f	class:thorin::Cleaner
emit	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit(const Def* def) {$/;"	f	class:thorin::CCodeGen
emit	src/thorin/be/c.cpp	/^void CCodeGen::emit() {$/;"	f	class:thorin::CCodeGen
emit	src/thorin/be/llvm/cuda.cpp	/^void CUDACodeGen::emit(std::ostream& stream, int \/*opt*\/, bool debug) {$/;"	f	class:thorin::CUDACodeGen
emit	src/thorin/be/llvm/hls.cpp	/^void HLSCodeGen::emit(std::ostream& stream, int \/*opt*\/, bool debug) {$/;"	f	class:thorin::HLSCodeGen
emit	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit(const Def* def) {$/;"	f	class:thorin::CodeGen
emit	src/thorin/be/llvm/llvm.cpp	/^std::unique_ptr<llvm::Module>& CodeGen::emit(int opt, bool debug) {$/;"	f	class:thorin::CodeGen
emit	src/thorin/be/llvm/llvm.cpp	/^void CodeGen::emit(std::ostream& stream, int opt, bool debug) {$/;"	f	class:thorin::CodeGen
emit	src/thorin/be/llvm/opencl.cpp	/^void OpenCLCodeGen::emit(std::ostream& stream, int \/*opt*\/, bool debug) {$/;"	f	class:thorin::OpenCLCodeGen
emit	src/thorin/util/stream.h	/^    Emit emit;$/;"	m	class:thorin::StreamList
emit_addr_space	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_addr_space(std::ostream& os, const Type* type) {$/;"	f	class:thorin::CCodeGen
emit_aggop_decl	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_aggop_decl(const Type* type) {$/;"	f	class:thorin::CCodeGen
emit_aggop_defs	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_aggop_defs(const Def* def) {$/;"	f	class:thorin::CCodeGen
emit_alloc	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_alloc(const Type* type, const Def* extra) {$/;"	f	class:thorin::CodeGen
emit_alloca	src/thorin/be/llvm/llvm.cpp	/^llvm::AllocaInst* CodeGen::emit_alloca(llvm::Type* type, const std::string& name) {$/;"	f	class:thorin::CodeGen
emit_assembly	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_assembly(const Assembly* assembly) {$/;"	f	class:thorin::CodeGen
emit_atomic	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_atomic(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_bitcast	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_bitcast(const Def* val, const Type* dst_type) {$/;"	f	class:thorin::CodeGen
emit_c	src/thorin/be/c.cpp	/^void emit_c(World& world, const Cont2Config& kernel_config, std::ostream& stream, Lang lang, bool debug) { CCodeGen(world, kernel_config, stream, lang, debug).emit(); }$/;"	f	namespace:thorin
emit_cmpxchg	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_cmpxchg(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_debug_info	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_debug_info(const Def* def) {$/;"	f	class:thorin::CCodeGen
emit_float	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_float(T t, IsInfFn is_inf, IsNanFn is_nan) {$/;"	f	class:thorin::CCodeGen
emit_function_decl	src/thorin/be/llvm/llvm.cpp	/^llvm::Function* CodeGen::emit_function_decl(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_function_decl_hook	src/thorin/be/llvm/amdgpu.cpp	/^void AMDGPUCodeGen::emit_function_decl_hook(Continuation* continuation, llvm::Function* f) {$/;"	f	class:thorin::AMDGPUCodeGen
emit_function_decl_hook	src/thorin/be/llvm/llvm.h	/^    virtual void emit_function_decl_hook(Continuation*, llvm::Function*) {}$/;"	f	class:thorin::CodeGen
emit_function_decl_hook	src/thorin/be/llvm/nvvm.cpp	/^void NVVMCodeGen::emit_function_decl_hook(Continuation* continuation, llvm::Function* f) {$/;"	f	class:thorin::NVVMCodeGen
emit_function_start	src/thorin/be/llvm/llvm.h	/^    virtual void emit_function_start(llvm::BasicBlock*, Continuation*) {}$/;"	f	class:thorin::CodeGen
emit_function_start	src/thorin/be/llvm/nvvm.cpp	/^void NVVMCodeGen::emit_function_start(llvm::BasicBlock*, Continuation* continuation) {$/;"	f	class:thorin::NVVMCodeGen
emit_global	src/thorin/be/llvm/amdgpu.cpp	/^llvm::Value* AMDGPUCodeGen::emit_global(const Global* global) {$/;"	f	class:thorin::AMDGPUCodeGen
emit_global	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_global(const Global* global) {$/;"	f	class:thorin::CodeGen
emit_global	src/thorin/be/llvm/nvvm.cpp	/^llvm::Value* NVVMCodeGen::emit_global(const Global* global) {$/;"	f	class:thorin::NVVMCodeGen
emit_global_variable	src/thorin/be/llvm/llvm.cpp	/^llvm::GlobalVariable* CodeGen::emit_global_variable(llvm::Type* type, const std::string& name, unsigned addr_space, bool init_undef) {$/;"	f	class:thorin::CodeGen
emit_hls	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_hls(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_host_code	src/thorin/be/llvm/runtime.cpp	/^Continuation* Runtime::emit_host_code(CodeGen& code_gen, Platform platform, const std::string& ext, Continuation* continuation) {$/;"	f	class:thorin::Runtime
emit_intrinsic	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_intrinsic(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_lea	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_lea(const LEA* lea) {$/;"	f	class:thorin::CodeGen
emit_lea	src/thorin/be/llvm/nvvm.cpp	/^llvm::Value* NVVMCodeGen::emit_lea(const LEA* lea) {$/;"	f	class:thorin::NVVMCodeGen
emit_load	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_load(const Load* load) {$/;"	f	class:thorin::CodeGen
emit_load	src/thorin/be/llvm/nvvm.cpp	/^llvm::Value* NVVMCodeGen::emit_load(const Load* load) {$/;"	f	class:thorin::NVVMCodeGen
emit_parallel	src/thorin/be/llvm/parallel.cpp	/^Continuation* CodeGen::emit_parallel(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_reserve	src/thorin/be/llvm/amdgpu.cpp	/^Continuation* AMDGPUCodeGen::emit_reserve(const Continuation* continuation) { return emit_reserve_shared(continuation, true); }$/;"	f	class:thorin::AMDGPUCodeGen
emit_reserve	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_reserve(const Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_reserve	src/thorin/be/llvm/nvvm.cpp	/^Continuation* NVVMCodeGen::emit_reserve(const Continuation* continuation) { return emit_reserve_shared(continuation); }$/;"	f	class:thorin::NVVMCodeGen
emit_reserve_shared	src/thorin/be/llvm/llvm.cpp	/^Continuation* CodeGen::emit_reserve_shared(const Continuation* continuation, bool init_undef) {$/;"	f	class:thorin::CodeGen
emit_result_phi	src/thorin/be/llvm/llvm.cpp	/^void CodeGen::emit_result_phi(const Param* param, llvm::Value* value) {$/;"	f	class:thorin::CodeGen
emit_spawn	src/thorin/be/llvm/parallel.cpp	/^Continuation* CodeGen::emit_spawn(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_store	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::emit_store(const Store* store) {$/;"	f	class:thorin::CodeGen
emit_store	src/thorin/be/llvm/nvvm.cpp	/^llvm::Value* NVVMCodeGen::emit_store(const Store* store) {$/;"	f	class:thorin::NVVMCodeGen
emit_sync	src/thorin/be/llvm/parallel.cpp	/^Continuation* CodeGen::emit_sync(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emit_type	src/thorin/be/c.cpp	/^std::ostream& CCodeGen::emit_type(std::ostream& os, const Type* type) {$/;"	f	class:thorin::CCodeGen
emit_vectorize	src/thorin/be/llvm/vectorize.cpp	/^void CodeGen::emit_vectorize(u32 vector_length, llvm::Function* kernel_func, llvm::CallInst* simd_kernel_call) {$/;"	f	class:thorin::CodeGen
emit_vectorize_continuation	src/thorin/be/llvm/vectorize.cpp	/^Continuation* CodeGen::emit_vectorize_continuation(Continuation* continuation) {$/;"	f	class:thorin::CodeGen
emplace	src/thorin/util/hash.h	/^    std::pair<iterator,bool> emplace(Args&&... args) {$/;"	f	class:thorin::detail::HashTable
emplace_no_rehash	src/thorin/util/hash.h	/^    std::pair<iterator,bool> emplace_no_rehash(Args&&... args) {$/;"	f	class:thorin::detail::HashTable
empty	src/thorin/def.h	/^    bool empty() const { return ops_.empty(); }$/;"	f	class:thorin::Def
empty	src/thorin/util/array.h	/^    bool empty() const { return size_ == 0; }$/;"	f	class:thorin::Array
empty	src/thorin/util/array.h	/^    bool empty() const { return size_ == 0; }$/;"	f	class:thorin::ArrayRef
empty	src/thorin/util/hash.h	/^    bool empty() const { return size() == 0; }$/;"	f	class:thorin::detail::HashTable
empty	src/thorin/util/symbol.h	/^    bool empty() const { return *str_ == '\\0'; }$/;"	f	class:thorin::Symbol
empty	src/thorin/util/type_table.h	/^    bool empty() const { return ops_.empty(); }$/;"	f	class:thorin::TypeBase
empty	src/thorin/util/utility.h	/^    bool empty() const { return queue_.empty(); }$/;"	f	class:thorin::unique_queue
empty	src/thorin/util/utility.h	/^    bool empty() const { return stack_.empty(); }$/;"	f	class:thorin::unique_stack
empty	src/thorin/world.h	/^    bool empty() const { return continuations().size() <= 2; } \/\/ TODO rework intrinsic stuff. 2 = branch + end_scope$/;"	f	class:thorin::World
enable_history	src/thorin/world.h	/^    void enable_history(bool flag = true) { track_history_ = flag; }$/;"	f	class:thorin::World
end	src/thorin/analyses/schedule.h	/^        const_iterator end() const { return primops().end(); }$/;"	f	class:thorin::Schedule::Block
end	src/thorin/analyses/schedule.h	/^    const_iterator end() const { return blocks().end(); }$/;"	f	class:thorin::Schedule
end	src/thorin/util/array.h	/^    const_iterator end() const { return ptr_ + size_; }$/;"	f	class:thorin::Array
end	src/thorin/util/array.h	/^    const_iterator end() const { return ptr_ + size_; }$/;"	f	class:thorin::ArrayRef
end	src/thorin/util/array.h	/^    iterator end() { return ptr_ + size_; }$/;"	f	class:thorin::Array
end	src/thorin/util/hash.h	/^    const_iterator end() const { return const_iterator(const_cast<HashTable*>(this)->end()); }$/;"	f	class:thorin::detail::HashTable
end	src/thorin/util/hash.h	/^    iterator end() { return iterator(end_ptr(), this); }$/;"	f	class:thorin::detail::HashTable
end	src/thorin/util/indexmap.h	/^    const_iterator end() const { return make_filter(array_.end(), array_.end(), IsValidPred<Value>::is_valid); }$/;"	f	class:thorin::IndexMap
end	src/thorin/util/iterator.h	/^    I end() const { return end_; }$/;"	f	class:thorin::filter_iterator
end	src/thorin/util/iterator.h	/^    I end() const { return end_; }$/;"	f	class:thorin::map_iterator
end	src/thorin/util/iterator.h	/^    I end() const { return end_; }$/;"	f	struct:thorin::Range
end_	src/thorin/util/iterator.h	/^    I end_;$/;"	m	class:thorin::filter_iterator
end_	src/thorin/util/iterator.h	/^    I end_;$/;"	m	class:thorin::map_iterator
end_	src/thorin/util/iterator.h	/^    I end_;$/;"	m	struct:thorin::Range
end_ptr	src/thorin/util/hash.h	/^    value_type* end_ptr() const { return nodes_ + capacity(); }$/;"	f	class:thorin::detail::HashTable
end_scope	src/thorin/world.h	/^    Continuation* end_scope() const { return end_scope_; }$/;"	f	class:thorin::World
end_scope_	src/thorin/world.h	/^    Continuation* end_scope_;$/;"	m	class:thorin::World
endl	src/thorin/util/stream.h	/^std::basic_ostream<charT,traits>& endl(std::basic_ostream<charT,traits>& os) {$/;"	f	namespace:thorin
enqueue	src/thorin/transform/partial_evaluation.cpp	/^    void enqueue(Continuation* continuation) {$/;"	f	class:thorin::PartialEvaluator
enter	src/thorin/world.cpp	/^const Def* World::enter(const Def* mem, Debug dbg) {$/;"	f	class:thorin::World
entry	src/thorin/analyses/cfg.h	/^    const CFNode* entry() const { return entry_; }$/;"	f	class:thorin::CFA
entry	src/thorin/analyses/cfg.h	/^    const CFNode* entry() const { return forward ? cfa().entry() : cfa().exit();  }$/;"	f	class:thorin::CFG
entry	src/thorin/analyses/scope.h	/^    Continuation* entry() const { return entry_; }$/;"	f	class:thorin::Scope
entry_	src/thorin/analyses/cfg.h	/^    const CFNode* entry_;$/;"	m	class:thorin::CFA
entry_	src/thorin/analyses/scope.h	/^    Continuation* entry_ = nullptr;$/;"	m	class:thorin::Scope
entry_	src/thorin/be/llvm/llvm.h	/^    Continuation* entry_ = nullptr;$/;"	m	class:thorin::CodeGen
environment_ptr_type	src/thorin/primop.cpp	/^const PtrType* Closure::environment_ptr_type(World& world) {$/;"	f	class:thorin::Closure
environment_type	src/thorin/primop.cpp	/^const VariantType* Closure::environment_type(World& world) {$/;"	f	class:thorin::Closure
eq	src/thorin/continuation.h	/^        static bool eq(const Call& c1, const Call& c2) { return c1 == c2; }$/;"	f	struct:thorin::Call::Hash
eq	src/thorin/def.h	/^    inline static bool eq(Use u1, Use u2) { return u1 == u2; }$/;"	f	struct:thorin::UseHash
eq	src/thorin/primop.h	/^    static bool eq(const PrimOp* o1, const PrimOp* o2) { return o1->equal(o2); }$/;"	f	struct:thorin::PrimOpHash
eq	src/thorin/transform/split_slots.cpp	/^    static bool eq(u32 a, u32 b) { return a == b; }$/;"	f	struct:thorin::IndexHash
eq	src/thorin/util/hash.h	/^    static bool eq(const char* s1, const char* s2) { return std::strcmp(s1, s2) == 0; }$/;"	f	struct:thorin::StrHash
eq	src/thorin/util/symbol.h	/^        static bool eq(Symbol s1, Symbol s2) { return s1 == s2; }$/;"	f	struct:thorin::Symbol::Hash
eq	src/thorin/util/type_table.h	/^        static bool eq(const Type* t1, const Type* t2) { return t2->equal(t1); }$/;"	f	struct:thorin::TypeTableBase::TypeHash
eq	src/thorin/util/type_table.h	/^    static bool eq(T a, T b) { return a == b; }$/;"	f	struct:thorin::GIDHash
eq	src/thorin/world.h	/^        static bool eq(size_t i1, size_t i2) { return i1 == i2; }$/;"	f	struct:thorin::World::BreakHash
equal	src/thorin/primop.cpp	/^bool PrimLit::equal(const PrimOp* other) const {$/;"	f	class:thorin::PrimLit
equal	src/thorin/primop.cpp	/^bool PrimOp::equal(const PrimOp* other) const {$/;"	f	class:thorin::PrimOp
equal	src/thorin/primop.cpp	/^bool Slot::equal(const PrimOp* other) const { return this == other; }$/;"	f	class:thorin::Slot
equal	src/thorin/type.cpp	/^bool PtrType::equal(const Type* other) const {$/;"	f	class:thorin::PtrType
equal	src/thorin/type.cpp	/^bool Var::equal(const Type* other) const {$/;"	f	class:thorin::Var
equal	src/thorin/util/type_table.h	/^bool TypeBase<TypeTable>::equal(const TypeBase* other) const {$/;"	f	class:thorin::TypeBase
erase	src/thorin/util/hash.h	/^    size_t erase(const key_type& key) {$/;"	f	class:thorin::detail::HashTable
erase	src/thorin/util/hash.h	/^    void erase(const_iterator first, const_iterator last) {$/;"	f	class:thorin::detail::HashTable
erase	src/thorin/util/hash.h	/^    void erase(const_iterator pos) {$/;"	f	class:thorin::detail::HashTable
erase	src/thorin/util/indexset.h	/^    bool erase(Key key) { return set<false>(key); } \/\/\/< Erase \\p key and returns true if successful.$/;"	f	class:thorin::IndexSet
errf	src/thorin/util/log.h	/^template<typename... Args> std::ostream& errf(const char* fmt, Args... args) { return streamf(std::cerr, fmt, std::forward<Args>(args)...); }$/;"	f	namespace:thorin
error	src/thorin/util/log.h	/^    [[noreturn]] static void error(Location location, const char* fmt, Args... args) {$/;"	f	class:thorin::Log
eta_conversion	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::eta_conversion() {$/;"	f	class:thorin::Cleaner
eval	src/thorin/transform/partial_evaluation.cpp	/^    bool eval(size_t i, bool lower2cff) {$/;"	f	class:thorin::CondEval
exit	src/thorin/analyses/cfg.h	/^    const CFNode* exit()  const { return forward ? cfa().exit()  : cfa().entry(); }$/;"	f	class:thorin::CFG
exit	src/thorin/analyses/cfg.h	/^    const CFNode* exit() const { return exit_; }$/;"	f	class:thorin::CFA
exit	src/thorin/analyses/scope.h	/^    Continuation* exit() const { return exit_; }$/;"	f	class:thorin::Scope
exit_	src/thorin/analyses/cfg.h	/^    const CFNode* exit_;$/;"	m	class:thorin::CFA
exit_	src/thorin/analyses/scope.h	/^    Continuation* exit_ = nullptr;$/;"	m	class:thorin::Scope
externals	src/thorin/world.h	/^    const ContinuationSet& externals() const { return externals_; }$/;"	f	class:thorin::World
externals_	src/thorin/world.h	/^    ContinuationSet externals_;$/;"	m	class:thorin::World
extra	src/thorin/primop.h	/^    const Def* extra() const { return op(1); }$/;"	f	class:thorin::Alloc
extract	src/thorin/world.cpp	/^const Def* World::extract(const Def* agg, const Def* index, Debug dbg) {$/;"	f	class:thorin::World
extract	src/thorin/world.h	/^    const Def* extract(const Def* tuple, u32 index, Debug dbg = {}) {$/;"	f	class:thorin::World
extract_from_slot	src/thorin/transform/resolve_loads.cpp	/^    const Def* extract_from_slot(const Def* ptr, const Def* slot_value, Debug dbg) {$/;"	f	class:thorin::ResolveLoads
extracted_type	src/thorin/primop.cpp	/^const Type* Extract::extracted_type(const Def* agg, const Def* index) {$/;"	f	class:thorin::Extract
f16	src/thorin/util/types.h	/^typedef half   f16; typedef Float<f16, true> pf16; typedef Float<f16, false> qf16;$/;"	t	namespace:thorin
f16_	src/thorin/util/types.h	/^    f16 f16_; f32 f32_; f64 f64_;$/;"	m	union:thorin::Box
f32	src/thorin/util/types.h	/^typedef float  f32; typedef Float<f32, true> pf32; typedef Float<f32, false> qf32;$/;"	t	namespace:thorin
f32_	src/thorin/util/types.h	/^    f16 f16_; f32 f32_; f64 f64_;$/;"	m	union:thorin::Box
f64	src/thorin/util/types.h	/^typedef double f64; typedef Float<f64, true> pf64; typedef Float<f64, false> qf64;$/;"	t	namespace:thorin
f64_	src/thorin/util/types.h	/^    f16 f16_; f32 f32_; f64 f64_;$/;"	m	union:thorin::Box
f_cfg	src/thorin/analyses/cfg.cpp	/^const F_CFG& CFA::f_cfg() const { return lazy_init(this, f_cfg_); }$/;"	f	class:thorin::CFA
f_cfg	src/thorin/analyses/scope.cpp	/^const F_CFG& Scope::f_cfg() const { return cfa().f_cfg(); }$/;"	f	class:thorin::Scope
f_cfg_	src/thorin/analyses/cfg.h	/^    mutable std::unique_ptr<const F_CFG> f_cfg_;$/;"	m	class:thorin::CFA
f_index_	src/thorin/analyses/cfg.h	/^    mutable size_t f_index_ = -1; \/\/\/< RPO index in a forward @p CFG.$/;"	m	class:thorin::CFNode
fcts_	src/thorin/be/llvm/llvm.h	/^    ContinuationMap<llvm::Function*> fcts_;$/;"	m	class:thorin::CodeGen
features	build/CMakeFiles/feature_tests.c	/^  const char features[] = {"\\n"$/;"	v
features	build/CMakeFiles/feature_tests.cxx	/^  const char features[] = {"\\n"$/;"	v
filename	src/thorin/util/location.h	/^    const char* filename() const { return filename_; }$/;"	f	class:thorin::Location
filename_	src/thorin/util/location.h	/^    const char* filename_ = nullptr;$/;"	m	class:thorin::Location
fileno	src/thorin/util/log.cpp	8;"	d	file:
files	src/thorin/util/ycomp.h	/^    std::vector<std::string> files;$/;"	m	class:thorin::YCompCommandLine
fill	src/thorin/util/hash.h	/^    value_type* fill(value_type* nodes) {$/;"	f	class:thorin::detail::HashTable
filter	src/thorin/continuation.h	/^    Defs filter() const { return filter_; }$/;"	f	class:thorin::Continuation
filter	src/thorin/continuation.h	/^    const Def* filter(size_t i) const { return filter_[i]; }$/;"	f	class:thorin::Continuation
filter	src/thorin/transform/partial_evaluation.cpp	/^    const Def* filter(size_t i) {$/;"	f	class:thorin::CondEval
filter_	src/thorin/continuation.h	/^    Array<const Def*> filter_; \/\/\/< used during @p partial_evaluation$/;"	m	class:thorin::Continuation
filter_iterator	src/thorin/util/iterator.h	/^    filter_iterator(I iterator, I end, P predicate)$/;"	f	class:thorin::filter_iterator
filter_iterator	src/thorin/util/iterator.h	/^    filter_iterator(const filter_iterator& other)$/;"	f	class:thorin::filter_iterator
filter_iterator	src/thorin/util/iterator.h	/^    filter_iterator(filter_iterator&& other)$/;"	f	class:thorin::filter_iterator
filter_iterator	src/thorin/util/iterator.h	/^class filter_iterator {$/;"	c	namespace:thorin
find	src/thorin/util/hash.h	/^    const_iterator find(const key_type& key) const {$/;"	f	class:thorin::detail::HashTable
find	src/thorin/util/hash.h	/^    iterator find(const key_type& k) {$/;"	f	class:thorin::detail::HashTable
find	src/thorin/util/hash.h	/^T* find(const HashMap<Key, T*, H>& map, const typename HashMap<Key, T*, H>::key_type& key) {$/;"	f	namespace:thorin
find	src/thorin/util/indexmap.h	/^inline Value* find(IndexMap<Indexer, Key, Value*>& map, Key key) {$/;"	f	namespace:thorin
find	src/thorin/util/indexmap.h	/^inline const Value* find(const IndexMap<Indexer, Key, Value*>& map, Key key) {$/;"	f	namespace:thorin
find_enters	src/thorin/transform/hoist_enters.cpp	/^static void find_enters(std::deque<const Enter*>& enters, Continuation* continuation) {$/;"	f	namespace:thorin
find_enters	src/thorin/transform/hoist_enters.cpp	/^static void find_enters(std::deque<const Enter*>& enters, const Def* def) {$/;"	f	namespace:thorin
find_slot	src/thorin/transform/resolve_loads.cpp	/^    const Def* find_slot(const Def* ptr, bool must_be_safe = true) {$/;"	f	class:thorin::ResolveLoads
fix	src/thorin/type.h	/^    void fix() {$/;"	f	class:thorin::TypeTable
flags	src/thorin/primop.h	/^    Flags flags() const { return flags_; }$/;"	f	class:thorin::Assembly
flags_	src/thorin/primop.h	/^    Flags flags_;$/;"	m	class:thorin::Assembly
flatten_tuples	src/thorin/transform/flatten_tuples.cpp	/^static void flatten_tuples(World& world, size_t max_tuple_size) {$/;"	f	namespace:thorin
flatten_tuples	src/thorin/transform/flatten_tuples.cpp	/^void flatten_tuples(World& world) {$/;"	f	namespace:thorin
fn0_	src/thorin/type.h	/^    const FnType* fn0_;$/;"	m	class:thorin::TypeTable
fn_mem_	src/thorin/be/c.cpp	/^    const FnType* fn_mem_;$/;"	m	class:thorin::CCodeGen	file:
fn_type	src/thorin/type.h	/^    const FnType* fn_type() { return fn0_; } \/\/\/< Returns an empty @p FnType.$/;"	f	class:thorin::TypeTable
fn_type	src/thorin/type.h	/^    const FnType* fn_type(Types args) { return unify(new FnType(*this, args)); }$/;"	f	class:thorin::TypeTable
fold_1_tuple	src/thorin/world.cpp	/^static bool fold_1_tuple(const Type* type, const Def* index) {$/;"	f	namespace:thorin
for_all_primops	src/thorin/analyses/schedule.cpp	/^    void for_all_primops(std::function<void(const PrimOp*)> f) {$/;"	f	class:thorin::Scheduler
for_each	src/thorin/analyses/scope.cpp	/^void Scope::for_each(const World& world, std::function<void(Scope&)> f) {$/;"	f	class:thorin::Scope
force_inline	src/thorin/transform/inliner.cpp	/^void force_inline(Scope& scope, int threshold) {$/;"	f	namespace:thorin
force_use_dump	src/thorin/def.cpp	/^void force_use_dump() {$/;"	f	namespace:thorin
frame	src/thorin/primop.h	/^    const Def* frame() const { return op(0); }$/;"	f	class:thorin::Slot
frame_	src/thorin/type.h	/^    const FrameType* frame_;$/;"	m	class:thorin::TypeTable
frame_type	src/thorin/type.h	/^    const FrameType* frame_type() const { return frame_; }$/;"	f	class:thorin::TypeTable
free	src/thorin/analyses/scope.cpp	/^const DefSet& Scope::free() const {$/;"	f	class:thorin::Scope
free_	src/thorin/analyses/scope.h	/^    mutable std::unique_ptr<DefSet> free_;$/;"	m	class:thorin::Scope
free_defs	src/thorin/analyses/free_defs.cpp	/^DefSet free_defs(Continuation* entry) {$/;"	f	namespace:thorin
free_defs	src/thorin/analyses/free_defs.cpp	/^DefSet free_defs(const Scope& scope, bool include_closures) {$/;"	f	namespace:thorin
free_params	src/thorin/analyses/scope.cpp	/^const ParamSet& Scope::free_params() const {$/;"	f	class:thorin::Scope
free_params_	src/thorin/analyses/scope.h	/^    mutable std::unique_ptr<ParamSet> free_params_;$/;"	m	class:thorin::Scope
from	src/thorin/continuation.h	/^        Continuation* from() const { return from_; }$/;"	f	class:thorin::Param::Peek
from	src/thorin/primop.h	/^    const Def* from() const { return op(0); }$/;"	f	class:thorin::ConvOp
from_	src/thorin/continuation.h	/^        Continuation* from_;$/;"	m	class:thorin::Param::Peek
front	src/thorin/util/array.h	/^    T const& front() const { assert(!empty()); return ptr_[0]; }$/;"	f	class:thorin::ArrayRef
front	src/thorin/util/array.h	/^    T& front() const { assert(!empty()); return ptr_[0]; }$/;"	f	class:thorin::Array
front	src/thorin/util/location.h	/^    Location front() const { return {filename_, front_line(), front_col(), front_line(), front_col()}; }$/;"	f	class:thorin::Location
front_col	src/thorin/util/location.h	/^    uint32_t front_col() const { return front_col_; }$/;"	f	class:thorin::Location
front_col_	src/thorin/util/location.h	/^    uint16_t front_line_ = 1, front_col_ = 1, back_line_ = 1, back_col_ = 1;$/;"	m	class:thorin::Location
front_line	src/thorin/util/location.h	/^    uint32_t front_line() const { return front_line_; }$/;"	f	class:thorin::Location
front_line_	src/thorin/util/location.h	/^    uint16_t front_line_ = 1, front_col_ = 1, back_line_ = 1, back_col_ = 1;$/;"	m	class:thorin::Location
func_decls_	src/thorin/be/c.cpp	/^    std::ostringstream func_decls_;$/;"	m	class:thorin::CCodeGen	file:
func_impl_	src/thorin/be/c.cpp	/^    std::ostringstream func_impl_;$/;"	m	class:thorin::CCodeGen	file:
function	src/thorin/util/iterator.h	/^    F function() const { return function_; }$/;"	f	class:thorin::map_iterator
function_	src/thorin/util/iterator.h	/^    F function_;$/;"	m	class:thorin::map_iterator
function_calling_convention_	src/thorin/be/llvm/llvm.h	/^    llvm::CallingConv::ID function_calling_convention_;$/;"	m	class:thorin::CodeGen
fval	src/thorin/primop.h	/^    const Def* fval() const { return op(2); }$/;"	f	class:thorin::Select
get	src/thorin/be/llvm/runtime.cpp	/^llvm::Function* Runtime::get(const char* name) {$/;"	f	class:thorin::Runtime
get	src/thorin/primop.h	/^T get(ArrayRef<T> array, const Def* def) { return array[primlit_value<size_t>(def)]; }$/;"	f	namespace:thorin
get	src/thorin/util/hash.h	/^    struct get_key { static K& get(std::pair<K, V>& pair) { return pair.first; } };$/;"	f	struct:thorin::detail::HashTable::get_key
get	src/thorin/util/hash.h	/^    struct get_key<K, void> { static K& get(K& key) { return key; } };$/;"	f	struct:thorin::detail::HashTable::get_key
get	src/thorin/util/types.h	/^    template <typename T> inline T get() { THORIN_UNREACHABLE; }$/;"	f	union:thorin::Box
get_alloc_call	src/thorin/be/llvm/llvm.cpp	/^static const Continuation* get_alloc_call(const Def* def) {$/;"	f	namespace:thorin
get_alloc_size	src/thorin/be/llvm/llvm.cpp	/^static uint64_t get_alloc_size(const Def* def) {$/;"	f	namespace:thorin
get_back	src/thorin/util/array.h	/^    ArrayRef<T> get_back  (size_t num = 1) const { assert(num <= size()); return ArrayRef<T>(ptr_ + size() - num, num); }$/;"	f	class:thorin::Array
get_back	src/thorin/util/array.h	/^    ArrayRef<T> get_back  (size_t num = 1) const { assert(num <= size()); return ArrayRef<T>(ptr_ + size() - num, num); }$/;"	f	class:thorin::ArrayRef
get_f16	src/thorin/util/types.h	/^    f16 get_f16() const { return f16_; }$/;"	f	union:thorin::Box
get_f32	src/thorin/util/types.h	/^    f32 get_f32() const { return f32_; }$/;"	f	union:thorin::Box
get_f64	src/thorin/util/types.h	/^    f64 get_f64() const { return f64_; }$/;"	f	union:thorin::Box
get_front	src/thorin/util/array.h	/^    ArrayRef<T> get_front (size_t num = 1) const { assert(num <= size()); return ArrayRef<T>(ptr_, num); }$/;"	f	class:thorin::Array
get_front	src/thorin/util/array.h	/^    ArrayRef<T> get_front (size_t num = 1) const { assert(num <= size()); return ArrayRef<T>(ptr_, num); }$/;"	f	class:thorin::ArrayRef
get_indent	src/thorin/util/stream.cpp	/^unsigned int get_indent() { return indent; }$/;"	f	namespace:thorin::detail
get_kernel_configs	src/thorin/be/llvm/llvm.cpp	/^static void get_kernel_configs(Importer& importer,$/;"	f	namespace:thorin
get_key	src/thorin/util/hash.h	/^    struct get_key { static K& get(std::pair<K, V>& pair) { return pair.first; } };$/;"	s	class:thorin::detail::HashTable
get_key	src/thorin/util/hash.h	/^    struct get_key<K, void> { static K& get(K& key) { return key; } };$/;"	s	class:thorin::detail::HashTable
get_lang	src/thorin/be/c.cpp	/^const std::string CCodeGen::get_lang() const {$/;"	f	class:thorin::CCodeGen
get_min_level	src/thorin/util/log.cpp	/^Log::Level Log::get_min_level() { return min_level_; }$/;"	f	class:thorin::Log
get_name	src/thorin/be/c.cpp	/^std::string& CCodeGen::get_name(const Def* def) {$/;"	f	class:thorin::CCodeGen
get_name	src/thorin/be/c.cpp	/^std::string& CCodeGen::get_name(const Type* type) {$/;"	f	class:thorin::CCodeGen
get_nodes	src/thorin/analyses/looptree.h	/^    static void get_nodes(std::vector<const Node *>& nodes, const Node* node) {$/;"	f	class:thorin::LoopTree
get_s16	src/thorin/util/types.h	/^    s16 get_s16() const { return s16_; } u16 get_u16() const { return u16_; }$/;"	f	union:thorin::Box
get_s32	src/thorin/util/types.h	/^    s32 get_s32() const { return s32_; } u32 get_u32() const { return u32_; }$/;"	f	union:thorin::Box
get_s64	src/thorin/util/types.h	/^    s64 get_s64() const { return s64_; } u64 get_u64() const { return u64_; }$/;"	f	union:thorin::Box
get_s8	src/thorin/util/types.h	/^     s8  get_s8() const { return  s8_; }  u8  get_u8() const { return  u8_; }$/;"	f	union:thorin::Box
get_stream	src/thorin/util/log.cpp	/^std::ostream* Log::get_stream() { return stream_; }$/;"	f	class:thorin::Log
get_texture_fetch_command	src/thorin/be/llvm/nvvm.cpp	/^static std::string get_texture_fetch_command(const Type* type) {$/;"	f	namespace:thorin
get_texture_fetch_constraint	src/thorin/be/llvm/nvvm.cpp	/^static std::string get_texture_fetch_constraint(const Type* type) {$/;"	f	namespace:thorin
get_texture_handle_fun	src/thorin/be/llvm/nvvm.cpp	/^llvm::Function* NVVMCodeGen::get_texture_handle_fun() {$/;"	f	class:thorin::NVVMCodeGen
get_u16	src/thorin/util/types.h	/^    s16 get_s16() const { return s16_; } u16 get_u16() const { return u16_; }$/;"	f	union:thorin::Box
get_u32	src/thorin/util/types.h	/^    s32 get_s32() const { return s32_; } u32 get_u32() const { return u32_; }$/;"	f	union:thorin::Box
get_u64	src/thorin/util/types.h	/^    s64 get_s64() const { return s64_; } u64 get_u64() const { return u64_; }$/;"	f	union:thorin::Box
get_u8	src/thorin/util/types.h	/^     s8  get_s8() const { return  s8_; }  u8  get_u8() const { return  u8_; }$/;"	f	union:thorin::Box
get_value	src/thorin/transform/resolve_loads.cpp	/^    const Def* get_value(const Def* alloc, Def2Def& mapping) {$/;"	f	class:thorin::ResolveLoads
gid	src/thorin/analyses/cfg.h	/^    uint64_t gid() const { return gid_; }$/;"	f	class:thorin::CFNode
gid	src/thorin/def.h	/^    size_t gid() const { return gid_; }$/;"	f	class:thorin::Def
gid	src/thorin/util/type_table.h	/^    size_t gid() const { return gid_; }$/;"	f	class:thorin::TypeBase
gid_	src/thorin/analyses/cfg.h	/^    size_t gid_;$/;"	m	class:thorin::CFNode
gid_	src/thorin/util/type_table.h	/^    mutable size_t gid_;$/;"	m	class:thorin::TypeBase
gid_counter	src/thorin/def.h	/^    static size_t gid_counter() { return gid_counter_; }$/;"	f	class:thorin::Def
gid_counter	src/thorin/util/type_table.h	/^    static size_t gid_counter() { return gid_counter_; }$/;"	f	class:thorin::TypeBase
gid_counter_	src/thorin/analyses/cfg.cpp	/^uint64_t CFNode::gid_counter_ = 0;$/;"	m	class:thorin::CFNode	file:
gid_counter_	src/thorin/analyses/cfg.h	/^    static uint64_t gid_counter_;$/;"	m	class:thorin::CFNode
gid_counter_	src/thorin/def.cpp	/^size_t Def::gid_counter_ = 1;$/;"	m	class:thorin::Def	file:
gid_counter_	src/thorin/def.h	/^    static size_t gid_counter_;$/;"	m	class:thorin::Def
gid_counter_	src/thorin/util/type_table.h	/^    static size_t gid_counter_;$/;"	m	class:thorin::TypeBase
gid_counter_	src/thorin/util/type_table.h	/^size_t TypeBase<TypeTable>::gid_counter_ = 1;$/;"	m	class:thorin::TypeBase
global	src/thorin/world.cpp	/^const Def* World::global(const Def* init, bool is_mutable, Debug dbg) {$/;"	f	class:thorin::World
global2str_	src/thorin/be/c.cpp	/^    DefMap<std::string> global2str_;$/;"	m	class:thorin::CCodeGen	file:
global_immutable_string	src/thorin/world.cpp	/^const Def* World::global_immutable_string(const std::string& str, Debug dbg) {$/;"	f	class:thorin::World
graph_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static const Type* graph_type(World& world) {$/;"	f	namespace:thorin
graphs	src/thorin/util/ycomp.h	/^    std::vector<std::string> graphs;$/;"	m	class:thorin::YCompCommandLine
handle	src/thorin/util/args.h	/^    BasicOption::iterator handle(BasicOption::iterator it) const {$/;"	f	struct:thorin::Option
handle	src/thorin/util/args.h	/^    BasicOption<target_type>::iterator handle(BasicOption<target_type>::iterator it) const {$/;"	f	struct:thorin::ImplicitOption
handle	src/thorin/util/args.h	/^    typename BasicOption<Data>::iterator handle(typename BasicOption<Data>::iterator it) const {$/;"	f	class:thorin::OptionBase
handle_fmt_specifier	src/thorin/util/stream.h	/^    const char* handle_fmt_specifier(std::ostream& os, const char* fmt, T val) {$/;"	f	namespace:thorin::detail
handle_option	src/thorin/util/args.h	/^    typename OptionBase<Data, T, Option<T, Data>>::iterator handle_option(typename OptionBase<Data, T, Option<T, Data>>::iterator) const {$/;"	f	struct:thorin::Option
handle_option	src/thorin/util/args.h	/^    typename OptionBase<OptionStringVector, T, self>::iterator handle_option(typename OptionBase<OptionStringVector, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
handle_option	src/thorin/util/args.h	/^    typename OptionBase<YCompCommandLine, T, self>::iterator handle_option(typename OptionBase<YCompCommandLine, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
handle_option	src/thorin/util/args.h	/^    typename OptionBase<bool, T, self>::iterator handle_option(typename OptionBase<bool, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
handle_option	src/thorin/util/args.h	/^    typename OptionBase<int, T, self>::iterator handle_option(typename OptionBase<int, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
handle_option	src/thorin/util/args.h	/^    typename OptionBase<std::string, T, self>::iterator handle_option(typename OptionBase<std::string, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
has_free_params	src/thorin/analyses/scope.h	/^    bool has_free_params() const { return !free_params().empty(); }$/;"	f	class:thorin::Scope
has_free_params	src/thorin/transform/partial_evaluation.cpp	/^    bool has_free_params(Continuation* continuation) {$/;"	f	class:thorin::CondEval
has_multiple_outs	src/thorin/primop.h	/^    virtual bool has_multiple_outs() const { return false; }$/;"	f	class:thorin::PrimOp
has_next	src/thorin/util/args.h	/^    bool has_next(typename OptionBase<YCompCommandLine, T, self>::iterator it) const {$/;"	f	struct:thorin::Option
has_restrict	src/thorin/be/kernel_config.h	/^    bool has_restrict() const { return has_restrict_; }$/;"	f	class:thorin::GPUKernelConfig
has_restrict_	src/thorin/be/kernel_config.h	/^    bool has_restrict_;$/;"	m	class:thorin::GPUKernelConfig
has_sideeffects	src/thorin/primop.h	/^    bool has_sideeffects() const { return flags_ & HasSideEffects; }$/;"	f	class:thorin::Assembly
has_task_or_graph_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static bool has_task_or_graph_type(TypeMap<bool>& cache, const Type* type) {$/;"	f	namespace:thorin
hash	src/thorin/continuation.h	/^        static uint64_t hash(const Call& call) { return call.hash(); }$/;"	f	struct:thorin::Call::Hash
hash	src/thorin/continuation.h	/^    uint64_t hash() const {$/;"	f	struct:thorin::Call
hash	src/thorin/def.h	/^uint64_t UseHash::hash(Use use) { return murmur3(uint64_t(use.index()) << 48_u64 | uint64_t(use->gid())); }$/;"	f	class:thorin::UseHash
hash	src/thorin/primop.h	/^    static uint64_t hash(const PrimOp* o) { return o->hash(); }$/;"	f	struct:thorin::PrimOpHash
hash	src/thorin/primop.h	/^    uint64_t hash() const { return hash_ == 0 ? hash_ = vhash() : hash_; }$/;"	f	class:thorin::PrimOp
hash	src/thorin/transform/split_slots.cpp	/^    static uint64_t hash(u32 u) { return u; }$/;"	f	struct:thorin::IndexHash
hash	src/thorin/util/hash.cpp	/^uint64_t hash(const char* s) {$/;"	f	namespace:thorin
hash	src/thorin/util/hash.h	/^    static uint64_t hash(const char* s) { return thorin::hash(s); }$/;"	f	struct:thorin::StrHash
hash	src/thorin/util/hash.h	/^    uint64_t hash(size_t i) { return H::hash(key(&nodes_[i])); } \/\/\/< just for debugging$/;"	f	class:thorin::detail::HashTable
hash	src/thorin/util/symbol.h	/^        static uint64_t hash(Symbol s) { return thorin::hash(s.c_str()); }$/;"	f	struct:thorin::Symbol::Hash
hash	src/thorin/util/type_table.h	/^        static uint64_t hash(const Type* t) { return t->hash(); }$/;"	f	struct:thorin::TypeTableBase::TypeHash
hash	src/thorin/util/type_table.h	/^    static uint64_t hash(T n) { return thorin::murmur3(n->gid()); }$/;"	f	struct:thorin::GIDHash
hash	src/thorin/util/type_table.h	/^    uint64_t hash() const { return hash_ == 0 ? hash_ = vhash() : hash_; }$/;"	f	class:thorin::TypeBase
hash	src/thorin/world.h	/^        static uint64_t hash(size_t i) { return i; }$/;"	f	struct:thorin::World::BreakHash
hash_	src/thorin/continuation.h	/^    mutable uint64_t hash_ = 0;$/;"	m	struct:thorin::Call
hash_	src/thorin/primop.h	/^    mutable uint64_t hash_ = 0;$/;"	m	class:thorin::PrimOp
hash_	src/thorin/util/type_table.h	/^    mutable uint64_t hash_ = 0;$/;"	m	class:thorin::TypeBase
hash_begin	src/thorin/util/hash.h	/^inline uint64_t hash_begin() { return FNV1::offset; }$/;"	f	namespace:thorin
hash_begin	src/thorin/util/hash.h	/^uint64_t hash_begin(T val) { return hash_combine(FNV1::offset, val); }$/;"	f	namespace:thorin
hash_combine	src/thorin/util/hash.h	/^uint64_t hash_combine(uint64_t seed, T v) {$/;"	f	namespace:thorin
hash_combine	src/thorin/util/hash.h	/^uint64_t hash_combine(uint64_t seed, T val, Args&&... args) {$/;"	f	namespace:thorin
hash_combine	src/thorin/util/hash.h	/^uint64_t hash_combine(uint64_t seed, T* val) { return hash_combine(seed, uintptr_t(val)); }$/;"	f	namespace:thorin
help	src/thorin/util/args.h	/^    const std::string& help() const { return help_; }$/;"	f	class:thorin::BasicOption
help_	src/thorin/util/args.h	/^    std::string help_;$/;"	m	class:thorin::BasicOption
hls	src/thorin/be/llvm/llvm.h	/^    Importer hls;$/;"	m	struct:thorin::Backends
hls_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> hls_cg;$/;"	m	struct:thorin::Backends
hls_top_	src/thorin/be/c.cpp	/^    std::ostringstream hls_top_;$/;"	m	class:thorin::CCodeGen	file:
hlt	src/thorin/world.cpp	/^const Def* World::hlt(const Def* def, Debug dbg) {$/;"	f	class:thorin::World
hoist_enters	src/thorin/transform/hoist_enters.cpp	/^static void hoist_enters(const Scope& scope) {$/;"	f	namespace:thorin
hoist_enters	src/thorin/transform/hoist_enters.cpp	/^void hoist_enters(World& world) {$/;"	f	namespace:thorin
id_	src/thorin/util/hash.h	/^        int id_;$/;"	m	class:thorin::detail::HashTable::iterator_base
id_	src/thorin/util/hash.h	/^    int id_;$/;"	m	class:thorin::detail::HashTable
idom	src/thorin/analyses/domtree.h	/^    const CFNode* idom(const CFNode* n) const { return idoms_[n]; }$/;"	f	class:thorin::DomTreeBase
idoms_	src/thorin/analyses/domtree.h	/^    typename CFG<forward>::template Map<const CFNode*> idoms_;$/;"	m	class:thorin::DomTreeBase
implicit_option	src/thorin/util/args.h	/^    ImplicitOption implicit_option(std::string domain, std::string help, std::vector<std::string>& target) const {$/;"	f	class:thorin::ArgParser
import	src/thorin/transform/importer.cpp	/^const Def* Importer::import(Tracker odef) {$/;"	f	class:thorin::Importer
import	src/thorin/transform/importer.cpp	/^const Type* Importer::import(const Type* otype) {$/;"	f	class:thorin::Importer
in_scc	src/thorin/analyses/looptree.cpp	/^    bool in_scc(const CFNode* n) { return states_[n] & InSCC; }$/;"	f	class:thorin::LoopTreeBuilder	file:
inc_indent	src/thorin/util/stream.cpp	/^void inc_indent() { indent++; }$/;"	f	namespace:thorin::detail
indefinite_array	src/thorin/world.h	/^    const Def* indefinite_array(const Type* elem, const Def* dim, Debug dbg = {}) {$/;"	f	class:thorin::World
indefinite_array_type	src/thorin/type.h	/^    const IndefiniteArrayType* indefinite_array_type(const Type* elem) { return unify(new IndefiniteArrayType(*this, elem)); }$/;"	f	class:thorin::TypeTable
indent	src/thorin/util/stream.cpp	/^static unsigned int indent = 0;$/;"	m	namespace:thorin::detail	file:
index	src/thorin/analyses/cfg.h	/^    static size_t index(const CFNode* n) { return forward ? n->f_index_ : n->b_index_; }$/;"	f	class:thorin::CFG
index	src/thorin/analyses/domtree.h	/^    size_t index(const CFNode* n) const { return cfg().index(n); }$/;"	f	class:thorin::DomTreeBase
index	src/thorin/analyses/looptree.h	/^        size_t index() const { return index_; }$/;"	f	class:thorin::LoopTree::Leaf
index	src/thorin/analyses/schedule.h	/^        size_t index() const { return index_; }$/;"	f	class:thorin::Schedule::Block
index	src/thorin/analyses/schedule.h	/^    static size_t index(const Block& block) { return block.index(); }$/;"	f	class:thorin::Schedule
index	src/thorin/continuation.h	/^    size_t index() const { return index_; }$/;"	f	class:thorin::Param
index	src/thorin/def.h	/^    size_t index() const { return index_; }$/;"	f	class:thorin::Use
index	src/thorin/def.h	/^    size_t index() const { return uptr_ >> 48ull; }$/;"	f	class:thorin::Use
index	src/thorin/primop.h	/^    const Def* index() const { return op(1); }$/;"	f	class:thorin::AggOp
index	src/thorin/primop.h	/^    const Def* index() const { return op(1); }$/;"	f	class:thorin::LEA
index	src/thorin/util/utility.h	/^    I index() const { return index_; }$/;"	f	class:thorin::TaggedPtr
index	src/thorin/util/utility.h	/^    void index(I index) { index_ = index; }$/;"	f	class:thorin::TaggedPtr
index_	src/thorin/analyses/looptree.cpp	/^    size_t index_;$/;"	m	class:thorin::LoopTreeBuilder	file:
index_	src/thorin/analyses/looptree.h	/^        size_t index_;$/;"	m	class:thorin::LoopTree::Leaf
index_	src/thorin/analyses/schedule.h	/^        size_t index_;$/;"	m	class:thorin::Schedule::Block
index_	src/thorin/continuation.h	/^    const size_t index_;$/;"	m	class:thorin::Param
index_	src/thorin/def.h	/^    size_t index_;$/;"	m	class:thorin::Use
index_	src/thorin/util/utility.h	/^    I index_;$/;"	m	class:thorin::TaggedPtr
indexer	src/thorin/util/indexmap.h	/^    const Indexer& indexer() const { return indexer_; }$/;"	f	class:thorin::IndexMap
indexer	src/thorin/util/indexset.h	/^    const Indexer& indexer() const { return indexer_; }$/;"	f	class:thorin::IndexSet
indexer_	src/thorin/util/indexmap.h	/^    const Indexer& indexer_;$/;"	m	class:thorin::IndexMap
indexer_	src/thorin/util/indexset.h	/^    const Indexer& indexer_;$/;"	m	class:thorin::IndexSet
indices_	src/thorin/analyses/schedule.h	/^    F_CFG::Map<size_t> indices_;$/;"	m	class:thorin::Schedule
info_arch	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_arch	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_language_dialect_default	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^const char* info_language_dialect_default = "INFO" ":" "dialect_default["$/;"	v
info_language_dialect_default	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^const char* info_language_dialect_default = "INFO" ":" "dialect_default["$/;"	v
info_platform	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_platform	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate_version	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const info_simulate_version[] = {$/;"	v
info_simulate_version	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_simulate_version[] = {$/;"	v
info_version	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const info_version[] = {$/;"	v
info_version	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version[] = {$/;"	v
init	src/thorin/primop.h	/^    const Def* init() const { return op(0); }$/;"	f	class:thorin::Global
inline_calls	src/thorin/transform/flatten_tuples.cpp	/^static void inline_calls(Continuation* cont) {$/;"	f	namespace:thorin
inliner	src/thorin/transform/inliner.cpp	/^void inliner(World& world) {$/;"	f	namespace:thorin
inner_order	src/thorin/type.h	/^    int inner_order() const { return inner_order_; }$/;"	f	class:thorin::ClosureType
inner_order_	src/thorin/type.h	/^    int inner_order_;$/;"	m	class:thorin::ClosureType
input	src/thorin/primop.h	/^    const Def* input(size_t i) const { return inputs()[i]; }$/;"	f	class:thorin::Assembly
input_constraints	src/thorin/primop.h	/^    const ArrayRef<std::string> input_constraints() const { return input_constraints_; }$/;"	f	class:thorin::Assembly
input_constraints_	src/thorin/primop.h	/^    Array<std::string> output_constraints_, input_constraints_, clobbers_;$/;"	m	class:thorin::Assembly
inputs	src/thorin/primop.h	/^    Defs inputs() const { return ops().skip_front(); }$/;"	f	class:thorin::Assembly
insert	src/thorin/be/c.cpp	/^void CCodeGen::insert(const Def* def, std::string str) {$/;"	f	class:thorin::CCodeGen
insert	src/thorin/be/c.cpp	/^void CCodeGen::insert(const Type* type, std::string str) {$/;"	f	class:thorin::CCodeGen
insert	src/thorin/util/hash.h	/^    bool insert(I begin, I end) {$/;"	f	class:thorin::detail::HashTable
insert	src/thorin/util/hash.h	/^    std::pair<iterator, bool> insert(const value_type& value) { return emplace(value); }$/;"	f	class:thorin::detail::HashTable
insert	src/thorin/util/hash.h	/^    std::pair<iterator, bool> insert(value_type&& value) { return emplace(std::move(value)); }$/;"	f	class:thorin::detail::HashTable
insert	src/thorin/util/hash.h	/^    void insert(std::initializer_list<value_type> ilist) { insert(ilist.begin(), ilist.end()); }$/;"	f	class:thorin::detail::HashTable
insert	src/thorin/util/indexset.h	/^    bool insert(Key key) { return set<true>(key); } \/\/\/< Inserts \\p key and returns true if successful.$/;"	f	class:thorin::IndexSet
insert	src/thorin/util/symbol.cpp	/^void Symbol::insert(const char* s) {$/;"	f	class:thorin::Symbol
insert	src/thorin/util/type_table.h	/^const Type* TypeTableBase<Type>::insert(const Type* type) {$/;"	f	class:thorin::TypeTableBase
insert	src/thorin/world.cpp	/^const Def* World::insert(const Def* agg, const Def* index, const Def* value, Debug dbg) {$/;"	f	class:thorin::World
insert	src/thorin/world.h	/^    const Def* insert(const Def* tuple, u32 index, const Def* value, Debug dbg = {}) {$/;"	f	class:thorin::World
insert_range	src/thorin/util/hash.h	/^    bool insert_range(const R& range) { return insert(range.begin(), range.end()); }$/;"	f	class:thorin::detail::HashTable
insert_to_slot	src/thorin/transform/resolve_loads.cpp	/^    const Def* insert_to_slot(const Def* ptr, const Def* slot_value, const Def* insert_value, Debug dbg) {$/;"	f	class:thorin::ResolveLoads
instantiate	src/thorin/transform/mangle.cpp	/^const Def* Rewriter::instantiate(const Def* odef) {$/;"	f	class:thorin::Rewriter
instantiate	src/thorin/transform/partial_evaluation.cpp	/^    const Def* instantiate(const Def* odef) {$/;"	f	class:thorin::CondEval
intrinsic	src/thorin/continuation.h	/^    Intrinsic intrinsic() const { return intrinsic_; }$/;"	f	class:thorin::Continuation
intrinsic	src/thorin/continuation.h	/^    Intrinsic& intrinsic() { return intrinsic_; }$/;"	f	class:thorin::Continuation
intrinsic_	src/thorin/continuation.h	/^    Intrinsic intrinsic_;$/;"	m	class:thorin::Continuation
iptr_	src/thorin/def.h	/^        intptr_t iptr_;$/;"	m	union:thorin::Use::__anon10
irbuilder_	src/thorin/be/llvm/llvm.h	/^    llvm::IRBuilder<> irbuilder_;$/;"	m	class:thorin::CodeGen
is_accelerator	src/thorin/continuation.cpp	/^bool Continuation::is_accelerator() const { return Intrinsic::_Accelerator_Begin <= intrinsic_ && intrinsic_ < Intrinsic::_Accelerator_End; }$/;"	f	class:thorin::Continuation
is_agg_const	src/thorin/world.cpp	/^bool is_agg_const(const Def* def) {$/;"	f	namespace:thorin
is_alignstack	src/thorin/primop.h	/^    bool is_alignstack() const { return flags_ & IsAlignStack; }$/;"	f	class:thorin::Assembly
is_allset	src/thorin/def.h	/^inline bool is_allset     (const Def* def) { return is_primlit(def, -1); }$/;"	f	namespace:thorin
is_anonymous	src/thorin/util/symbol.h	/^    bool is_anonymous() { return (*this) == "_"; }$/;"	f	class:thorin::Symbol
is_arithop	src/thorin/enums.h	/^inline bool is_arithop(int tag) { return (int) Begin_ArithOp <= tag && tag < (int) End_ArithOp; }$/;"	f	namespace:thorin
is_associative	src/thorin/def.h	/^inline bool is_associative(const Def* def) { return thorin::is_associative(def->tag()); }$/;"	f	namespace:thorin
is_associative	src/thorin/enums.h	/^inline bool is_associative(int tag) { return tag == ArithOp_add || tag == ArithOp_mul$/;"	f	namespace:thorin
is_basicblock	src/thorin/continuation.cpp	/^bool Continuation::is_basicblock() const { return type()->is_basicblock(); }$/;"	f	class:thorin::Continuation
is_basicblock	src/thorin/type.h	/^    bool is_basicblock() const { return order() == 1; }$/;"	f	class:thorin::FnType
is_bitop	src/thorin/def.h	/^inline bool is_bitop      (const Def* def) { return thorin::is_bitop(def->tag()); }$/;"	f	namespace:thorin
is_bitop	src/thorin/enums.h	/^inline bool is_bitop(int tag) { return  tag == ArithOp_and || tag == ArithOp_or || tag == ArithOp_xor; }$/;"	f	namespace:thorin
is_cmp	src/thorin/enums.h	/^inline bool is_cmp(int tag)     { return (int) Begin_Cmp   <= tag && tag < (int) End_Cmp; }$/;"	f	namespace:thorin
is_commutative	src/thorin/def.h	/^inline bool is_commutative(const Def* def) { return thorin::is_commutative(def->tag()); }$/;"	f	namespace:thorin
is_commutative	src/thorin/enums.h	/^inline bool is_commutative(int tag) { return tag == ArithOp_add  || tag == ArithOp_mul$/;"	f	namespace:thorin
is_const	src/thorin/def.cpp	/^bool is_const(const Def* def) {$/;"	f	namespace:thorin
is_div_or_rem	src/thorin/def.h	/^inline bool is_div_or_rem (const Def* def) { return thorin::is_div_or_rem(def->tag()); }$/;"	f	namespace:thorin
is_div_or_rem	src/thorin/enums.h	/^inline bool is_div_or_rem(int tag) { return tag == ArithOp_div || tag == ArithOp_rem; }$/;"	f	namespace:thorin
is_external	src/thorin/continuation.cpp	/^bool Continuation::is_external() const { return world().is_external(this); }$/;"	f	class:thorin::Continuation
is_external	src/thorin/world.h	/^    bool is_external(const Continuation* continuation) { return externals().contains(const_cast<Continuation*>(continuation)); }$/;"	f	class:thorin::World
is_from_match	src/thorin/primop.cpp	/^bool is_from_match(const PrimOp* primop) {$/;"	f	namespace:thorin
is_graph_intrinsic	src/thorin/transform/closure_conversion.cpp	/^    bool is_graph_intrinsic(const Continuation* cont) {$/;"	f	class:thorin::ClosureConversion
is_graph_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static bool is_graph_type(const Type* type) {$/;"	f	namespace:thorin
is_head	src/thorin/analyses/looptree.cpp	/^    bool is_head(const CFNode* n) { return states_[n] & IsHead; }$/;"	f	class:thorin::LoopTreeBuilder	file:
is_host_device	src/thorin/type.h	/^    bool is_host_device() const { return device_ == -1; }$/;"	f	class:thorin::PtrType
is_inteldialect	src/thorin/primop.h	/^    bool is_inteldialect() const { return flags_ & IsIntelDialect; }$/;"	f	class:thorin::Assembly
is_intrinsic	src/thorin/continuation.cpp	/^bool Continuation::is_intrinsic() const { return intrinsic_ != Intrinsic::None; }$/;"	f	class:thorin::Continuation
is_invalid	src/thorin/util/hash.h	/^    bool is_invalid(size_t i) { return is_invalid(nodes_+i); }$/;"	f	class:thorin::detail::HashTable
is_invalid	src/thorin/util/hash.h	/^    static bool is_invalid(value_type* ptr) { return key(ptr) == H::sentinel(); }$/;"	f	class:thorin::detail::HashTable
is_known	src/thorin/util/type_table.h	/^    bool is_known()   const { return known_; }                \/\/\/< Does this @p Type depend on any @p UnknownType%s?$/;"	f	class:thorin::TypeBase
is_leaf	src/thorin/analyses/looptree.cpp	/^    bool is_leaf(const CFNode* n, size_t num) {$/;"	f	class:thorin::LoopTreeBuilder	file:
is_mem	src/thorin/def.h	/^inline bool is_mem        (const Def* def) { return def->type()->isa<MemType>(); }$/;"	f	namespace:thorin
is_minus	src/thorin/def.h	/^inline bool is_minus      (const Def* def) { return def->tag() == Node_sub && is_minus_zero(def->op(0)); }$/;"	f	namespace:thorin
is_minus_zero	src/thorin/def.cpp	/^bool is_minus_zero(const Def* def) {$/;"	f	namespace:thorin
is_monomorphic	src/thorin/util/type_table.h	/^    bool is_monomorphic() const { return monomorphic_; }      \/\/\/< Does this @p Type not depend on any @p Var%s?.$/;"	f	class:thorin::TypeBase
is_mutable	src/thorin/primop.h	/^    bool is_mutable() const { return is_mutable_; }$/;"	f	class:thorin::Global
is_mutable_	src/thorin/primop.h	/^    bool is_mutable_;$/;"	m	class:thorin::Global
is_neg	src/thorin/util/types.h	/^    bool is_neg() const { return data_ < ST(0); }$/;"	f	class:thorin::SInt
is_neg	src/thorin/util/types.h	/^    bool is_neg() const { return data_ < UT(0u); }$/;"	f	class:thorin::UInt
is_nominal	src/thorin/util/type_table.h	/^    bool is_nominal() const { return nominal_; }              \/\/\/< A nominal @p Type is always different from each other @p Type.$/;"	f	class:thorin::TypeBase
is_not	src/thorin/def.h	/^inline bool is_not        (const Def* def) { return def->tag() == Node_xor && is_allset(def->op(0)); }$/;"	f	namespace:thorin
is_one	src/thorin/def.h	/^inline bool is_one        (const Def* def) { return is_primlit(def, 1); }$/;"	f	namespace:thorin
is_out	src/thorin/primop.h	/^const T* PrimOp::is_out(const Def* def) {$/;"	f	class:thorin::PrimOp
is_out_frame	src/thorin/primop.h	/^    static const Enter* is_out_frame(const Def* def) { return is_out<1, Enter>(def); }$/;"	f	class:thorin::Enter
is_out_mem	src/thorin/primop.h	/^    static const Alloc* is_out_mem(const Def* def) { return is_out<0, Alloc>(def); }$/;"	f	class:thorin::Alloc
is_out_mem	src/thorin/primop.h	/^    static const Enter* is_out_mem(const Def* def) { return is_out<0, Enter>(def); }$/;"	f	class:thorin::Enter
is_out_mem	src/thorin/primop.h	/^    static const Load* is_out_mem(const Def* def) { return is_out<0, Load>(def); }$/;"	f	class:thorin::Load
is_out_ptr	src/thorin/primop.h	/^    static const Alloc* is_out_ptr(const Def* def) { return is_out<1, Alloc>(def); }$/;"	f	class:thorin::Alloc
is_out_val	src/thorin/primop.h	/^    static const Load* is_out_val(const Def* def) { return is_out<1, Load>(def); }$/;"	f	class:thorin::Load
is_param	src/thorin/util/args.h	/^    bool is_param(const char* value) const {$/;"	f	class:thorin::OptionBase
is_param	src/thorin/util/args.h	/^    bool is_param(const char*) const { return true; }$/;"	f	struct:thorin::ImplicitOption
is_param	src/thorin/util/args.h	/^    bool is_param(const char*) const { return true; }$/;"	f	struct:thorin::Option
is_passed_to_accelerator	src/thorin/continuation.cpp	/^bool is_passed_to_accelerator(Continuation* cont, bool include_globals) {$/;"	f	namespace:thorin
is_passed_to_intrinsic	src/thorin/continuation.cpp	/^bool is_passed_to_intrinsic(Continuation* cont, Intrinsic intrinsic, bool include_globals) {$/;"	f	namespace:thorin
is_pe_done	src/thorin/world.h	/^    bool is_pe_done() const { return pe_done_; }$/;"	f	class:thorin::World
is_polymorphic	src/thorin/util/type_table.h	/^    bool is_polymorphic() const { return !is_monomorphic(); } \/\/\/< Does this @p Type depend on any @p Var%s?.$/;"	f	class:thorin::TypeBase
is_power_of_2	src/thorin/util/utility.h	/^constexpr uint64_t is_power_of_2(uint64_t i) { return ((i != 0) && !(i & (i - 1))); }$/;"	f	namespace:thorin
is_primlit	src/thorin/def.cpp	/^bool is_primlit(const Def* def, int64_t val) {$/;"	f	namespace:thorin
is_primtype	src/thorin/enums.h	/^inline bool is_primtype(int tag){ return (int) Begin_PrimType <= tag && tag < (int) End_PrimType; }$/;"	f	namespace:thorin
is_primtype	src/thorin/type.h	/^inline bool is_primtype (const Type* t) { return thorin::is_primtype(t->tag()); }$/;"	f	namespace:thorin
is_replaced	src/thorin/def.h	/^    bool is_replaced() const { return substitute_ != nullptr; }$/;"	f	class:thorin::Def
is_returning	src/thorin/continuation.cpp	/^bool Continuation::is_returning() const { return type()->is_returning(); }$/;"	f	class:thorin::Continuation
is_returning	src/thorin/type.cpp	/^bool FnType::is_returning() const {$/;"	f	class:thorin::FnType
is_root	src/thorin/analyses/looptree.h	/^        bool is_root() const { return Super::parent_ == 0; }$/;"	f	class:thorin::LoopTree::Head
is_safe_bitcast	src/thorin/transform/resolve_loads.cpp	/^    static bool is_safe_bitcast(const Bitcast* bitcast) {$/;"	f	class:thorin::ResolveLoads
is_set	src/thorin/util/location.h	/^    bool is_set() const { return filename_ != nullptr; }$/;"	f	class:thorin::Location
is_shift	src/thorin/def.h	/^inline bool is_shift      (const Def* def) { return thorin::is_shift(def->tag()); }$/;"	f	namespace:thorin
is_shift	src/thorin/enums.h	/^inline bool is_shift(int tag) { return  tag == ArithOp_shl || tag == ArithOp_shr; }$/;"	f	namespace:thorin
is_string_type	src/thorin/be/c.cpp	/^inline bool is_string_type(const Type* type) {$/;"	f	namespace:thorin
is_task_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static bool is_task_type(const Type* type) {$/;"	f	namespace:thorin
is_texture_type	src/thorin/be/c.cpp	/^bool CCodeGen::is_texture_type(const Type* type) {$/;"	f	class:thorin::CCodeGen
is_thin	src/thorin/primop.cpp	/^bool Closure::is_thin() const {$/;"	f	class:thorin::Closure
is_top_level	src/thorin/transform/partial_evaluation.cpp	/^    bool is_top_level(Continuation* continuation) {$/;"	f	class:thorin::CondEval
is_type_bool	src/thorin/type.h	/^inline bool is_type_bool(const Type* t) { return t->tag() == Node_PrimType_bool; }$/;"	f	namespace:thorin
is_type_f	src/thorin/enums.h	/^inline bool is_type_f(int tag) { return is_type_pf(tag) || is_type_qf(tag); }$/;"	f	namespace:thorin
is_type_f	src/thorin/type.h	/^inline bool is_type_f   (const Type* t) { return thorin::is_type_f  (t->tag()); }$/;"	f	namespace:thorin
is_type_i	src/thorin/enums.h	/^inline bool is_type_i(int tag) { return is_type_s (tag) || is_type_u (tag); }$/;"	f	namespace:thorin
is_type_i	src/thorin/type.h	/^inline bool is_type_i   (const Type* t) { return thorin::is_type_i  (t->tag()); }$/;"	f	namespace:thorin
is_type_p	src/thorin/enums.h	/^inline bool is_type_p(int tag) { return is_type_ps(tag) || is_type_pu(tag) || is_type_pf(tag); }$/;"	f	namespace:thorin
is_type_p	src/thorin/type.h	/^inline bool is_type_p   (const Type* t) { return thorin::is_type_p  (t->tag()); }$/;"	f	namespace:thorin
is_type_pf	src/thorin/enums.h	/^inline bool is_type_pf(int tag) { return (int) Begin_PrimType_pf <= tag && tag < (int) End_PrimType_pf; }$/;"	f	namespace:thorin
is_type_pf	src/thorin/type.h	/^inline bool is_type_pf  (const Type* t) { return thorin::is_type_pf (t->tag()); }$/;"	f	namespace:thorin
is_type_ps	src/thorin/enums.h	/^inline bool is_type_ps(int tag) { return (int) Begin_PrimType_ps <= tag && tag < (int) End_PrimType_ps; }$/;"	f	namespace:thorin
is_type_ps	src/thorin/type.h	/^inline bool is_type_ps  (const Type* t) { return thorin::is_type_ps (t->tag()); }$/;"	f	namespace:thorin
is_type_pu	src/thorin/enums.h	/^inline bool is_type_pu(int tag) { return (int) Begin_PrimType_pu <= tag && tag < (int) End_PrimType_pu; }$/;"	f	namespace:thorin
is_type_pu	src/thorin/type.h	/^inline bool is_type_pu  (const Type* t) { return thorin::is_type_pu (t->tag()); }$/;"	f	namespace:thorin
is_type_q	src/thorin/enums.h	/^inline bool is_type_q(int tag) { return is_type_qs(tag) || is_type_qu(tag) || is_type_qf(tag); }$/;"	f	namespace:thorin
is_type_q	src/thorin/type.h	/^inline bool is_type_q   (const Type* t) { return thorin::is_type_q  (t->tag()); }$/;"	f	namespace:thorin
is_type_qf	src/thorin/enums.h	/^inline bool is_type_qf(int tag) { return (int) Begin_PrimType_qf <= tag && tag < (int) End_PrimType_qf; }$/;"	f	namespace:thorin
is_type_qf	src/thorin/type.h	/^inline bool is_type_qf  (const Type* t) { return thorin::is_type_qf (t->tag()); }$/;"	f	namespace:thorin
is_type_qs	src/thorin/enums.h	/^inline bool is_type_qs(int tag) { return (int) Begin_PrimType_qs <= tag && tag < (int) End_PrimType_qs; }$/;"	f	namespace:thorin
is_type_qs	src/thorin/type.h	/^inline bool is_type_qs  (const Type* t) { return thorin::is_type_qs (t->tag()); }$/;"	f	namespace:thorin
is_type_qu	src/thorin/enums.h	/^inline bool is_type_qu(int tag) { return (int) Begin_PrimType_qu <= tag && tag < (int) End_PrimType_qu; }$/;"	f	namespace:thorin
is_type_qu	src/thorin/type.h	/^inline bool is_type_qu  (const Type* t) { return thorin::is_type_qu (t->tag()); }$/;"	f	namespace:thorin
is_type_s	src/thorin/enums.h	/^inline bool is_type_s(int tag) { return is_type_ps(tag) || is_type_qs(tag); }$/;"	f	namespace:thorin
is_type_s	src/thorin/type.h	/^inline bool is_type_s   (const Type* t) { return thorin::is_type_s  (t->tag()); }$/;"	f	namespace:thorin
is_type_u	src/thorin/enums.h	/^inline bool is_type_u(int tag) { return is_type_pu(tag) || is_type_qu(tag); }$/;"	f	namespace:thorin
is_type_u	src/thorin/type.h	/^inline bool is_type_u   (const Type* t) { return thorin::is_type_u  (t->tag()); }$/;"	f	namespace:thorin
is_unit	src/thorin/def.cpp	/^bool is_unit(const Def* def) {$/;"	f	namespace:thorin
is_valid	src/thorin/util/indexmap.h	/^        static bool is_valid(T) { return true; }$/;"	f	struct:thorin::IndexMap::IsValidPred
is_valid	src/thorin/util/indexmap.h	/^        static bool is_valid(T* value) { return value != nullptr; }$/;"	f	struct:thorin::IndexMap::IsValidPred
is_vector	src/thorin/type.h	/^    bool is_vector() const { return length_ != 1; }$/;"	f	class:thorin::VectorType
is_zero	src/thorin/def.h	/^inline bool is_zero       (const Def* def) { return is_primlit(def, 0); }$/;"	f	namespace:thorin
isa	src/thorin/util/cast.h	/^    const To* isa() const { return thorin::dcast<To>(static_cast<const Base*>(this)); }$/;"	f	class:thorin::RuntimeCast
isa	src/thorin/util/cast.h	/^    template<class To> To* isa() { return thorin::dcast<To>(static_cast<Base*>(this)); }$/;"	f	class:thorin::RuntimeCast
isa_continuation	src/thorin/def.cpp	/^Continuation* Def::isa_continuation() const { return const_cast<Continuation*>(dcast<Continuation>(this)); }$/;"	f	class:thorin::Def
isatty	src/thorin/util/log.cpp	7;"	d	file:
iterator	src/thorin/util/args.h	/^    typedef ArgsIterator iterator;$/;"	t	class:thorin::BasicOption
iterator	src/thorin/util/array.h	/^    typedef T* iterator;$/;"	t	class:thorin::Array
iterator	src/thorin/util/hash.h	/^    typedef iterator_base<false> iterator;$/;"	t	class:thorin::detail::HashTable
iterator	src/thorin/util/hash.h	/^    typedef typename Super::iterator iterator;$/;"	t	class:thorin::HashMap
iterator	src/thorin/util/hash.h	/^    typedef typename Super::iterator iterator;$/;"	t	class:thorin::HashSet
iterator	src/thorin/util/iterator.h	/^    I iterator() const { return iterator_; }$/;"	f	class:thorin::filter_iterator
iterator	src/thorin/util/iterator.h	/^    I iterator() const { return iterator_; }$/;"	f	class:thorin::map_iterator
iterator_	src/thorin/util/iterator.h	/^    I iterator_;$/;"	m	class:thorin::filter_iterator
iterator_	src/thorin/util/iterator.h	/^    I iterator_;$/;"	m	class:thorin::map_iterator
iterator_base	src/thorin/util/hash.h	/^        iterator_base(const iterator_base<false>& i)$/;"	f	class:thorin::detail::HashTable::iterator_base
iterator_base	src/thorin/util/hash.h	/^        iterator_base(value_type* ptr, const HashTable* table)$/;"	f	class:thorin::detail::HashTable::iterator_base
iterator_base	src/thorin/util/hash.h	/^    class iterator_base {$/;"	c	class:thorin::detail::HashTable
iterator_category	src/thorin/util/hash.h	/^        typedef std::forward_iterator_tag iterator_category;$/;"	t	class:thorin::detail::HashTable::iterator_base
iterator_category	src/thorin/util/iterator.h	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:thorin::filter_iterator
iterator_category	src/thorin/util/iterator.h	/^    typedef std::forward_iterator_tag iterator_category;$/;"	t	class:thorin::map_iterator
jump	src/thorin/continuation.cpp	/^void Continuation::jump(const Def* callee, Defs args, Debug dbg) {$/;"	f	class:thorin::Continuation
jump	src/thorin/transform/flatten_tuples.cpp	/^static Continuation* jump(Continuation* cont, Array<const Def*>& args) {$/;"	f	namespace:thorin
jump_debug	src/thorin/continuation.h	/^    Debug& jump_debug() const { return jump_debug_; }$/;"	f	class:thorin::Continuation
jump_debug_	src/thorin/continuation.h	/^    mutable Debug jump_debug_;$/;"	m	class:thorin::Continuation
jump_location	src/thorin/continuation.h	/^    Location jump_location() const { return jump_debug(); }$/;"	f	class:thorin::Continuation
jump_name	src/thorin/continuation.h	/^    Symbol jump_name() const { return jump_debug().name(); }$/;"	f	class:thorin::Continuation
jump_to_dropped_call	src/thorin/continuation.cpp	/^void jump_to_dropped_call(Continuation* src, Continuation* dst, const Call& call) {$/;"	f	namespace:thorin
kernel_calling_convention_	src/thorin/be/llvm/llvm.h	/^    llvm::CallingConv::ID kernel_calling_convention_;$/;"	m	class:thorin::CodeGen
kernel_config	src/thorin/be/llvm/llvm.h	/^    Cont2Config kernel_config;$/;"	m	struct:thorin::Backends
kernel_config_	src/thorin/be/c.cpp	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::CCodeGen	file:
kernel_config_	src/thorin/be/llvm/amdgpu.h	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::AMDGPUCodeGen
kernel_config_	src/thorin/be/llvm/cuda.h	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::CUDACodeGen
kernel_config_	src/thorin/be/llvm/hls.h	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::HLSCodeGen
kernel_config_	src/thorin/be/llvm/nvvm.h	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::NVVMCodeGen
kernel_config_	src/thorin/be/llvm/opencl.h	/^    const Cont2Config& kernel_config_;$/;"	m	class:thorin::OpenCLCodeGen
kernels	src/thorin/be/llvm/llvm.h	/^    std::vector<Continuation*> kernels;$/;"	m	struct:thorin::Backends
key	src/thorin/util/hash.h	/^    static key_type& key(value_type* ptr) { return get_key<Key, T>::get(*ptr); }$/;"	f	class:thorin::detail::HashTable
key_type	src/thorin/util/hash.h	/^    typedef Key key_type;$/;"	t	class:thorin::detail::HashTable
key_type	src/thorin/util/hash.h	/^    typedef typename Super::key_type key_type;$/;"	t	class:thorin::HashMap
key_type	src/thorin/util/hash.h	/^    typedef typename Super::key_type key_type;$/;"	t	class:thorin::HashSet
known	src/thorin/world.cpp	/^const Def* World::known(const Def* def, Debug dbg) {$/;"	f	class:thorin::World
known_	src/thorin/util/type_table.h	/^    mutable bool known_       = true;$/;"	m	class:thorin::TypeBase
lambda	src/thorin/type.h	/^    const Lambda* lambda(const Type* body, const char* name) { return unify(new Lambda(*this, body, name)); }$/;"	f	class:thorin::TypeTable
lang_	src/thorin/be/c.cpp	/^    Lang lang_;$/;"	m	class:thorin::CCodeGen	file:
launch_kernel	src/thorin/be/llvm/runtime.cpp	/^llvm::Value* Runtime::launch_kernel(llvm::Value* device,$/;"	f	class:thorin::Runtime
layout_	src/thorin/be/llvm/runtime.h	/^    const llvm::DataLayout& layout_;$/;"	m	class:thorin::Runtime
lazy_init	src/thorin/util/utility.h	/^inline T& lazy_init(const This* self, std::unique_ptr<T>& ptr) {$/;"	f	namespace:thorin
lca	src/thorin/analyses/domtree.cpp	/^const CFNode* DomTreeBase<forward>::lca(const CFNode* i, const CFNode* j) const {$/;"	f	class:thorin::DomTreeBase
lea	src/thorin/world.cpp	/^const Def* World::lea(const Def* ptr, const Def* index, Debug dbg) {$/;"	f	class:thorin::World
leaves_	src/thorin/analyses/looptree.h	/^    typename CFG<forward>::template Map<Leaf*> leaves_;$/;"	m	class:thorin::LoopTree
length	src/thorin/type.h	/^    size_t length() const { return length_; }$/;"	f	class:thorin::VectorType
length_	src/thorin/type.h	/^    size_t length_;$/;"	m	class:thorin::VectorType
level2color	src/thorin/util/log.cpp	/^int Log::level2color(Level level) {$/;"	f	class:thorin::Log
level2string	src/thorin/util/log.cpp	/^std::string Log::level2string(Level level) {$/;"	f	class:thorin::Log
lhs	src/thorin/primop.h	/^    const Def* lhs() const { return op(0); }$/;"	f	class:thorin::BinOp
lift	src/thorin/transform/mangle.h	/^inline Continuation* lift(const Scope& scope, Defs defs) {$/;"	f	namespace:thorin
lift_	src/thorin/transform/mangle.h	/^    Defs lift_;$/;"	m	class:thorin::Mangler
lift_builtins	src/thorin/transform/lift_builtins.cpp	/^void lift_builtins(World& world) {$/;"	f	namespace:thorin
lift_pipeline	src/thorin/transform/lift_builtins.cpp	/^void lift_pipeline(World& world) {$/;"	f	namespace:thorin
link	src/thorin/analyses/cfg.cpp	/^void CFNode::link(const CFNode* other) const {$/;"	f	class:thorin::CFNode
link	src/thorin/analyses/domfrontier.h	/^    void link(const CFNode* src, const CFNode* dst) {$/;"	f	class:thorin::DomFrontierBase
link_to_exit	src/thorin/analyses/cfg.cpp	/^void CFA::link_to_exit() {$/;"	f	class:thorin::CFA
list	src/thorin/util/stream.h	/^    const List& list;$/;"	m	class:thorin::StreamList
literal	src/thorin/world.h	/^    const Def* literal(PrimTypeTag tag, Box box, Debug dbg, size_t length = 1) { return splat(cse(new PrimLit(*this, tag, box, dbg)), length); }$/;"	f	class:thorin::World
literal	src/thorin/world.h	/^    const Def* literal(T value, Debug dbg = {}, size_t length = 1) { return literal(type2tag<T>::tag, Box(value), dbg, length); }$/;"	f	class:thorin::World
llvm_ref	src/thorin/be/llvm/llvm.h	/^llvm::ArrayRef<T> llvm_ref(const Array<T>& array) { return llvm::ArrayRef<T>(array.begin(), array.end()); }$/;"	f	namespace:thorin
load	src/thorin/world.cpp	/^const Def* World::load(const Def* mem, const Def* ptr, Debug dbg) {$/;"	f	class:thorin::World
location	src/thorin/def.h	/^    Location location() const { return debug_; }$/;"	f	class:thorin::Def
location	src/thorin/util/location.h	/^    Location location() { return *this; }$/;"	f	class:thorin::Debug
log	src/thorin/util/log.h	/^    static void log(Level level, Location location, const char* fmt, Args... args) {$/;"	f	class:thorin::Log
log2	src/thorin/util/utility.h	/^constexpr uint64_t log2(uint64_t n, uint64_t p = 0) { return (n <= 1_u64) ? p : log2(n \/ 2_u64, p + 1_u64); }$/;"	f	namespace:thorin
lookup	src/thorin/be/c.cpp	/^bool CCodeGen::lookup(const Def* def) {$/;"	f	class:thorin::CCodeGen
lookup	src/thorin/be/c.cpp	/^bool CCodeGen::lookup(const Type* type) {$/;"	f	class:thorin::CCodeGen
lookup	src/thorin/be/llvm/llvm.cpp	/^llvm::Value* CodeGen::lookup(const Def* def) {$/;"	f	class:thorin::CodeGen
looptree	src/thorin/analyses/cfg.cpp	/^template<bool forward> const LoopTree<forward>& CFG<forward>::looptree() const { return lazy_init(this, looptree_); }$/;"	f	class:thorin::CFG
looptree_	src/thorin/analyses/cfg.h	/^    mutable std::unique_ptr<const LoopTree<forward>> looptree_;$/;"	m	class:thorin::CFG
looptree_	src/thorin/analyses/looptree.cpp	/^    LoopTree<forward>& looptree_;$/;"	m	class:thorin::LoopTreeBuilder	file:
looptree_	src/thorin/analyses/schedule.cpp	/^    const LoopTree<true>& looptree_;$/;"	m	class:thorin::Scheduler	file:
low	src/thorin/analyses/looptree.cpp	/^        size_t low; \/\/ low link (see Tarjan's SCC algo)$/;"	m	struct:thorin::LoopTreeBuilder::Number	file:
lower2cff_	src/thorin/transform/partial_evaluation.cpp	/^    bool lower2cff_;$/;"	m	class:thorin::PartialEvaluator	file:
lowlink	src/thorin/analyses/looptree.cpp	/^    size_t& lowlink(const CFNode* n) { return number(n).low; }$/;"	f	class:thorin::LoopTreeBuilder	file:
machine_	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<llvm::TargetMachine> machine_;$/;"	m	class:thorin::CodeGen
main	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^int main(int argc, char* argv[])$/;"	f
main	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^void main() {}$/;"	f
main	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^int main(int argc, char* argv[])$/;"	f
main	build/CMakeFiles/feature_tests.c	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
main	build/CMakeFiles/feature_tests.cxx	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
make_array	src/thorin/util/array.h	/^Array<typename T::value_type> make_array(const T& container) {$/;"	f	namespace:thorin
make_external	src/thorin/continuation.cpp	/^void Continuation::make_external() { return world().add_external(this); }$/;"	f	class:thorin::Continuation
make_filter	src/thorin/util/iterator.h	/^filter_iterator<I, P> make_filter(I begin, I end, P pred) { return filter_iterator<I, P>(begin, end, pred); }$/;"	f	namespace:thorin
make_internal	src/thorin/continuation.cpp	/^void Continuation::make_internal() { return world().remove_external(this); }$/;"	f	class:thorin::Continuation
mangle	src/thorin/transform/mangle.cpp	/^Continuation* Mangler::mangle() {$/;"	f	class:thorin::Mangler
mangle	src/thorin/transform/mangle.cpp	/^Continuation* mangle(const Scope& scope, Defs args, Defs lift) {$/;"	f	namespace:thorin
mangle	src/thorin/transform/mangle.cpp	/^const Def* Mangler::mangle(const Def* old_def) {$/;"	f	class:thorin::Mangler
mangle_body	src/thorin/transform/mangle.cpp	/^void Mangler::mangle_body(Continuation* old_continuation, Continuation* new_continuation) {$/;"	f	class:thorin::Mangler
mangle_head	src/thorin/transform/mangle.cpp	/^Continuation* Mangler::mangle_head(Continuation* old_continuation) {$/;"	f	class:thorin::Mangler
map	src/thorin/util/symbol.h	/^        HashSet<const char*, StrHash> map;$/;"	m	struct:thorin::Symbol::Table
map_iterator	src/thorin/util/iterator.h	/^    map_iterator(I iterator, I end, F function)$/;"	f	class:thorin::map_iterator
map_iterator	src/thorin/util/iterator.h	/^    map_iterator(const map_iterator& other)$/;"	f	class:thorin::map_iterator
map_iterator	src/thorin/util/iterator.h	/^    map_iterator(map_iterator&& other)$/;"	f	class:thorin::map_iterator
map_iterator	src/thorin/util/iterator.h	/^class map_iterator {$/;"	c	namespace:thorin
map_param	src/thorin/be/llvm/llvm.h	/^    virtual llvm::Value* map_param(llvm::Function*, llvm::Argument* a, const Param*) { return a; }$/;"	f	class:thorin::CodeGen
map_param	src/thorin/be/llvm/nvvm.cpp	/^llvm::Value* NVVMCodeGen::map_param(llvm::Function*, llvm::Argument* arg, const Param* param) {$/;"	f	class:thorin::NVVMCodeGen
mapped_type	src/thorin/util/hash.h	/^    typedef typename Super::mapped_type mapped_type;$/;"	t	class:thorin::HashMap
mapped_type	src/thorin/util/hash.h	/^    typedef typename Super::mapped_type mapped_type;$/;"	t	class:thorin::HashSet
mapped_type	src/thorin/util/hash.h	/^    typedef typename std::conditional<std::is_void<T>::value, Key, T>::type mapped_type;$/;"	t	class:thorin::detail::HashTable
mark_pe_done	src/thorin/world.h	/^    void mark_pe_done(bool flag = true) { pe_done_ = flag; }$/;"	f	class:thorin::World
match	src/thorin/continuation.cpp	/^void Continuation::match(const Def* val, Continuation* otherwise, Defs patterns, ArrayRef<Continuation*> continuations, Debug dbg) {$/;"	f	class:thorin::Continuation
match	src/thorin/world.cpp	/^Continuation* World::match(const Type* type, size_t num_patterns) {$/;"	f	class:thorin::World
mem	src/thorin/primop.h	/^    const Def* mem() const { return op(0); }$/;"	f	class:thorin::MemOp
mem_	src/thorin/type.h	/^    const MemType* mem_;$/;"	m	class:thorin::TypeTable
mem_param	src/thorin/continuation.cpp	/^const Param* Continuation::mem_param() const {$/;"	f	class:thorin::Continuation
mem_type	src/thorin/type.h	/^    const MemType* mem_type() const { return mem_; }$/;"	f	class:thorin::TypeTable
metadata_	src/thorin/be/llvm/nvvm.h	/^    ParamMap<llvm::MDNode*> metadata_;$/;"	m	class:thorin::NVVMCodeGen
min_level	src/thorin/util/log.cpp	/^Log::Level Log::min_level() { return min_level_; }$/;"	f	class:thorin::Log
min_level_	src/thorin/util/log.cpp	/^Log::Level Log::min_level_ = Log::Error;$/;"	m	class:thorin::Log	file:
min_level_	src/thorin/util/log.h	/^    static Level min_level_;$/;"	m	class:thorin::Log
minus	src/thorin/util/types.h	/^    SInt minus() const { return SInt(~UT(data_)+UT(1u)); }$/;"	f	class:thorin::SInt
minus	src/thorin/util/types.h	/^    UInt minus() const { return UInt(~UT(data_)+UT(1u)); }$/;"	f	class:thorin::UInt
mod	src/thorin/util/hash.h	/^    size_t mod(size_t i) const { return i & (capacity_-1); }$/;"	f	class:thorin::detail::HashTable
module_	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<llvm::Module> module_;$/;"	m	class:thorin::CodeGen
monomorphic_	src/thorin/util/type_table.h	/^    mutable bool monomorphic_ = true;$/;"	m	class:thorin::TypeBase
murmur3	src/thorin/util/hash.h	/^inline uint64_t murmur3(uint64_t h) {$/;"	f	namespace:thorin
name	src/thorin/def.h	/^    Symbol name() const { return debug().name(); }$/;"	f	class:thorin::Def
name	src/thorin/type.h	/^    Symbol name() const { return name_; }$/;"	f	class:thorin::StructType
name	src/thorin/type.h	/^    const char* name() const { return name_; }$/;"	f	class:thorin::Lambda
name	src/thorin/util/location.h	/^    Symbol name() const { return name_; }$/;"	f	class:thorin::Debug
name	src/thorin/util/ycomp.h	/^    const char* name() const { return name_; }$/;"	f	class:thorin::YComp
name	src/thorin/world.h	/^    const std::string& name() const { return name_; }$/;"	f	class:thorin::World
name_	src/thorin/type.h	/^    Symbol name_;$/;"	m	class:thorin::StructType
name_	src/thorin/type.h	/^    const char* name_;$/;"	m	class:thorin::Lambda
name_	src/thorin/util/location.h	/^    Symbol name_;$/;"	m	class:thorin::Debug
name_	src/thorin/util/ycomp.h	/^    const char* name_;$/;"	m	class:thorin::YComp
name_	src/thorin/world.h	/^    std::string name_;$/;"	m	class:thorin::World
negate	src/thorin/enums.cpp	/^CmpTag negate(CmpTag tag) {$/;"	f	namespace:thorin
new_defs_	src/thorin/transform/closure_conversion.cpp	/^    Def2Def new_defs_;$/;"	m	class:thorin::ClosureConversion	file:
new_entry	src/thorin/transform/mangle.h	/^    Continuation* new_entry() const { return new_entry_; }$/;"	f	class:thorin::Mangler
new_entry_	src/thorin/transform/mangle.h	/^    Continuation* new_entry_;$/;"	m	class:thorin::Mangler
new_types_	src/thorin/transform/closure_conversion.cpp	/^    Type2Type new_types_;$/;"	m	class:thorin::ClosureConversion	file:
next	src/thorin/util/indexset.h	/^    size_t next(size_t pos = 0) {$/;"	f	class:thorin::IndexSet
node	src/thorin/analyses/cfg.cpp	/^const CFNode* CFA::node(Continuation* continuation) {$/;"	f	class:thorin::CFA
node	src/thorin/analyses/schedule.h	/^        const CFNode* node() const { return node_; }$/;"	f	class:thorin::Schedule::Block
node_	src/thorin/analyses/schedule.h	/^        const CFNode* node_;$/;"	m	class:thorin::Schedule::Block
nodes	src/thorin/analyses/cfg.h	/^    const ContinuationMap<const CFNode*>& nodes() const { return nodes_; }$/;"	f	class:thorin::CFA
nodes_	src/thorin/analyses/cfg.h	/^    ContinuationMap<const CFNode*> nodes_;$/;"	m	class:thorin::CFA
nodes_	src/thorin/util/hash.h	/^    value_type* nodes_;$/;"	m	class:thorin::detail::HashTable
nominal_	src/thorin/util/type_table.h	/^    mutable bool nominal_     = false;$/;"	m	class:thorin::TypeBase
num_args	src/thorin/continuation.h	/^    size_t num_args() const { return args().size(); }$/;"	f	class:thorin::Continuation
num_args	src/thorin/continuation.h	/^    size_t num_args() const { return args().size(); }$/;"	f	struct:thorin::Call
num_bits	src/thorin/enums.cpp	/^int num_bits(PrimTypeTag tag) {$/;"	f	namespace:thorin
num_cf_nodes	src/thorin/analyses/looptree.h	/^        size_t num_cf_nodes() const { return cf_nodes().size(); }$/;"	f	class:thorin::LoopTree::Node
num_children	src/thorin/analyses/looptree.h	/^        size_t num_children() const { return children().size(); }$/;"	f	class:thorin::LoopTree::Head
num_inputs	src/thorin/primop.h	/^    size_t num_inputs() const { return inputs().size(); }$/;"	f	class:thorin::Assembly
num_ops	src/thorin/continuation.h	/^    size_t num_ops() const { return ops().size(); }$/;"	f	struct:thorin::Call
num_ops	src/thorin/def.h	/^    size_t num_ops() const { return ops_.size(); }$/;"	f	class:thorin::Def
num_ops	src/thorin/util/type_table.h	/^    size_t num_ops() const { return ops_.size(); }$/;"	f	class:thorin::TypeBase
num_params	src/thorin/continuation.h	/^    size_t num_params() const { return params().size(); }$/;"	f	class:thorin::Continuation
num_preds	src/thorin/analyses/cfg.h	/^    size_t num_preds(Continuation* continuation) const { return num_preds(cfa()[continuation]); }$/;"	f	class:thorin::CFG
num_preds	src/thorin/analyses/cfg.h	/^    size_t num_preds(const CFNode* n) const { return preds(n).size(); }$/;"	f	class:thorin::CFG
num_succs	src/thorin/analyses/cfg.h	/^    size_t num_succs(Continuation* continuation) const { return num_succs(cfa()[continuation]); }$/;"	f	class:thorin::CFG
num_succs	src/thorin/analyses/cfg.h	/^    size_t num_succs(const CFNode* n) const { return succs(n).size(); }$/;"	f	class:thorin::CFG
num_uses	src/thorin/def.h	/^    size_t num_uses() const { return uses().size(); }$/;"	f	class:thorin::Def
number	src/thorin/analyses/looptree.cpp	/^    Number& number(const CFNode* n) { return numbers_[n]; }$/;"	f	class:thorin::LoopTreeBuilder	file:
numbers_	src/thorin/analyses/looptree.cpp	/^    typename CFG<forward>::template Map<Number> numbers_;$/;"	m	class:thorin::LoopTreeBuilder	file:
nvvm	src/thorin/be/llvm/llvm.h	/^    Importer nvvm;$/;"	m	struct:thorin::Backends
nvvm_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> nvvm_cg;$/;"	m	struct:thorin::Backends
of	src/thorin/primop.h	/^    const Type* of() const { return op(0)->type(); }$/;"	f	class:thorin::SizeOf
offset	src/thorin/util/hash.h	/^    static const uint64_t offset = 14695981039346656037_u64;$/;"	m	struct:thorin::FNV1
old2new	src/thorin/transform/mangle.h	/^    Def2Def old2new;$/;"	m	struct:thorin::Rewriter
old2new_	src/thorin/transform/partial_evaluation.cpp	/^    Def2Def old2new_;$/;"	m	class:thorin::CondEval	file:
old_	src/thorin/util/utility.h	/^    T old_;$/;"	m	struct:thorin::Push
old_entry	src/thorin/transform/mangle.h	/^    Continuation* old_entry() const { return old_entry_; }$/;"	f	class:thorin::Mangler
old_entry_	src/thorin/transform/mangle.h	/^    Continuation* old_entry_;$/;"	m	class:thorin::Mangler
on_heap	src/thorin/util/hash.h	/^    bool on_heap() const { return capacity_ != StackCapacity; }$/;"	f	class:thorin::detail::HashTable
on_stack	src/thorin/analyses/looptree.cpp	/^    bool on_stack(const CFNode* n) { assert(set_.contains(n)); return (states_[n] & OnStack) != 0; }$/;"	f	class:thorin::LoopTreeBuilder	file:
one	src/thorin/world.h	/^    const Def* one(PrimTypeTag tag, Debug dbg = {}, size_t length = 1) { return literal(tag, 1, dbg, length); }$/;"	f	class:thorin::World
one	src/thorin/world.h	/^    const Def* one(const Type* type, Debug dbg = {}, size_t length = 1) { return one(type->as<PrimType>()->primtype_tag(), dbg, length); }$/;"	f	class:thorin::World
op	src/thorin/continuation.h	/^    const Def* op(size_t i) const { return ops_[i]; }$/;"	f	struct:thorin::Call
op	src/thorin/def.h	/^    const Def* op(size_t i) const { assert(i < ops().size() && "index out of bounds"); return ops_[i]; }$/;"	f	class:thorin::Def
op	src/thorin/util/type_table.h	/^    const TypeBase* op(size_t i) const { return ops()[i]; }$/;"	f	class:thorin::TypeBase
op_name	src/thorin/primop.cpp	/^const char* ArithOp::op_name() const {$/;"	f	class:thorin::ArithOp
op_name	src/thorin/primop.cpp	/^const char* Cmp::op_name() const {$/;"	f	class:thorin::Cmp
op_name	src/thorin/primop.cpp	/^const char* Global::op_name() const { return is_mutable() ? "global_mutable" : "global_immutable"; }$/;"	f	class:thorin::Global
op_name	src/thorin/primop.cpp	/^const char* PrimOp::op_name() const {$/;"	f	class:thorin::PrimOp
opencl	src/thorin/be/llvm/llvm.h	/^    Importer opencl;$/;"	m	struct:thorin::Backends
opencl_cg	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<CodeGen> opencl_cg;$/;"	m	struct:thorin::Backends
operator !=	src/thorin/util/args.h	/^    bool operator!=(ArgsIterator b) const { return pos_ != b.pos_; }$/;"	f	class:thorin::ArgsIterator
operator !=	src/thorin/util/hash.h	/^        bool operator!=(const iterator_base& other) { verify(other); return this->ptr_ != other.ptr_; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator !=	src/thorin/util/iterator.h	/^    bool operator!=(const filter_iterator& other) { return this->iterator_ != other.iterator_; }$/;"	f	class:thorin::filter_iterator
operator !=	src/thorin/util/iterator.h	/^    bool operator!=(const map_iterator& other) { return this->iterator_ != other.iterator_; }$/;"	f	class:thorin::map_iterator
operator !=	src/thorin/util/symbol.h	/^    bool operator!=(Symbol symbol) const { return c_str() != symbol.c_str(); }$/;"	f	class:thorin::Symbol
operator !=	src/thorin/util/symbol.h	/^    bool operator!=(const char* s) const { return c_str() != Symbol(s).c_str(); }$/;"	f	class:thorin::Symbol
operator !=	src/thorin/util/types.h	/^    bool  operator!=(Float other) const { return this->data_ !=other.data_; }$/;"	f	class:thorin::Float
operator !=	src/thorin/util/types.h	/^    bool operator!=(SInt other) const { return this->data_ !=other.data_; }$/;"	f	class:thorin::SInt
operator !=	src/thorin/util/types.h	/^    bool operator!=(UInt other) const { return this->data_ !=other.data_; }$/;"	f	class:thorin::UInt
operator %	src/thorin/util/types.h	/^    Float operator% (Float other) const { return Float(rem(this->data_, other.data_)); }$/;"	f	class:thorin::Float
operator %	src/thorin/util/types.h	/^    SInt operator%(SInt other) const { div_check(other); return SInt(this->data_ % other.data_); }$/;"	f	class:thorin::SInt
operator %	src/thorin/util/types.h	/^    UInt operator%(UInt other) const { div_check(other); return UInt(this->data_ % other.data_); }$/;"	f	class:thorin::UInt
operator &	src/thorin/primop.h	/^inline Assembly::Flags operator&(Assembly::Flags lhs, Assembly::Flags rhs) { return static_cast<Assembly::Flags>(static_cast<int>(lhs) & static_cast<int>(rhs)); }$/;"	f	namespace:thorin
operator &	src/thorin/util/types.h	/^    SInt operator& (SInt other) const { return this->data_ & other.data_; }$/;"	f	class:thorin::SInt
operator &	src/thorin/util/types.h	/^    UInt operator& (UInt other) const { return this->data_ & other.data_; }$/;"	f	class:thorin::UInt
operator &=	src/thorin/primop.h	/^inline Assembly::Flags operator&=(Assembly::Flags& lhs, Assembly::Flags rhs) { return lhs = lhs & rhs; }$/;"	f	namespace:thorin
operator &=	src/thorin/util/indexset.h	/^    IndexSet& operator&=(const IndexSet& other) { return transform(other, std::bit_and<uint64_t>()); }$/;"	f	class:thorin::IndexSet
operator ()	src/thorin/util/type_table.h	/^    bool operator()(T a, T b) const { return a->gid() < b->gid(); }$/;"	f	struct:thorin::GIDLt
operator *	src/thorin/util/args.h	/^    const char* operator*() const { return argv_[pos_]; }$/;"	f	class:thorin::ArgsIterator
operator *	src/thorin/util/hash.h	/^        reference operator*() const { verify(); return *ptr_; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator *	src/thorin/util/iterator.h	/^    reference operator*() const { return (reference) *iterator_; }$/;"	f	class:thorin::filter_iterator
operator *	src/thorin/util/iterator.h	/^    value_type operator*() const { return function_(*iterator_); }$/;"	f	class:thorin::map_iterator
operator *	src/thorin/util/types.h	/^    Float operator* (Float other) const { return Float(this->data_ * other.data_); }$/;"	f	class:thorin::Float
operator *	src/thorin/util/types.h	/^    SInt operator*(SInt other) const {$/;"	f	class:thorin::SInt
operator *	src/thorin/util/types.h	/^    UInt operator*(UInt other) const {$/;"	f	class:thorin::UInt
operator +	src/thorin/util/location.cpp	/^Debug operator+(Debug d1, Debug d2) {$/;"	f	namespace:thorin
operator +	src/thorin/util/location.cpp	/^Location operator+(Location l1, Location l2) {$/;"	f	namespace:thorin
operator +	src/thorin/util/location.h	/^inline Debug operator+(Debug dbg, Symbol s)             { return {dbg, dbg.name() + s}; }$/;"	f	namespace:thorin
operator +	src/thorin/util/location.h	/^inline Debug operator+(Debug dbg, const char* s)        { return {dbg, dbg.name() + s}; }$/;"	f	namespace:thorin
operator +	src/thorin/util/location.h	/^inline Debug operator+(Debug dbg, const std::string& s) { return {dbg, dbg.name() + s}; }$/;"	f	namespace:thorin
operator +	src/thorin/util/symbol.h	/^inline Symbol operator+(Symbol s1, Symbol s2) { return std::string(s1.c_str()) + s2.str(); }$/;"	f	namespace:thorin
operator +	src/thorin/util/symbol.h	/^inline Symbol operator+(Symbol s1, const char* s2) { return std::string(s1.c_str()) + s2; }$/;"	f	namespace:thorin
operator +	src/thorin/util/symbol.h	/^inline Symbol operator+(Symbol s1, std::string s2) { return std::string(s1.c_str()) + s2; }$/;"	f	namespace:thorin
operator +	src/thorin/util/types.h	/^    Float operator+ (Float other) const { return Float(this->data_ + other.data_); }$/;"	f	class:thorin::Float
operator +	src/thorin/util/types.h	/^    SInt operator+(SInt other) const {$/;"	f	class:thorin::SInt
operator +	src/thorin/util/types.h	/^    UInt operator+(UInt other) const {$/;"	f	class:thorin::UInt
operator ++	src/thorin/util/args.h	/^    ArgsIterator operator++(int) { ArgsIterator tmp(pos_, argv_); ++pos_; return tmp; }$/;"	f	class:thorin::ArgsIterator
operator ++	src/thorin/util/args.h	/^    ArgsIterator& operator++() { ++pos_; return *this; }$/;"	f	class:thorin::ArgsIterator
operator ++	src/thorin/util/hash.h	/^        iterator_base operator++(int) { verify(); iterator_base res = *this; ++(*this); return res; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator ++	src/thorin/util/hash.h	/^        iterator_base& operator++() { verify(); *this = skip(ptr_+1, table_); return *this; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator ++	src/thorin/util/iterator.h	/^    filter_iterator operator++(int) { filter_iterator res = *this; ++(*this); return res; }$/;"	f	class:thorin::filter_iterator
operator ++	src/thorin/util/iterator.h	/^    filter_iterator& operator++() {$/;"	f	class:thorin::filter_iterator
operator ++	src/thorin/util/iterator.h	/^    map_iterator operator++(int) { map_iterator res = *this; ++(*this); return res; }$/;"	f	class:thorin::map_iterator
operator ++	src/thorin/util/iterator.h	/^    map_iterator& operator++() {$/;"	f	class:thorin::map_iterator
operator -	src/thorin/util/types.h	/^    Float operator- () const { return -data_; }$/;"	f	class:thorin::Float
operator -	src/thorin/util/types.h	/^    Float operator- (Float other) const { return Float(this->data_ - other.data_); }$/;"	f	class:thorin::Float
operator -	src/thorin/util/types.h	/^    SInt operator-() const {$/;"	f	class:thorin::SInt
operator -	src/thorin/util/types.h	/^    SInt operator-(SInt other) const { return *this + SInt(other.minus()); }$/;"	f	class:thorin::SInt
operator -	src/thorin/util/types.h	/^    UInt operator-() const { return UInt(0u) - *this; }$/;"	f	class:thorin::UInt
operator -	src/thorin/util/types.h	/^    UInt operator-(UInt other) const {$/;"	f	class:thorin::UInt
operator ->	src/thorin/def.h	/^    const Def* operator->() const { return def(); }$/;"	f	class:thorin::Use
operator ->	src/thorin/def.h	/^    const Def* operator->() { return def(); }$/;"	f	class:thorin::Tracker
operator ->	src/thorin/util/hash.h	/^        pointer operator->() const { verify(); return ptr_; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator ->	src/thorin/util/iterator.h	/^    pointer operator->() const { return (pointer) &*iterator_; }$/;"	f	class:thorin::filter_iterator
operator ->	src/thorin/util/iterator.h	/^    pointer operator->() const { return (pointer) &function_(*iterator_); }$/;"	f	class:thorin::map_iterator
operator ->	src/thorin/util/utility.h	/^    T* operator->() const { return ptr(); }$/;"	f	class:thorin::TaggedPtr
operator /	src/thorin/util/types.h	/^    Float operator\/ (Float other) const { return Float(this->data_ \/ other.data_); }$/;"	f	class:thorin::Float
operator /	src/thorin/util/types.h	/^    SInt operator\/(SInt other) const { div_check(other); return SInt(this->data_ \/ other.data_); }$/;"	f	class:thorin::SInt
operator /	src/thorin/util/types.h	/^    UInt operator\/(UInt other) const { div_check(other); return UInt(this->data_ \/ other.data_); }$/;"	f	class:thorin::UInt
operator <	src/thorin/util/types.h	/^    bool  operator< (Float other) const { return this->data_ < other.data_; }$/;"	f	class:thorin::Float
operator <	src/thorin/util/types.h	/^    bool operator< (SInt other) const { return this->data_ < other.data_; }$/;"	f	class:thorin::SInt
operator <	src/thorin/util/types.h	/^    bool operator< (UInt other) const { return this->data_ < other.data_; }$/;"	f	class:thorin::UInt
operator <<	src/thorin/def.h	/^inline std::ostream& operator<<(std::ostream& os, Use use) { return use->stream(os); }$/;"	f	namespace:thorin
operator <<	src/thorin/def.h	/^inline std::ostream& operator<<(std::ostream& os, const Def* def) { return def == nullptr ? os << "nullptr" : def->stream(os); }$/;"	f	namespace:thorin
operator <<	src/thorin/def.h	/^inline std::ostream& operator<<(std::ostream& os, const Type* type) { return type == nullptr ? os << "nullptr" : type->stream(os); }$/;"	f	namespace:thorin
operator <<	src/thorin/util/array.h	/^std::ostream& operator<<(std::ostream& os, const Array<T>& a) {$/;"	f	namespace:thorin
operator <<	src/thorin/util/array.h	/^std::ostream& operator<<(std::ostream& os, const ArrayRef<T> a) {$/;"	f	namespace:thorin
operator <<	src/thorin/util/location.cpp	/^std::ostream& operator<<(std::ostream& os, Debug dbg) {$/;"	f	namespace:thorin
operator <<	src/thorin/util/location.cpp	/^std::ostream& operator<<(std::ostream& os, Location l) {$/;"	f	namespace:thorin
operator <<	src/thorin/util/stream.cpp	/^std::ostream& operator<<(std::ostream& ostream, const Streamable* s) { return s->stream(ostream); }$/;"	f	namespace:thorin
operator <<	src/thorin/util/stream.h	/^std::ostream& operator<<(std::ostream& os, StreamList<Emit, List> sl) {$/;"	f	namespace:thorin
operator <<	src/thorin/util/symbol.h	/^inline std::ostream& operator<<(std::ostream& os, Symbol s) { return os << s.c_str(); }$/;"	f	namespace:thorin
operator <<	src/thorin/util/types.h	/^    SInt operator<<(SInt other) const {$/;"	f	class:thorin::SInt
operator <<	src/thorin/util/types.h	/^    UInt operator<<(UInt other) const {$/;"	f	class:thorin::UInt
operator <<	src/thorin/util/types.h	/^std::ostream& operator<<(std::ostream& os, const Float<FT, precise>& ft) { return os << ft.data(); }$/;"	f	namespace:thorin
operator <=	src/thorin/util/types.h	/^    bool  operator<=(Float other) const { return this->data_ <=other.data_; }$/;"	f	class:thorin::Float
operator <=	src/thorin/util/types.h	/^    bool operator<=(SInt other) const { return this->data_ <=other.data_; }$/;"	f	class:thorin::SInt
operator <=	src/thorin/util/types.h	/^    bool operator<=(UInt other) const { return this->data_ <=other.data_; }$/;"	f	class:thorin::UInt
operator =	src/thorin/continuation.h	/^    Call& operator=(Call other) { swap(*this, other); return *this; }$/;"	f	struct:thorin::Call
operator =	src/thorin/util/array.h	/^    Array<T>& operator=(Array<T> other) { swap(*this, other); return *this; }$/;"	f	class:thorin::Array
operator =	src/thorin/util/hash.h	/^    HashTable& operator=(HashTable other) { swap(*this, other); return *this; }$/;"	f	class:thorin::detail::HashTable
operator =	src/thorin/util/indexset.h	/^        reference operator=(bool b) {$/;"	f	class:thorin::IndexSet::reference
operator =	src/thorin/util/indexset.h	/^    IndexSet& operator =(IndexSet other) { swap(*this, other); return *this; }$/;"	f	class:thorin::IndexSet
operator =	src/thorin/util/iterator.h	/^    filter_iterator& operator=(filter_iterator other) { swap(*this, other); return *this; }$/;"	f	class:thorin::filter_iterator
operator =	src/thorin/util/iterator.h	/^    map_iterator& operator=(map_iterator other) { swap(*this, other); return *this; }$/;"	f	class:thorin::map_iterator
operator ==	src/thorin/continuation.h	/^    bool operator==(const Call& other) const { return this->ops() == other.ops(); }$/;"	f	struct:thorin::Call
operator ==	src/thorin/def.h	/^    bool operator==(Use other) const { return this->def() == other.def() && this->index() == other.index(); }$/;"	f	class:thorin::Use
operator ==	src/thorin/util/args.h	/^    bool operator==(ArgsIterator b) const { return pos_ == b.pos_; }$/;"	f	class:thorin::ArgsIterator
operator ==	src/thorin/util/array.h	/^    bool operator==(const Array<T>& other) const { return ArrayRef<T>(*this) == ArrayRef<T>(other); }$/;"	f	class:thorin::Array
operator ==	src/thorin/util/array.h	/^    bool operator==(const Other& other) const { return this->size() == other.size() && std::equal(begin(), end(), other.begin()); }$/;"	f	class:thorin::ArrayRef
operator ==	src/thorin/util/hash.h	/^        bool operator==(const iterator_base& other) { verify(other); return this->ptr_ == other.ptr_; }$/;"	f	class:thorin::detail::HashTable::iterator_base
operator ==	src/thorin/util/iterator.h	/^    bool operator==(const filter_iterator& other) { return this->iterator_ == other.iterator_; }$/;"	f	class:thorin::filter_iterator
operator ==	src/thorin/util/iterator.h	/^    bool operator==(const map_iterator& other) { return this->iterator_ == other.iterator_; }$/;"	f	class:thorin::map_iterator
operator ==	src/thorin/util/symbol.h	/^    bool operator==(Symbol symbol) const { return c_str() == symbol.c_str(); }$/;"	f	class:thorin::Symbol
operator ==	src/thorin/util/symbol.h	/^    bool operator==(const char* s) const { return c_str() == Symbol(s).c_str(); }$/;"	f	class:thorin::Symbol
operator ==	src/thorin/util/types.h	/^    bool  operator==(Float other) const { return this->data_ ==other.data_; }$/;"	f	class:thorin::Float
operator ==	src/thorin/util/types.h	/^    bool operator==(SInt other) const { return this->data_ ==other.data_; }$/;"	f	class:thorin::SInt
operator ==	src/thorin/util/types.h	/^    bool operator==(UInt other) const { return this->data_ ==other.data_; }$/;"	f	class:thorin::UInt
operator ==	src/thorin/util/types.h	/^    bool operator==(const Box& other) const { return bcast<uint64_t, Box>(*this) == bcast<uint64_t, Box>(other); }$/;"	f	union:thorin::Box
operator ==	src/thorin/util/utility.h	/^    bool operator==(TaggedPtr other) const { return this->ptr() == other.ptr() && this->index() == other.index(); }$/;"	f	class:thorin::TaggedPtr
operator >	src/thorin/util/types.h	/^    bool  operator> (Float other) const { return this->data_ > other.data_; }$/;"	f	class:thorin::Float
operator >	src/thorin/util/types.h	/^    bool operator> (SInt other) const { return this->data_ > other.data_; }$/;"	f	class:thorin::SInt
operator >	src/thorin/util/types.h	/^    bool operator> (UInt other) const { return this->data_ > other.data_; }$/;"	f	class:thorin::UInt
operator >=	src/thorin/util/types.h	/^    bool  operator>=(Float other) const { return this->data_ >=other.data_; }$/;"	f	class:thorin::Float
operator >=	src/thorin/util/types.h	/^    bool operator>=(SInt other) const { return this->data_ >=other.data_; }$/;"	f	class:thorin::SInt
operator >=	src/thorin/util/types.h	/^    bool operator>=(UInt other) const { return this->data_ >=other.data_; }$/;"	f	class:thorin::UInt
operator >>	src/thorin/util/types.h	/^    SInt operator>>(SInt other) const { return this->data_ >>other.data_; }$/;"	f	class:thorin::SInt
operator >>	src/thorin/util/types.h	/^    UInt operator>>(UInt other) const { return this->data_ >>other.data_; }$/;"	f	class:thorin::UInt
operator FT	src/thorin/util/types.h	/^    operator FT() const { return data_; }$/;"	f	class:thorin::Float
operator ST	src/thorin/util/types.h	/^    operator ST() const { return data_; }$/;"	f	class:thorin::SInt
operator T*	src/thorin/util/utility.h	/^    operator T*() const { return ptr(); }$/;"	f	class:thorin::TaggedPtr
operator UT	src/thorin/util/types.h	/^    operator UT() const { return data_; }$/;"	f	class:thorin::UInt
operator []	src/thorin/analyses/cfg.h	/^    const CFNode* operator [] (Continuation* continuation) const { return cfa()[continuation]; }    \/\/\/< Maps from @p l to @p CFNode.$/;"	f	class:thorin::CFG
operator []	src/thorin/analyses/cfg.h	/^    const CFNode* operator [] (Continuation* continuation) const { return find(nodes_, continuation); }$/;"	f	class:thorin::CFA
operator []	src/thorin/analyses/looptree.h	/^    const Leaf* operator[](const CFNode* n) const { return find(leaves_, n); }$/;"	f	class:thorin::LoopTree
operator []	src/thorin/analyses/schedule.h	/^    Block& operator[](const CFNode* n) { return blocks_[indices_[n]]; }$/;"	f	class:thorin::Schedule
operator []	src/thorin/analyses/schedule.h	/^    const Block& operator[](const CFNode* n) const { return blocks_[indices_[n]]; }$/;"	f	class:thorin::Schedule
operator []	src/thorin/util/array.h	/^    T const& operator[](size_t i) const { assert(i < size() && "index out of bounds"); return ptr_[i]; }$/;"	f	class:thorin::Array
operator []	src/thorin/util/array.h	/^    T& operator[](size_t i) { assert(i < size() && "index out of bounds"); return ptr_[i]; }$/;"	f	class:thorin::Array
operator []	src/thorin/util/array.h	/^    const T& operator[](size_t i) const { assert(i < size() && "index out of bounds"); return *(ptr_ + i); }$/;"	f	class:thorin::ArrayRef
operator []	src/thorin/util/hash.h	/^    mapped_type& operator[](const key_type& key) { return Super::insert(value_type(key, T())).first->second; }$/;"	f	class:thorin::HashMap
operator []	src/thorin/util/hash.h	/^    mapped_type& operator[](key_type&& key) {$/;"	f	class:thorin::HashMap
operator []	src/thorin/util/indexmap.h	/^    Value& operator[](Key key) { auto i = indexer().index(key); assert(i != size_t(-1)); return array_[i]; }$/;"	f	class:thorin::IndexMap
operator []	src/thorin/util/indexmap.h	/^    const Value& operator[](Key key) const { return const_cast<IndexMap*>(this)->operator[](key); }$/;"	f	class:thorin::IndexMap
operator []	src/thorin/util/indexset.h	/^    bool operator[](Key key) const { return (*const_cast<IndexSet<Indexer, Key>*>(this))[key]; }$/;"	f	class:thorin::IndexSet
operator []	src/thorin/util/indexset.h	/^    reference operator[](Key key) {$/;"	f	class:thorin::IndexSet
operator ^	src/thorin/util/types.h	/^    SInt operator^ (SInt other) const { return this->data_ ^ other.data_; }$/;"	f	class:thorin::SInt
operator ^	src/thorin/util/types.h	/^    UInt operator^ (UInt other) const { return this->data_ ^ other.data_; }$/;"	f	class:thorin::UInt
operator ^=	src/thorin/util/indexset.h	/^    IndexSet& operator^=(const IndexSet& other) { return transform(other, std::bit_xor<uint64_t>()); }$/;"	f	class:thorin::IndexSet
operator bool	src/thorin/continuation.h	/^    explicit operator bool() { return !ops_.empty(); }$/;"	f	struct:thorin::Call
operator bool	src/thorin/util/indexset.h	/^        operator bool() const { return word_ & (uint64_t(1) << pos_); }$/;"	f	class:thorin::IndexSet::reference
operator bool	src/thorin/util/symbol.h	/^    operator bool() const { return *this != Symbol(""); }$/;"	f	class:thorin::Symbol
operator const Def*	src/thorin/def.h	/^    operator const Def*() const { return def(); }$/;"	f	class:thorin::Use
operator const Def*	src/thorin/def.h	/^    operator const Def*() { return def(); }$/;"	f	class:thorin::Tracker
operator |	src/thorin/primop.h	/^inline Assembly::Flags operator|(Assembly::Flags lhs, Assembly::Flags rhs) { return static_cast<Assembly::Flags>(static_cast<int>(lhs) | static_cast<int>(rhs)); }$/;"	f	namespace:thorin
operator |	src/thorin/util/types.h	/^    SInt operator| (SInt other) const { return this->data_ | other.data_; }$/;"	f	class:thorin::SInt
operator |	src/thorin/util/types.h	/^    UInt operator| (UInt other) const { return this->data_ | other.data_; }$/;"	f	class:thorin::UInt
operator |=	src/thorin/primop.h	/^inline Assembly::Flags operator|=(Assembly::Flags& lhs, Assembly::Flags rhs) { return lhs = lhs | rhs; }$/;"	f	namespace:thorin
operator |=	src/thorin/util/indexset.h	/^    IndexSet& operator|=(const IndexSet& other) { return transform(other, std::bit_or <uint64_t>()); }$/;"	f	class:thorin::IndexSet
ops	src/thorin/continuation.h	/^    Defs ops() const { return ops_; }$/;"	f	struct:thorin::Call
ops	src/thorin/def.h	/^    Defs ops() const { return ops_; }$/;"	f	class:thorin::Def
ops	src/thorin/util/type_table.h	/^    Types ops() const { return ops_; }$/;"	f	class:thorin::TypeBase
ops_	src/thorin/continuation.h	/^    Array<const Def*> ops_;$/;"	m	struct:thorin::Call
ops_	src/thorin/def.h	/^    std::vector<const Def*> ops_;$/;"	m	class:thorin::Def
ops_	src/thorin/util/type_table.h	/^    thorin::Array<const TypeBase*> ops_;$/;"	m	class:thorin::TypeBase
opt	src/thorin/world.cpp	/^void World::opt() {$/;"	f	class:thorin::World
optimize	src/thorin/be/llvm/llvm.cpp	/^void CodeGen::optimize(int opt) {$/;"	f	class:thorin::CodeGen
option	src/thorin/util/args.h	/^    Option<void, void> option() const { return Option<void, void>(); }$/;"	f	class:thorin::ArgParser
order	src/thorin/def.h	/^    int order() const { return type()->order(); }$/;"	f	class:thorin::Def
order	src/thorin/util/type_table.h	/^    int order() const { return order_; }$/;"	f	class:thorin::TypeBase
order_	src/thorin/util/type_table.h	/^    int order_ = 0;$/;"	m	class:thorin::TypeBase
os_	src/thorin/be/c.cpp	/^    std::ostream& os_;$/;"	m	class:thorin::CCodeGen	file:
ostream	src/thorin/util/ycomp.h	/^    std::ostream& ostream() { return ostream_; }$/;"	f	class:thorin::YCompScope
ostream_	src/thorin/util/ycomp.h	/^    std::ostream& ostream_;$/;"	m	class:thorin::YCompScope
other	src/thorin/util/hash.h	/^        iterator_base& operator=(const iterator_base& other) = default;$/;"	m	class:thorin::detail::HashTable::iterator_base
out	src/thorin/primop.cpp	/^const Def* PrimOp::out(size_t i) const {$/;"	f	class:thorin::PrimOp
out_frame	src/thorin/primop.h	/^    const Def* out_frame() const { return out(1); }$/;"	f	class:thorin::Enter
out_mem	src/thorin/primop.h	/^    const Def* out_mem() const { return has_multiple_outs() ? out(0) : this; }$/;"	f	class:thorin::MemOp
out_ptr	src/thorin/primop.h	/^    const Def* out_ptr() const { return out(1); }$/;"	f	class:thorin::Alloc
out_ptr_type	src/thorin/primop.h	/^    const PtrType* out_ptr_type() const { return type()->op(1)->as<PtrType>(); }$/;"	f	class:thorin::Alloc
out_val	src/thorin/primop.h	/^    const Def* out_val() const { return out(1); }$/;"	f	class:thorin::Load
out_val_type	src/thorin/primop.h	/^    const Type* out_val_type() const { return type()->op(1); }$/;"	f	class:thorin::Load
outf	src/thorin/util/log.h	/^template<typename... Args> std::ostream& outf(const char* fmt, Args... args) { return streamf(std::cout, fmt, std::forward<Args>(args)...); }$/;"	f	namespace:thorin
output_constraints	src/thorin/primop.h	/^    const ArrayRef<std::string> output_constraints() const { return output_constraints_; }$/;"	f	class:thorin::Assembly
output_constraints_	src/thorin/primop.h	/^    Array<std::string> output_constraints_, input_constraints_, clobbers_;$/;"	m	class:thorin::Assembly
override	src/thorin/analyses/cfg.h	/^    std::ostream& stream(std::ostream& os) const override;$/;"	m	class:thorin::CFNode
override	src/thorin/analyses/cfg.h	/^    void stream_ycomp(std::ostream& out) const override;$/;"	m	class:thorin::CFG
override	src/thorin/analyses/domfrontier.h	/^    virtual void stream_ycomp(std::ostream& out) const override;$/;"	m	class:thorin::DomFrontierBase
override	src/thorin/analyses/domtree.h	/^    virtual void stream_ycomp(std::ostream& out) const override;$/;"	m	class:thorin::DomTreeBase
override	src/thorin/analyses/looptree.h	/^        virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::LoopTree::Head
override	src/thorin/analyses/looptree.h	/^        virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::LoopTree::Leaf
override	src/thorin/analyses/looptree.h	/^    virtual void stream_ycomp(std::ostream& out) const override;$/;"	m	class:thorin::LoopTree
override	src/thorin/analyses/schedule.h	/^    virtual std::ostream& stream(std::ostream&) const override;  \/\/\/< Streams thorin to file @p out.$/;"	m	class:thorin::Schedule
override	src/thorin/analyses/scope.h	/^    virtual std::ostream& stream(std::ostream&) const override;  \/\/\/< Streams thorin to file @p out.$/;"	m	class:thorin::Scope
override	src/thorin/be/llvm/amdgpu.h	/^    virtual Continuation* emit_reserve(const Continuation*) override;$/;"	m	class:thorin::AMDGPUCodeGen
override	src/thorin/be/llvm/amdgpu.h	/^    virtual llvm::Value* emit_global(const Global*) override;$/;"	m	class:thorin::AMDGPUCodeGen
override	src/thorin/be/llvm/amdgpu.h	/^    virtual unsigned convert_addr_space(const AddrSpace) override;$/;"	m	class:thorin::AMDGPUCodeGen
override	src/thorin/be/llvm/amdgpu.h	/^    virtual void emit_function_decl_hook(Continuation*, llvm::Function*) override;$/;"	m	class:thorin::AMDGPUCodeGen
override	src/thorin/be/llvm/cuda.h	/^    void emit(std::ostream& stream, int opt, bool debug) override;$/;"	m	class:thorin::CUDACodeGen
override	src/thorin/be/llvm/hls.h	/^    void emit(std::ostream& stream, int opt, bool debug) override;$/;"	m	class:thorin::HLSCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual Continuation* emit_reserve(const Continuation*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::FunctionType* convert_fn_type(Continuation*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::Value* emit_global(const Global*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::Value* emit_lea(const LEA*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::Value* emit_load(const Load*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::Value* emit_store(const Store*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual llvm::Value* map_param(llvm::Function*, llvm::Argument*, const Param*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual void emit_function_decl_hook(Continuation*, llvm::Function*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/nvvm.h	/^    virtual void emit_function_start(llvm::BasicBlock*, Continuation*) override;$/;"	m	class:thorin::NVVMCodeGen
override	src/thorin/be/llvm/opencl.h	/^    void emit(std::ostream& stream, int opt, bool debug) override;$/;"	m	class:thorin::OpenCLCodeGen
override	src/thorin/primop.h	/^    std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::Global
override	src/thorin/primop.h	/^    std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::PrimLit
override	src/thorin/primop.h	/^    virtual bool equal(const PrimOp* other) const override;$/;"	m	class:thorin::PrimLit
override	src/thorin/primop.h	/^    virtual bool equal(const PrimOp* other) const override;$/;"	m	class:thorin::Slot
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Alloc
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::ArithOp
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Assembly
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Bitcast
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Bottom
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Cast
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Closure
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Cmp
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::DefiniteArray
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Enter
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Extract
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Global
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Hlt
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::IndefiniteArray
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Insert
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Known
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::LEA
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Load
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::PrimLit
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Run
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Select
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::SizeOf
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Slot
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Store
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::StructAgg
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Top
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Tuple
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Variant
override	src/thorin/primop.h	/^    virtual const Def* vrebuild(World& to, Defs ops, const Type* type) const override;$/;"	m	class:thorin::Vector
override	src/thorin/primop.h	/^    virtual const char* op_name() const override;$/;"	m	class:thorin::ArithOp
override	src/thorin/primop.h	/^    virtual const char* op_name() const override;$/;"	m	class:thorin::Cmp
override	src/thorin/primop.h	/^    virtual const char* op_name() const override;$/;"	m	class:thorin::Global
override	src/thorin/primop.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::PrimOp
override	src/thorin/primop.h	/^    virtual std::ostream& stream_assignment(std::ostream&) const override;$/;"	m	class:thorin::Assembly
override	src/thorin/primop.h	/^    virtual uint64_t vhash() const override;$/;"	m	class:thorin::PrimLit
override	src/thorin/primop.h	/^    virtual uint64_t vhash() const override;$/;"	m	class:thorin::Slot
override	src/thorin/type.h	/^    virtual bool equal(const Type* other) const override;$/;"	m	class:thorin::PtrType
override	src/thorin/type.h	/^    virtual bool equal(const Type*) const override;$/;"	m	class:thorin::Var
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::App
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::ClosureType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::DefiniteArrayType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::FnType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::FrameType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::IndefiniteArrayType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::Lambda
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::MemType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::PrimType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::PtrType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::StructType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::TupleType
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::Var
override	src/thorin/type.h	/^    virtual const Type* vrebuild(TypeTable& to, Types ops) const override;$/;"	m	class:thorin::VariantType
override	src/thorin/type.h	/^    virtual const Type* vreduce(int, const Type*, Type2Type&) const override;$/;"	m	class:thorin::Lambda
override	src/thorin/type.h	/^    virtual const Type* vreduce(int, const Type*, Type2Type&) const override;$/;"	m	class:thorin::StructType
override	src/thorin/type.h	/^    virtual const Type* vreduce(int, const Type*, Type2Type&) const override;$/;"	m	class:thorin::Var
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::App
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::ClosureType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::DefiniteArrayType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::FnType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::FrameType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::IndefiniteArrayType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::Lambda
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::MemType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::PrimType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::PtrType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::StructType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::TupleType
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::Var
override	src/thorin/type.h	/^    virtual std::ostream& stream(std::ostream&) const override;$/;"	m	class:thorin::VariantType
override	src/thorin/type.h	/^    virtual uint64_t vhash() const override;$/;"	m	class:thorin::PtrType
override	src/thorin/type.h	/^    virtual uint64_t vhash() const override;$/;"	m	class:thorin::Var
override	src/thorin/world.h	/^    virtual std::ostream& stream(std::ostream&) const override; \/\/\/< Streams thorin to file @p out.$/;"	m	class:thorin::World
parallel_for	src/thorin/be/llvm/runtime.cpp	/^llvm::Value* Runtime::parallel_for(llvm::Value* num_threads, llvm::Value* lower, llvm::Value* upper,$/;"	f	class:thorin::Runtime
param	src/thorin/continuation.h	/^    const Param* param(size_t i) const { assert(i < num_params()); return params_[i]; }$/;"	f	class:thorin::Continuation
param	src/thorin/util/args.h	/^    const std::string& param() const { return param_; }$/;"	f	class:thorin::BasicOption
param	src/thorin/world.cpp	/^const Param* World::param(const Type* type, Continuation* continuation, size_t index, Debug dbg) {$/;"	f	class:thorin::World
param_	src/thorin/util/args.h	/^    std::string param_;$/;"	m	class:thorin::BasicOption
param_size	src/thorin/be/kernel_config.h	/^    uint32_t param_size(const Param* param) const {$/;"	f	class:thorin::HLSKernelConfig
param_sizes_	src/thorin/be/kernel_config.h	/^    Param2Size param_sizes_;$/;"	m	class:thorin::HLSKernelConfig
params	src/thorin/continuation.h	/^    ArrayRef<const Param*> params() const { return params_; }$/;"	f	class:thorin::Continuation
params_	src/thorin/be/llvm/llvm.h	/^    ParamMap<llvm::Value*> params_;$/;"	m	class:thorin::CodeGen
params_	src/thorin/continuation.h	/^    std::vector<const Param*> params_;$/;"	m	class:thorin::Continuation
params_as_defs	src/thorin/continuation.cpp	/^Array<const Def*> Continuation::params_as_defs() const {$/;"	f	class:thorin::Continuation
parent	src/thorin/analyses/looptree.h	/^        const Head* parent() const { return parent_; }$/;"	f	class:thorin::LoopTree::Node
parent_	src/thorin/analyses/looptree.h	/^        Head* parent_;$/;"	m	class:thorin::LoopTree::Node
parse	src/thorin/util/args.h	/^    void parse(int argc, char** argv) const {$/;"	f	class:thorin::OptionBase
partial_evaluation	src/thorin/transform/partial_evaluation.cpp	/^bool partial_evaluation(World& world, bool lower2cff) {$/;"	f	namespace:thorin
pe_done_	src/thorin/world.h	/^    bool pe_done_ = false;$/;"	m	class:thorin::World
peek	src/thorin/continuation.cpp	/^std::vector<Param::Peek> Param::peek() const {$/;"	f	class:thorin::Param
pf16	src/thorin/util/types.h	/^typedef half   f16; typedef Float<f16, true> pf16; typedef Float<f16, false> qf16;$/;"	t	namespace:thorin
pf32	src/thorin/util/types.h	/^typedef float  f32; typedef Float<f32, true> pf32; typedef Float<f32, false> qf32;$/;"	t	namespace:thorin
pf64	src/thorin/util/types.h	/^typedef double f64; typedef Float<f64, true> pf64; typedef Float<f64, false> qf64;$/;"	t	namespace:thorin
phis_	src/thorin/be/llvm/llvm.h	/^    ParamMap<llvm::PHINode*> phis_;$/;"	m	class:thorin::CodeGen
pointee	src/thorin/type.h	/^    const Type* pointee() const { return op(0); }$/;"	f	class:thorin::PtrType
pointer	src/thorin/util/hash.h	/^        typedef typename std::conditional<is_const, const value_type*, value_type*>::type pointer;$/;"	t	class:thorin::detail::HashTable::iterator_base
pointer	src/thorin/util/iterator.h	/^    typedef OutT* pointer;$/;"	t	class:thorin::map_iterator
pointer	src/thorin/util/iterator.h	/^    typedef V* pointer;$/;"	t	class:thorin::filter_iterator
pop	src/thorin/util/utility.h	/^    T pop() { return thorin::pop(queue_); }$/;"	f	class:thorin::unique_queue
pop	src/thorin/util/utility.h	/^    T pop() { return thorin::pop(stack_); }$/;"	f	class:thorin::unique_stack
pop	src/thorin/util/utility.h	/^T pop(std::queue<T>& queue) {$/;"	f	namespace:thorin
pop	src/thorin/util/utility.h	/^T pop(std::stack<T>& stack) {$/;"	f	namespace:thorin
pos_	src/thorin/util/args.h	/^    int pos_;$/;"	m	class:thorin::ArgsIterator
pos_	src/thorin/util/indexset.h	/^        uint64_t pos_;$/;"	m	class:thorin::IndexSet::reference
post_order	src/thorin/analyses/cfg.h	/^    Range<ArrayRef<const CFNode*>::const_reverse_iterator> post_order() const { return reverse_range(rpo_.array()); }$/;"	f	class:thorin::CFG
post_order	src/thorin/analyses/cfg.h	/^    const CFNode* post_order(size_t i) const { return rpo_.array()[size()-1-i]; } \/\/\/< Maps from post-order index to @p CFNode.$/;"	f	class:thorin::CFG
post_order_visit	src/thorin/analyses/cfg.cpp	/^size_t CFG<forward>::post_order_visit(const CFNode* n, size_t i) {$/;"	f	class:thorin::CFG
predicate	src/thorin/util/iterator.h	/^    P predicate() const { return predicate_; }$/;"	f	class:thorin::filter_iterator
predicate_	src/thorin/util/iterator.h	/^    P predicate_;$/;"	m	class:thorin::filter_iterator
preds	src/thorin/analyses/cfg.cpp	/^template<bool forward> const CFNodes& CFG<forward>::preds(const CFNode* n) const { assert(n != nullptr); return forward ? n->preds() : n->succs(); }$/;"	f	class:thorin::CFG
preds	src/thorin/analyses/cfg.h	/^    const CFNodes& preds() const { return preds_; }$/;"	f	class:thorin::CFNode
preds	src/thorin/analyses/cfg.h	/^    const CFNodes& preds(Continuation* continuation) const { auto cn = nodes_.find(continuation)->second; assert(cn); return cn->preds(); }$/;"	f	class:thorin::CFA
preds	src/thorin/analyses/cfg.h	/^    const CFNodes& preds(Continuation* continuation) const { return preds(cfa()[continuation]); }$/;"	f	class:thorin::CFG
preds	src/thorin/analyses/domfrontier.h	/^    const std::vector<const CFNode*>& preds(const CFNode* n) const { return preds_[n]; }$/;"	f	class:thorin::DomFrontierBase
preds	src/thorin/continuation.cpp	/^Continuations Continuation::preds() const {$/;"	f	class:thorin::Continuation
preds_	src/thorin/analyses/cfg.h	/^    mutable CFNodes preds_;$/;"	m	class:thorin::CFNode
preds_	src/thorin/analyses/domfrontier.h	/^    typename CFG<forward>::template Map<std::vector<const CFNode*>> preds_;$/;"	m	class:thorin::DomFrontierBase
previous_	src/thorin/util/args.h	/^    T previous_;$/;"	m	class:thorin::OptionBase
prime	src/thorin/util/hash.h	/^    static const uint64_t prime  = 1099511628211_u64;$/;"	m	struct:thorin::FNV1
primlit_value	src/thorin/primop.h	/^T primlit_value(const Def* def) {$/;"	f	namespace:thorin
primop2str_	src/thorin/be/c.cpp	/^    DefMap<std::string> primop2str_;$/;"	m	class:thorin::CCodeGen	file:
primop_counter	src/thorin/be/c.cpp	/^    int primop_counter = 0;$/;"	m	class:thorin::CCodeGen	file:
primops	src/thorin/analyses/schedule.h	/^        ArrayRef<const PrimOp*> primops() const { return primops_; }$/;"	f	class:thorin::Schedule::Block
primops	src/thorin/world.h	/^    const PrimOpSet& primops() const { return primops_; }$/;"	f	class:thorin::World
primops_	src/thorin/analyses/schedule.h	/^        std::vector<const PrimOp*> primops_;$/;"	m	class:thorin::Schedule::Block
primops_	src/thorin/be/llvm/llvm.h	/^    PrimOpMap<llvm::Value*> primops_;$/;"	m	class:thorin::CodeGen
primops_	src/thorin/world.h	/^    PrimOpSet primops_;$/;"	m	class:thorin::World
primtype_tag	src/thorin/primop.h	/^    PrimTypeTag primtype_tag() const { return type()->primtype_tag(); }$/;"	f	class:thorin::PrimLit
primtype_tag	src/thorin/type.h	/^    PrimTypeTag primtype_tag() const { return (PrimTypeTag) tag(); }$/;"	f	class:thorin::PrimType
primtypes_	src/thorin/type.h	/^        const PrimType* primtypes_[Num_PrimTypes];$/;"	m	union:thorin::TypeTable::__anon7
print_help	src/thorin/util/args.h	/^    void print_help() { std::cout << "implicit arguments: " << help() << std::endl; }$/;"	f	struct:thorin::ImplicitOption
print_help	src/thorin/util/args.h	/^    void print_help() {$/;"	f	class:thorin::OptionBase
print_help	src/thorin/util/args.h	/^    void print_help() {}$/;"	f	struct:thorin::Option
probe_distance	src/thorin/util/hash.h	/^    size_t probe_distance(size_t i) { return mod(i + capacity() - desired_pos(key(nodes_+i))); }$/;"	f	class:thorin::detail::HashTable
process_use	src/thorin/transform/resolve_loads.cpp	/^    const Def* process_use(const Def* mem_use, Def2Def& mapping) {$/;"	f	class:thorin::ResolveLoads
ps16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
ps32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
ps64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
ps8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
ptr	src/thorin/primop.h	/^    const Def* ptr() const { return op(0); }$/;"	f	class:thorin::LEA
ptr	src/thorin/primop.h	/^    const Def* ptr() const { return op(1); }$/;"	f	class:thorin::Access
ptr	src/thorin/util/utility.h	/^    T* ptr() const { return reinterpret_cast<T*>(ptr_); }$/;"	f	class:thorin::TaggedPtr
ptr_	src/thorin/util/array.h	/^        , ptr_(ptr)$/;"	f	class:thorin::ArrayRef
ptr_	src/thorin/util/array.h	/^    T* ptr_;$/;"	m	class:thorin::Array
ptr_	src/thorin/util/array.h	/^    const T* ptr_;$/;"	m	class:thorin::ArrayRef
ptr_	src/thorin/util/hash.h	/^        value_type* ptr_;$/;"	m	class:thorin::detail::HashTable::iterator_base
ptr_	src/thorin/util/utility.h	/^    T* ptr_;$/;"	m	class:thorin::TaggedPtr
ptr_pointee	src/thorin/primop.h	/^    const Type* ptr_pointee() const { return ptr_type()->pointee(); }        \/\/\/< Returns the type referenced by @p ptr().$/;"	f	class:thorin::LEA
ptr_type	src/thorin/primop.h	/^    const PtrType* ptr_type() const { return ptr()->type()->as<PtrType>(); } \/\/\/< Returns the PtrType from @p ptr().$/;"	f	class:thorin::LEA
ptr_type	src/thorin/type.h	/^    const PtrType* ptr_type(const Type* pointee,$/;"	f	class:thorin::TypeTable
pu16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
pu32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
pu64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
pu8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
push	src/thorin/analyses/looptree.cpp	/^    void push(const CFNode* n) {$/;"	f	class:thorin::LoopTreeBuilder	file:
push	src/thorin/util/utility.h	/^    void push(T val) {$/;"	f	class:thorin::unique_queue
push	src/thorin/util/utility.h	/^    void push(T val) {$/;"	f	class:thorin::unique_stack
push	src/thorin/util/utility.h	/^inline Push<T> push(T& t, U new_val) { return Push<T>(t, new_val); }$/;"	f	namespace:thorin
qf16	src/thorin/util/types.h	/^typedef half   f16; typedef Float<f16, true> pf16; typedef Float<f16, false> qf16;$/;"	t	namespace:thorin
qf32	src/thorin/util/types.h	/^typedef float  f32; typedef Float<f32, true> pf32; typedef Float<f32, false> qf32;$/;"	t	namespace:thorin
qf64	src/thorin/util/types.h	/^typedef double f64; typedef Float<f64, true> pf64; typedef Float<f64, false> qf64;$/;"	t	namespace:thorin
qnxnto	build/CMakeFiles/3.4.3/CompilerIdC/CMakeCCompilerId.c	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
qnxnto	build/CMakeFiles/3.4.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
qs16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
qs32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
qs64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
qs8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
qu16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
qu32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
qu64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
qu8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
queue_	src/thorin/transform/partial_evaluation.cpp	/^    std::queue<Continuation*> queue_;$/;"	m	class:thorin::PartialEvaluator	file:
queue_	src/thorin/util/utility.h	/^    std::queue<T> queue_;$/;"	m	class:thorin::unique_queue
rbegin	src/thorin/util/array.h	/^    const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:thorin::Array
rbegin	src/thorin/util/array.h	/^    const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:thorin::ArrayRef
rbegin	src/thorin/util/array.h	/^    reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:thorin::Array
rebuild	src/thorin/primop.h	/^    const Def* rebuild(Defs ops) const { return rebuild(world(), ops, type()); }$/;"	f	class:thorin::PrimOp
rebuild	src/thorin/primop.h	/^    const Def* rebuild(Defs ops, const Type* type) const { return rebuild(world(), ops, type); }$/;"	f	class:thorin::PrimOp
rebuild	src/thorin/primop.h	/^    const Def* rebuild(World& to, Defs ops, const Type* type) const {$/;"	f	class:thorin::PrimOp
rebuild	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::rebuild() {$/;"	f	class:thorin::Cleaner
rebuild	src/thorin/util/type_table.h	/^    const TypeBase* rebuild(Types ops) const { return rebuild(table(), ops); }$/;"	f	class:thorin::TypeBase
rebuild	src/thorin/util/type_table.h	/^const TypeBase<TypeTable>* TypeBase<TypeTable>::rebuild(TypeTable& to, Types ops) const {$/;"	f	class:thorin::TypeBase
recurse	src/thorin/analyses/looptree.cpp	/^void LoopTreeBuilder<forward>::recurse(Head* parent, ArrayRef<const CFNode*> heads, int depth) {$/;"	f	class:thorin::LoopTreeBuilder
reduce	src/thorin/util/type_table.h	/^const TypeBase<TypeTable>* TypeBase<TypeTable>::reduce(int depth, const TypeBase* type, Type2Type& map) const {$/;"	f	class:thorin::TypeBase
ref	src/thorin/util/array.h	/^    ArrayRef<T> ref() const { return ArrayRef<T>(ptr_, size_); }$/;"	f	class:thorin::Array
ref_	src/thorin/util/utility.h	/^    T& ref_;$/;"	m	struct:thorin::Push
reference	src/thorin/util/hash.h	/^        typedef typename std::conditional<is_const, const value_type&, value_type&>::type reference;$/;"	t	class:thorin::detail::HashTable::iterator_base
reference	src/thorin/util/indexset.h	/^        reference(uint64_t& word, uint64_t pos)$/;"	f	class:thorin::IndexSet::reference
reference	src/thorin/util/indexset.h	/^    class reference {$/;"	c	class:thorin::IndexSet
reference	src/thorin/util/iterator.h	/^    typedef OutT& reference;$/;"	t	class:thorin::map_iterator
reference	src/thorin/util/iterator.h	/^    typedef V& reference;$/;"	t	class:thorin::filter_iterator
rehash	src/thorin/util/hash.h	/^    void rehash(size_t new_capacity) {$/;"	f	class:thorin::detail::HashTable
rem	src/thorin/util/types.h	/^inline double      rem(double a, double b)           { return std::fmod(a, b); }$/;"	f	namespace:thorin
rem	src/thorin/util/types.h	/^inline float       rem(float a, float b)             { return std::fmod(a, b); }$/;"	f	namespace:thorin
rem	src/thorin/util/types.h	/^inline half        rem(half a, half b)               { return      fmod(a, b); }$/;"	f	namespace:thorin
rem	src/thorin/util/types.h	/^inline long double rem(long double a, long double b) { return std::fmod(a, b); }$/;"	f	namespace:thorin
remove_external	src/thorin/world.h	/^    void remove_external(Continuation* continuation) { externals_.erase(continuation); }$/;"	f	class:thorin::World
remove_quotation	src/thorin/util/symbol.cpp	/^std::string Symbol::remove_quotation() const {$/;"	f	class:thorin::Symbol
rend	src/thorin/util/array.h	/^    const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:thorin::Array
rend	src/thorin/util/array.h	/^    const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:thorin::ArrayRef
rend	src/thorin/util/array.h	/^    reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:thorin::Array
replace	src/thorin/def.cpp	/^void Def::replace(Tracker with) const {$/;"	f	class:thorin::Def
reset	src/thorin/util/types.h	/^    void reset() { *this = Box(); }$/;"	f	union:thorin::Box
resize	src/thorin/def.h	/^    void resize(size_t n) { ops_.resize(n, nullptr); }$/;"	f	class:thorin::Def
resolve_addr_space	src/thorin/be/llvm/nvvm.cpp	/^static AddrSpace resolve_addr_space(const Def* def) {$/;"	f	namespace:thorin
resolve_global_variable	src/thorin/be/llvm/nvvm.cpp	/^llvm::GlobalVariable* NVVMCodeGen::resolve_global_variable(const Param* param) {$/;"	f	class:thorin::NVVMCodeGen
resolve_loads	src/thorin/transform/resolve_loads.cpp	/^    bool resolve_loads() {$/;"	f	class:thorin::ResolveLoads
resolve_loads	src/thorin/transform/resolve_loads.cpp	/^    void resolve_loads(const Def* mem, Def2Def& mapping) {$/;"	f	class:thorin::ResolveLoads
resolve_loads	src/thorin/transform/resolve_loads.cpp	/^    void resolve_loads(const Scope& scope) {$/;"	f	class:thorin::ResolveLoads
resolve_loads	src/thorin/transform/resolve_loads.cpp	/^bool resolve_loads(World& world) {$/;"	f	namespace:thorin
ret_param	src/thorin/continuation.cpp	/^const Param* Continuation::ret_param() const {$/;"	f	class:thorin::Continuation
reverse_iterator	src/thorin/util/array.h	/^    typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:thorin::Array
reverse_post_order	src/thorin/analyses/cfg.h	/^    ArrayRef<const CFNode*> reverse_post_order() const { return rpo_.array(); }$/;"	f	class:thorin::CFG
reverse_post_order	src/thorin/analyses/cfg.h	/^    const CFNode* reverse_post_order(size_t i) const { return rpo_.array()[i]; }  \/\/\/< Maps from reverse post-order index to @p CFNode.$/;"	f	class:thorin::CFG
rewrite_def	src/thorin/transform/rewrite_flow_graphs.cpp	/^static void rewrite_def(const Def* def, Rewriter& rewriter) {$/;"	f	namespace:thorin
rewrite_flow_graphs	src/thorin/transform/rewrite_flow_graphs.cpp	/^void rewrite_flow_graphs(World& world) {$/;"	f	namespace:thorin
rewrite_jump	src/thorin/transform/rewrite_flow_graphs.cpp	/^static void rewrite_jump(Continuation* old_cont, Continuation* new_cont, Rewriter& rewriter) {$/;"	f	namespace:thorin
rewrite_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static const Type* rewrite_type(World& world, const Type* type) {$/;"	f	namespace:thorin
rhs	src/thorin/primop.h	/^    const Def* rhs() const { return op(1); }$/;"	f	class:thorin::BinOp
root	src/thorin/analyses/domtree.h	/^    const CFNode* root() const { return *idoms_.begin(); }$/;"	f	class:thorin::DomTreeBase
root	src/thorin/analyses/looptree.h	/^    const Head* root() const { return root_.get(); }$/;"	f	class:thorin::LoopTree
root_	src/thorin/analyses/looptree.h	/^    std::unique_ptr<Head> root_;$/;"	m	class:thorin::LoopTree
round_to_power_of_2	src/thorin/util/utility.h	/^inline uint64_t round_to_power_of_2(uint64_t i) {$/;"	f	namespace:thorin
rpo_	src/thorin/analyses/cfg.h	/^    Map<const CFNode*> rpo_;$/;"	m	class:thorin::CFG
run	src/thorin/analyses/scope.cpp	/^void Scope::run() {$/;"	f	class:thorin::Scope
run	src/thorin/analyses/verify.cpp	/^void Cycles::run() {$/;"	f	class:thorin::Cycles
run	src/thorin/transform/closure_conversion.cpp	/^    void run() {$/;"	f	class:thorin::ClosureConversion
run	src/thorin/transform/partial_evaluation.cpp	/^bool PartialEvaluator::run() {$/;"	f	class:thorin::PartialEvaluator
run	src/thorin/world.cpp	/^const Def* World::run(const Def* def, Debug dbg) {$/;"	f	class:thorin::World
runtime_	src/thorin/be/llvm/llvm.h	/^    std::unique_ptr<Runtime> runtime_;$/;"	m	class:thorin::CodeGen
runtime_	src/thorin/be/llvm/runtime.h	/^    std::unique_ptr<llvm::Module> runtime_;$/;"	m	class:thorin::Runtime
s16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
s16_	src/thorin/util/types.h	/^    s8 s8_; s16 s16_; s32 s32_; s64 s64_;$/;"	m	union:thorin::Box
s32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
s32_	src/thorin/util/types.h	/^    s8 s8_; s16 s16_; s32 s32_; s64 s64_;$/;"	m	union:thorin::Box
s64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
s64_	src/thorin/util/types.h	/^    s8 s8_; s16 s16_; s32 s32_; s64 s64_;$/;"	m	union:thorin::Box
s8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
s8_	src/thorin/util/types.h	/^    s8 s8_; s16 s16_; s32 s32_; s64 s64_;$/;"	m	union:thorin::Box
scalarize	src/thorin/type.cpp	/^const VectorType* VectorType::scalarize() const {$/;"	f	class:thorin::VectorType
scast	src/thorin/util/cast.h	/^inline L* scast(R* r) {$/;"	f	namespace:thorin
scast	src/thorin/util/cast.h	/^inline const L* scast(const R* r) { return const_cast<const L*>(scast<L, R>(const_cast<R*>(r))); }$/;"	f	namespace:thorin
schedule	src/thorin/analyses/schedule.h	/^inline Schedule schedule(const Scope& scope, Schedule::Tag tag = Schedule::Smart) { return Schedule(scope, tag); }$/;"	f	namespace:thorin
schedule_	src/thorin/analyses/schedule.cpp	/^    Schedule& schedule_;$/;"	m	class:thorin::Scheduler	file:
schedule_early	src/thorin/analyses/schedule.cpp	/^    void schedule_early() { for_all_primops([&](const PrimOp* primop) { schedule_early(primop); }); }$/;"	f	class:thorin::Scheduler
schedule_early	src/thorin/analyses/schedule.cpp	/^const CFNode* Scheduler::schedule_early(const Def* def) {$/;"	f	class:thorin::Scheduler
schedule_late	src/thorin/analyses/schedule.cpp	/^    void schedule_late()  { for_all_primops([&](const PrimOp* primop) { schedule_late (primop); }); }$/;"	f	class:thorin::Scheduler
schedule_late	src/thorin/analyses/schedule.cpp	/^const CFNode* Scheduler::schedule_late(const Def* def) {$/;"	f	class:thorin::Scheduler
schedule_smart	src/thorin/analyses/schedule.cpp	/^    void schedule_smart() { for_all_primops([&](const PrimOp* primop) { schedule_smart(primop); }); }$/;"	f	class:thorin::Scheduler
schedule_smart	src/thorin/analyses/schedule.cpp	/^const CFNode* Scheduler::schedule_smart(const PrimOp* primop) {$/;"	f	class:thorin::Scheduler
scope	src/thorin/analyses/cfg.h	/^    const Scope& scope() const { return scope_; }$/;"	f	class:thorin::CFA
scope	src/thorin/analyses/schedule.h	/^    const Scope& scope() const { return scope_; }$/;"	f	class:thorin::Schedule
scope	src/thorin/transform/mangle.h	/^    const Scope& scope() const { return scope_; }$/;"	f	class:thorin::Mangler
scope	src/thorin/util/ycomp.h	/^    const Scope& scope() const { return scope_; }$/;"	f	class:thorin::YComp
scope_	src/thorin/analyses/cfg.h	/^    const Scope& scope_;$/;"	m	class:thorin::CFA
scope_	src/thorin/analyses/schedule.cpp	/^    const Scope& scope_;$/;"	m	class:thorin::Scheduler	file:
scope_	src/thorin/analyses/schedule.h	/^    const Scope& scope_;$/;"	m	class:thorin::Schedule
scope_	src/thorin/transform/mangle.h	/^    const Scope& scope_;$/;"	m	class:thorin::Mangler
scope_	src/thorin/util/ycomp.h	/^    const Scope& scope_;$/;"	m	class:thorin::YComp
select	src/thorin/world.cpp	/^const Def* World::select(const Def* cond, const Def* a, const Def* b, Debug dbg) {$/;"	f	class:thorin::World
self	src/thorin/util/args.h	/^    typedef Option<OptionStringVector, T> self;$/;"	t	struct:thorin::Option
self	src/thorin/util/args.h	/^    typedef Option<YCompCommandLine, T> self;$/;"	t	struct:thorin::Option
self	src/thorin/util/args.h	/^    typedef Option<bool, T> self;$/;"	t	struct:thorin::Option
self	src/thorin/util/args.h	/^    typedef Option<int, T> self;$/;"	t	struct:thorin::Option
self	src/thorin/util/args.h	/^    typedef Option<std::string, T> self;$/;"	t	struct:thorin::Option
sentinel	src/thorin/continuation.h	/^        static Call sentinel() { return Call(); }$/;"	f	struct:thorin::Call::Hash
sentinel	src/thorin/def.h	/^    inline static Use sentinel() { return Use(size_t(-1), (const Def*)(-1)); }$/;"	f	struct:thorin::UseHash
sentinel	src/thorin/primop.h	/^    static const PrimOp* sentinel() { return (const PrimOp*)(1); }$/;"	f	struct:thorin::PrimOpHash
sentinel	src/thorin/transform/split_slots.cpp	/^    static u32 sentinel() { return 0xFFFFFFFF; }$/;"	f	struct:thorin::IndexHash
sentinel	src/thorin/util/hash.h	/^    static const char* sentinel() { return (const char*)(1); }$/;"	f	struct:thorin::StrHash
sentinel	src/thorin/util/symbol.h	/^        static Symbol sentinel() { return Symbol(\/*dummy*\/23); }$/;"	f	struct:thorin::Symbol::Hash
sentinel	src/thorin/util/type_table.h	/^        static const Type* sentinel() { return (const Type*)(1); }$/;"	f	struct:thorin::TypeTableBase::TypeHash
sentinel	src/thorin/util/type_table.h	/^    static T sentinel() { return T(1); }$/;"	f	struct:thorin::GIDHash
sentinel	src/thorin/world.h	/^        static size_t sentinel() { return size_t(-1); }$/;"	f	struct:thorin::World::BreakHash
sep	src/thorin/util/stream.h	/^    const char* sep;$/;"	m	class:thorin::StreamList
set	src/thorin/type.h	/^    void set(size_t i, const Type* type) const { return const_cast<StructType*>(this)->Type::set(i, type); }$/;"	f	class:thorin::StructType
set	src/thorin/util/indexset.h	/^    bool set(Key key) {$/;"	f	class:thorin::IndexSet
set	src/thorin/util/location.h	/^    void set(Location location) { *static_cast<Location*>(this) = location; }$/;"	f	class:thorin::Debug
set	src/thorin/util/location.h	/^    void set(Symbol name) { name_= name; }$/;"	f	class:thorin::Debug
set	src/thorin/util/log.cpp	/^void Log::set(Level min_level, std::ostream* stream) {$/;"	f	class:thorin::Log
set	src/thorin/util/type_table.h	/^    void set(size_t i, const TypeBase* type) {$/;"	f	class:thorin::TypeBase
set_	src/thorin/analyses/looptree.cpp	/^    typename CFG<forward>::Set set_;$/;"	m	class:thorin::LoopTreeBuilder	file:
set_all_true_filter	src/thorin/continuation.cpp	/^void Continuation::set_all_true_filter() {$/;"	f	class:thorin::Continuation
set_filter	src/thorin/continuation.h	/^    void set_filter(Defs defs) {$/;"	f	class:thorin::Continuation
set_intrinsic	src/thorin/continuation.cpp	/^void Continuation::set_intrinsic() {$/;"	f	class:thorin::Continuation
set_min_level	src/thorin/util/log.cpp	/^void Log::set_min_level(Log::Level min_level) { min_level_ = min_level; }$/;"	f	class:thorin::Log
set_op	src/thorin/def.cpp	/^void Def::set_op(size_t i, const Def* def) {$/;"	f	class:thorin::Def
set_stream	src/thorin/util/log.cpp	/^void Log::set_stream(std::ostream* stream) { stream_ = stream; }$/;"	f	class:thorin::Log
set_type	src/thorin/def.h	/^    void set_type(const Type* type) { type_ = type; }$/;"	f	class:thorin::Def
set_type	src/thorin/primop.h	/^    void set_type(const Type* type) { type_ = type; }$/;"	f	class:thorin::PrimOp
shrink	src/thorin/util/array.h	/^    void shrink(size_t newsize) { assert(newsize <= size_); size_ = newsize; }$/;"	f	class:thorin::Array
size	src/thorin/analyses/cfg.h	/^    size_t size() const { return cfa().size(); }$/;"	f	class:thorin::CFG
size	src/thorin/analyses/cfg.h	/^    size_t size() const { return nodes().size(); }$/;"	f	class:thorin::CFA
size	src/thorin/analyses/schedule.h	/^    size_t size() const { return blocks_.size(); }$/;"	f	class:thorin::Schedule
size	src/thorin/util/array.h	/^    size_t size() const { return size_; }$/;"	f	class:thorin::Array
size	src/thorin/util/array.h	/^    size_t size() const { return size_; }$/;"	f	class:thorin::ArrayRef
size	src/thorin/util/hash.h	/^    size_t size() const { return size_; }$/;"	f	class:thorin::detail::HashTable
size_	src/thorin/util/array.h	/^    size_t size_;$/;"	m	class:thorin::Array
size_	src/thorin/util/array.h	/^    size_t size_;$/;"	m	class:thorin::ArrayRef
size_	src/thorin/util/hash.h	/^    uint32_t size_;$/;"	m	class:thorin::detail::HashTable
size_of	src/thorin/world.cpp	/^const Def* World::size_of(const Type* type, Debug dbg) {$/;"	f	class:thorin::World
size_type	src/thorin/util/hash.h	/^    typedef std::size_t size_type;$/;"	t	class:thorin::detail::HashTable
size_type	src/thorin/util/hash.h	/^    typedef typename Super::size_type size_type;$/;"	t	class:thorin::HashMap
size_type	src/thorin/util/hash.h	/^    typedef typename Super::size_type size_type;$/;"	t	class:thorin::HashSet
sizeof	src/thorin/util/types.h	/^static_assert(sizeof(Box) == sizeof(uint64_t), "Box has incorrect size in bytes");$/;"	m	namespace:thorin
skip	src/thorin/util/hash.h	/^        static iterator_base skip(value_type* ptr, const HashTable* table) {$/;"	f	class:thorin::detail::HashTable::iterator_base
skip	src/thorin/util/iterator.h	/^    void skip() {$/;"	f	class:thorin::filter_iterator
skip_back	src/thorin/util/array.h	/^    ArrayRef<T> skip_back (size_t num = 1) const { return ArrayRef<T>(ptr_, size() - num); }$/;"	f	class:thorin::Array
skip_back	src/thorin/util/array.h	/^    ArrayRef<T> skip_back (size_t num = 1) const { return ArrayRef<T>(ptr_, size() - num); }$/;"	f	class:thorin::ArrayRef
skip_front	src/thorin/util/array.h	/^    ArrayRef<T> skip_front(size_t num = 1) const { return ArrayRef<T>(ptr_ + num, size() - num); }$/;"	f	class:thorin::Array
skip_front	src/thorin/util/array.h	/^    ArrayRef<T> skip_front(size_t num = 1) const { return ArrayRef<T>(ptr_ + num, size() - num); }$/;"	f	class:thorin::ArrayRef
slot	src/thorin/world.h	/^    const Def* slot(const Type* type, const Def* frame, Debug dbg = {}) { return cse(new Slot(type, frame, dbg)); }$/;"	f	class:thorin::World
spawn_thread	src/thorin/be/llvm/runtime.cpp	/^llvm::Value* Runtime::spawn_thread(llvm::Value* closure_ptr, llvm::Value* fun_ptr) {$/;"	f	class:thorin::Runtime
splat	src/thorin/world.cpp	/^const Def* World::splat(const Def* arg, size_t length, Debug dbg) {$/;"	f	class:thorin::World
split	src/thorin/transform/split_slots.cpp	/^static void split(const Slot* slot) {$/;"	f	namespace:thorin
split_slots	src/thorin/transform/split_slots.cpp	/^static bool split_slots(const Scope& scope) {$/;"	f	namespace:thorin
split_slots	src/thorin/transform/split_slots.cpp	/^void split_slots(World& world) {$/;"	f	namespace:thorin
stack_	src/thorin/analyses/looptree.cpp	/^    std::vector<const CFNode*> stack_;$/;"	m	class:thorin::LoopTreeBuilder	file:
stack_	src/thorin/util/utility.h	/^    std::stack<T> stack_;$/;"	m	class:thorin::unique_stack
states_	src/thorin/analyses/looptree.cpp	/^    typename CFG<forward>::template Map<uint8_t> states_;$/;"	m	class:thorin::LoopTreeBuilder	file:
store	src/thorin/world.cpp	/^const Def* World::store(const Def* mem, const Def* ptr, const Def* value, Debug dbg) {$/;"	f	class:thorin::World
str	src/thorin/util/symbol.h	/^    std::string str() const { return str_; }$/;"	f	class:thorin::Symbol
str_	src/thorin/util/symbol.h	/^    const char* str_;$/;"	m	class:thorin::Symbol
stream	src/thorin/analyses/cfg.cpp	/^std::ostream& CFNode::stream(std::ostream& out) const { return streamf(out, "{}", continuation()); }$/;"	f	class:thorin::CFNode
stream	src/thorin/analyses/looptree.cpp	/^std::ostream& LoopTree<forward>::Head::stream(std::ostream& out) const {$/;"	f	class:thorin::LoopTree::Head
stream	src/thorin/analyses/looptree.cpp	/^std::ostream& LoopTree<forward>::Leaf::stream(std::ostream& out) const {$/;"	f	class:thorin::LoopTree::Leaf
stream	src/thorin/analyses/schedule.cpp	/^std::ostream& Schedule::stream(std::ostream& os) const {$/;"	f	class:thorin::Schedule
stream	src/thorin/analyses/scope.cpp	/^std::ostream& Scope::stream(std::ostream& os) const { return schedule(*this).stream(os); }$/;"	f	class:thorin::Scope
stream	src/thorin/def.cpp	/^std::ostream& Def::stream(std::ostream& out) const { return out << unique_name(); }$/;"	f	class:thorin::Def
stream	src/thorin/def.h	/^    inline std::ostream& stream(std::ostream& os, const Def* def) { return def->stream(os); }$/;"	f	namespace:thorin::detail
stream	src/thorin/def.h	/^    inline std::ostream& stream(std::ostream& os, const Type* type) { return type->stream(os); }$/;"	f	namespace:thorin::detail
stream	src/thorin/primop.cpp	/^std::ostream& Global::stream(std::ostream& os) const { return os << unique_name(); }$/;"	f	class:thorin::Global
stream	src/thorin/primop.cpp	/^std::ostream& PrimLit::stream(std::ostream& os) const {$/;"	f	class:thorin::PrimLit
stream	src/thorin/primop.cpp	/^std::ostream& PrimOp::stream(std::ostream& os) const {$/;"	f	class:thorin::PrimOp
stream	src/thorin/type.cpp	/^std::ostream& App                ::stream(std::ostream& os) const { return streamf(os, "{}[{}]", callee(), arg()); }$/;"	f	class:thorin::App
stream	src/thorin/type.cpp	/^std::ostream& ClosureType        ::stream(std::ostream& os) const { return stream_type_ops(os << "closure", this); }$/;"	f	class:thorin::ClosureType
stream	src/thorin/type.cpp	/^std::ostream& DefiniteArrayType  ::stream(std::ostream& os) const { return streamf(os, "[{} x {}]", dim(), elem_type()); }$/;"	f	class:thorin::DefiniteArrayType
stream	src/thorin/type.cpp	/^std::ostream& FnType             ::stream(std::ostream& os) const { return stream_type_ops(os << "fn", this); }$/;"	f	class:thorin::FnType
stream	src/thorin/type.cpp	/^std::ostream& FrameType          ::stream(std::ostream& os) const { return os << "frame"; }$/;"	f	class:thorin::FrameType
stream	src/thorin/type.cpp	/^std::ostream& IndefiniteArrayType::stream(std::ostream& os) const { return streamf(os, "[{}]", elem_type()); }$/;"	f	class:thorin::IndefiniteArrayType
stream	src/thorin/type.cpp	/^std::ostream& Lambda             ::stream(std::ostream& os) const { return streamf(os, "[{}].{}", name(), body()); }$/;"	f	class:thorin::Lambda
stream	src/thorin/type.cpp	/^std::ostream& MemType            ::stream(std::ostream& os) const { return os << "mem"; }$/;"	f	class:thorin::MemType
stream	src/thorin/type.cpp	/^std::ostream& PrimType::stream(std::ostream& os) const {$/;"	f	class:thorin::PrimType
stream	src/thorin/type.cpp	/^std::ostream& PtrType::stream(std::ostream& os) const {$/;"	f	class:thorin::PtrType
stream	src/thorin/type.cpp	/^std::ostream& StructType         ::stream(std::ostream& os) const { return os << name(); }$/;"	f	class:thorin::StructType
stream	src/thorin/type.cpp	/^std::ostream& TupleType          ::stream(std::ostream& os) const { return stream_type_ops(os, this); }$/;"	f	class:thorin::TupleType
stream	src/thorin/type.cpp	/^std::ostream& Var                ::stream(std::ostream& os) const { return streamf(os, "<{}>", depth()); }$/;"	f	class:thorin::Var
stream	src/thorin/type.cpp	/^std::ostream& VariantType        ::stream(std::ostream& os) const { return stream_type_ops(os << "variant", this); }$/;"	f	class:thorin::VariantType
stream	src/thorin/util/array.h	/^    std::ostream& stream(std::ostream& os) const {$/;"	f	class:thorin::ArrayRef
stream	src/thorin/util/log.cpp	/^std::ostream& Log::stream() { return *stream_; }$/;"	f	class:thorin::Log
stream	src/thorin/util/stream.h	/^    template<> inline std::ostream& stream<const Streamable*>(std::ostream& os, const Streamable* s) { return s->stream(os); }$/;"	f	namespace:thorin::detail
stream	src/thorin/util/stream.h	/^    template<typename T> inline std::ostream& stream(std::ostream& os, T val) { return os << val; }$/;"	f	namespace:thorin::detail
stream	src/thorin/world.cpp	/^std::ostream& World::stream(std::ostream& os) const {$/;"	f	class:thorin::World
stream_	src/thorin/util/log.cpp	/^std::ostream* Log::stream_ = nullptr;$/;"	m	class:thorin::Log	file:
stream_	src/thorin/util/log.h	/^    static std::ostream* stream_;$/;"	m	class:thorin::Log
stream_assignment	src/thorin/primop.cpp	/^std::ostream& Assembly::stream_assignment(std::ostream& os) const {$/;"	f	class:thorin::Assembly
stream_assignment	src/thorin/primop.cpp	/^std::ostream& PrimOp::stream_assignment(std::ostream& os) const {$/;"	f	class:thorin::PrimOp
stream_head	src/thorin/continuation.cpp	/^std::ostream& Continuation::stream_head(std::ostream& os) const {$/;"	f	class:thorin::Continuation
stream_jump	src/thorin/continuation.cpp	/^std::ostream& Continuation::stream_jump(std::ostream& os) const {$/;"	f	class:thorin::Continuation
stream_list	src/thorin/util/stream.h	/^StreamList<Emit, List> stream_list(const List& list, Emit emit, const char* sep = ", ") {$/;"	f	namespace:thorin
stream_list	src/thorin/util/stream.h	/^std::ostream& stream_list(std::ostream& os, const List& list, Emit emit,$/;"	f	namespace:thorin
stream_type_ops	src/thorin/type.cpp	/^static std::ostream& stream_type_ops(std::ostream& os, const Type* type) {$/;"	f	namespace:thorin
stream_ycomp	src/thorin/analyses/cfg.cpp	/^void CFG<forward>::stream_ycomp(std::ostream& out) const {$/;"	f	class:thorin::CFG
stream_ycomp	src/thorin/analyses/domfrontier.cpp	/^void DomFrontierBase<forward>::stream_ycomp(std::ostream& out) const {$/;"	f	class:thorin::DomFrontierBase
stream_ycomp	src/thorin/analyses/domtree.cpp	/^void DomTreeBase<forward>::stream_ycomp(std::ostream& out) const {$/;"	f	class:thorin::DomTreeBase
stream_ycomp	src/thorin/analyses/looptree.cpp	/^void LoopTree<forward>::stream_ycomp(std::ostream& out) const {$/;"	f	class:thorin::LoopTree
streamf	src/thorin/util/stream.cpp	/^std::ostream& streamf(std::ostream& os, const char* fmt) {$/;"	f	namespace:thorin
streamf	src/thorin/util/stream.h	/^std::ostream& streamf(std::ostream& os, const char* fmt, T val, Args... args) {$/;"	f	namespace:thorin
struct_agg	src/thorin/world.h	/^    const Def* struct_agg(const StructType* struct_type, Defs args, Debug dbg = {}) {$/;"	f	class:thorin::World
struct_type	src/thorin/type.cpp	/^const StructType* TypeTable::struct_type(Symbol name, size_t size) {$/;"	f	class:thorin::TypeTable
stub	src/thorin/continuation.cpp	/^Continuation* Continuation::stub() const {$/;"	f	class:thorin::Continuation
substitute_	src/thorin/def.h	/^    mutable const Def* substitute_ = nullptr;$/;"	m	class:thorin::Def
succs	src/thorin/analyses/cfg.cpp	/^template<bool forward> const CFNodes& CFG<forward>::succs(const CFNode* n) const { assert(n != nullptr); return forward ? n->succs() : n->preds(); }$/;"	f	class:thorin::CFG
succs	src/thorin/analyses/cfg.h	/^    const CFNodes& succs() const { return succs_; }$/;"	f	class:thorin::CFNode
succs	src/thorin/analyses/cfg.h	/^    const CFNodes& succs(Continuation* continuation) const { auto cn = nodes_.find(continuation)->second; assert(cn); return cn->succs(); }$/;"	f	class:thorin::CFA
succs	src/thorin/analyses/cfg.h	/^    const CFNodes& succs(Continuation* continuation) const { return succs(cfa()[continuation]); }$/;"	f	class:thorin::CFG
succs	src/thorin/analyses/domfrontier.h	/^    const std::vector<const CFNode*>& succs(const CFNode* n) const { return succs_[n]; }$/;"	f	class:thorin::DomFrontierBase
succs	src/thorin/continuation.cpp	/^Continuations Continuation::succs() const {$/;"	f	class:thorin::Continuation
succs_	src/thorin/analyses/cfg.h	/^    mutable CFNodes succs_;$/;"	m	class:thorin::CFNode
succs_	src/thorin/analyses/domfrontier.h	/^    typename CFG<forward>::template Map<std::vector<const CFNode*>> succs_;$/;"	m	class:thorin::DomFrontierBase
swap	src/thorin/continuation.h	/^    friend void swap(Call& call1, Call& call2) {$/;"	f	struct:thorin::Call
swap	src/thorin/type.h	/^    friend void swap(TypeTable& t1, TypeTable& t2) {$/;"	f	class:thorin::TypeTable
swap	src/thorin/util/array.h	/^    friend void swap(Array& a, Array& b) {$/;"	f	class:thorin::Array
swap	src/thorin/util/hash.h	/^    friend void swap(HashMap& m1, HashMap& m2) { swap(static_cast<Super&>(m1), static_cast<Super&>(m2)); }$/;"	f	class:thorin::HashMap
swap	src/thorin/util/hash.h	/^    friend void swap(HashSet& s1, HashSet& s2) { swap(static_cast<Super&>(s1), static_cast<Super&>(s2)); }$/;"	f	class:thorin::HashSet
swap	src/thorin/util/hash.h	/^    friend void swap(HashTable& t1, HashTable& t2) {$/;"	f	class:thorin::detail::HashTable
swap	src/thorin/util/indexmap.h	/^    friend void swap(IndexMap& map1, IndexMap& map2) {$/;"	f	class:thorin::IndexMap
swap	src/thorin/util/indexset.h	/^    friend void swap(IndexSet& set1, IndexSet& set2) {$/;"	f	class:thorin::IndexSet
swap	src/thorin/util/iterator.h	/^    friend void swap(filter_iterator& i1, filter_iterator& i2) { using std::swap; swap(i1, i2); }$/;"	f	class:thorin::filter_iterator
swap	src/thorin/util/iterator.h	/^    friend void swap(map_iterator& i1, map_iterator& i2) { using std::swap; swap(i1, i2); }$/;"	f	class:thorin::map_iterator
swap	src/thorin/world.h	/^    friend void swap(World& w1, World& w2) {$/;"	f	class:thorin::World
swap_breakpoints	src/thorin/world.h	/^    void swap_breakpoints(World& other) { swap(this->breakpoints_, other.breakpoints_); }$/;"	f	class:thorin::World
sync_thread	src/thorin/be/llvm/runtime.cpp	/^llvm::Value* Runtime::sync_thread(llvm::Value* id) {$/;"	f	class:thorin::Runtime
table	src/thorin/util/type_table.h	/^    TypeTable& table() const { return *table_; }$/;"	f	class:thorin::TypeBase
table_	src/thorin/util/hash.h	/^        const HashTable* table_;$/;"	m	class:thorin::detail::HashTable::iterator_base
table_	src/thorin/util/symbol.cpp	/^Symbol::Table Symbol::table_;$/;"	m	class:thorin::Symbol	file:
table_	src/thorin/util/symbol.h	/^    static Table table_;$/;"	m	class:thorin::Symbol
table_	src/thorin/util/type_table.h	/^    mutable TypeTable* table_;$/;"	m	class:thorin::TypeBase
tag	src/thorin/analyses/schedule.h	/^    Tag tag() const { return tag_; }$/;"	f	class:thorin::Schedule
tag	src/thorin/def.h	/^    NodeTag tag() const { return tag_; }$/;"	f	class:thorin::Def
tag	src/thorin/util/type_table.h	/^    int tag() const { return tag_; }$/;"	f	class:thorin::TypeBase
tag2str	src/thorin/enums.cpp	/^const char* tag2str(NodeTag tag) {$/;"	f	namespace:thorin
tag2type	src/thorin/enums.h	/^template<PrimTypeTag tag> struct tag2type {};$/;"	s	namespace:thorin
tag_	src/thorin/analyses/schedule.h	/^    Tag tag_;$/;"	m	class:thorin::Schedule
tag_	src/thorin/def.h	/^    const NodeTag tag_;$/;"	m	class:thorin::Def
tag_	src/thorin/util/type_table.h	/^    int tag_;$/;"	m	class:thorin::TypeBase
target	src/thorin/util/args.h	/^    T* target() const { return target_; }$/;"	f	class:thorin::BasicOption
target_	src/thorin/be/llvm/runtime.h	/^    llvm::Module& target_;$/;"	m	class:thorin::Runtime
target_	src/thorin/util/args.h	/^    T* target_;$/;"	m	class:thorin::BasicOption
target_type	src/thorin/util/args.h	/^    typedef std::vector<std::string> target_type;$/;"	t	struct:thorin::ImplicitOption
task_type	src/thorin/transform/rewrite_flow_graphs.cpp	/^static const Type* task_type(World& world) {$/;"	f	namespace:thorin
temps	src/thorin/util/ycomp.h	/^    std::vector<bool> temps;$/;"	m	class:thorin::YCompCommandLine
thorin	src/thorin/analyses/cfg.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/cfg.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/domfrontier.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/domfrontier.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/domtree.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/domtree.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/free_defs.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/free_defs.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/looptree.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/looptree.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/schedule.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/schedule.cpp	/^void Schedule::thorin() const {$/;"	f	class:thorin::Schedule
thorin	src/thorin/analyses/schedule.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/scope.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/scope.cpp	/^void Scope::thorin() const { schedule(*this).thorin(); }$/;"	f	class:thorin::Scope
thorin	src/thorin/analyses/scope.h	/^namespace thorin {$/;"	n
thorin	src/thorin/analyses/verify.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/analyses/verify.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/c.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/c.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/kernel_config.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/amdgpu.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/amdgpu.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/cpu.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/cpu.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/cuda.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/cuda.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/hls.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/hls.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/llvm.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/llvm.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/nvvm.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/nvvm.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/opencl.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/opencl.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/parallel.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/runtime.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/be/llvm/runtime.h	/^namespace thorin {$/;"	n
thorin	src/thorin/be/llvm/vectorize.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/continuation.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/continuation.h	/^namespace thorin {$/;"	n
thorin	src/thorin/def.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/def.h	/^namespace thorin {$/;"	n
thorin	src/thorin/enums.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/enums.h	/^namespace thorin {$/;"	n
thorin	src/thorin/primop.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/primop.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/cleanup_world.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/cleanup_world.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/clone_bodies.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/clone_bodies.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/closure_conversion.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/closure_conversion.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/codegen_prepare.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/codegen_prepare.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/dead_load_opt.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/dead_load_opt.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/flatten_tuples.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/flatten_tuples.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/hoist_enters.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/hoist_enters.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/importer.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/importer.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/inliner.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/inliner.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/lift_builtins.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/lift_builtins.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/mangle.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/mangle.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/partial_evaluation.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/partial_evaluation.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/resolve_loads.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/resolve_loads.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/rewrite_flow_graphs.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/rewrite_flow_graphs.h	/^namespace thorin {$/;"	n
thorin	src/thorin/transform/split_slots.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/transform/split_slots.h	/^namespace thorin {$/;"	n
thorin	src/thorin/type.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/type.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/args.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/array.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/cast.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/hash.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/hash.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/indexmap.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/indexset.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/iterator.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/location.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/location.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/log.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/log.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/stream.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/stream.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/symbol.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/symbol.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/type_table.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/types.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/utility.h	/^namespace thorin {$/;"	n
thorin	src/thorin/util/ycomp.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/util/ycomp.h	/^namespace thorin {$/;"	n
thorin	src/thorin/world.cpp	/^namespace thorin {$/;"	n	file:
thorin	src/thorin/world.cpp	/^void World::thorin() const {$/;"	f	class:thorin::World
thorin	src/thorin/world.h	/^namespace thorin {$/;"	n
thorin_dummy_function	src/thorin/util/utility.h	/^inline __declspec(noreturn) void thorin_dummy_function() { abort(); }$/;"	f
to_string	src/thorin/util/stream.cpp	/^std::string Streamable::to_string() const {$/;"	f	class:thorin::Streamable
todo	src/thorin/transform/importer.h	/^    bool todo() const { return todo_; }$/;"	f	class:thorin::Importer
todo_	src/thorin/transform/cleanup_world.cpp	/^    bool todo_ = true;$/;"	m	class:thorin::Cleaner	file:
todo_	src/thorin/transform/importer.h	/^    bool todo_ = false;$/;"	m	class:thorin::Importer
todo_	src/thorin/transform/resolve_loads.cpp	/^    bool todo_;$/;"	m	class:thorin::ResolveLoads	file:
top	src/thorin/world.h	/^    const Def* top(const Type* type, Debug dbg = {}, size_t length = 1) { return splat(cse(new Top(type, dbg)), length); }$/;"	f	class:thorin::World
top_level_	src/thorin/transform/partial_evaluation.cpp	/^    ContinuationMap<bool> top_level_;$/;"	m	class:thorin::PartialEvaluator	file:
top_level_	src/thorin/transform/partial_evaluation.cpp	/^    ContinuationMap<bool>& top_level_;$/;"	m	class:thorin::CondEval	file:
topo_sort	src/thorin/analyses/schedule.cpp	/^void Scheduler::topo_sort(Def2CFNode& def2node) {$/;"	f	class:thorin::Scheduler
track_history	src/thorin/world.h	/^    bool track_history() const { return track_history_; }$/;"	f	class:thorin::World
track_history_	src/thorin/world.h	/^    bool track_history_ = false;$/;"	m	class:thorin::World
transform	src/thorin/util/indexset.h	/^    IndexSet& transform(const IndexSet& other, Op op) {$/;"	f	class:thorin::IndexSet
try_fold_aggregate	src/thorin/world.cpp	/^const Def* World::try_fold_aggregate(const Aggregate* agg) {$/;"	f	class:thorin::World
try_inline	src/thorin/transform/flatten_tuples.cpp	/^static Continuation* try_inline(Continuation* cont, Array<const Def*>& args) {$/;"	f	namespace:thorin
tuple	src/thorin/world.h	/^    const Def* tuple(Defs args, Debug dbg = {}) { return args.size() == 1 ? args.front() : try_fold_aggregate(cse(new Tuple(*this, args, dbg))); }$/;"	f	class:thorin::World
tuple_type	src/thorin/type.h	/^    const Type* tuple_type(Types ops) { return ops.size() == 1 ? ops.front() : unify(new TupleType(*this, ops)); }$/;"	f	class:thorin::TypeTable
tval	src/thorin/primop.h	/^    const Def* tval() const { return op(1); }$/;"	f	class:thorin::Select
type	src/thorin/continuation.h	/^    const FnType* type() const { return Def::type()->as<FnType>(); }$/;"	f	class:thorin::Continuation
type	src/thorin/def.h	/^    const Type* type() const { return type_; }$/;"	f	class:thorin::Def
type	src/thorin/primop.h	/^    const DefiniteArrayType* type() const { return Aggregate::type()->as<DefiniteArrayType>(); }$/;"	f	class:thorin::DefiniteArray
type	src/thorin/primop.h	/^    const IndefiniteArrayType* type() const { return Aggregate::type()->as<IndefiniteArrayType>(); }$/;"	f	class:thorin::IndefiniteArray
type	src/thorin/primop.h	/^    const MemType* type() const { return Access::type()->as<MemType>(); }$/;"	f	class:thorin::Store
type	src/thorin/primop.h	/^    const PrimType* type() const { return BinOp::type()->as<PrimType>(); }$/;"	f	class:thorin::ArithOp
type	src/thorin/primop.h	/^    const PrimType* type() const { return BinOp::type()->as<PrimType>(); }$/;"	f	class:thorin::Cmp
type	src/thorin/primop.h	/^    const PrimType* type() const { return Literal::type()->as<PrimType>(); }$/;"	f	class:thorin::PrimLit
type	src/thorin/primop.h	/^    const PtrType* type() const { return PrimOp::type()->as<PtrType>(); }$/;"	f	class:thorin::Global
type	src/thorin/primop.h	/^    const PtrType* type() const { return PrimOp::type()->as<PtrType>(); }$/;"	f	class:thorin::LEA
type	src/thorin/primop.h	/^    const PtrType* type() const { return PrimOp::type()->as<PtrType>(); }$/;"	f	class:thorin::Slot
type	src/thorin/primop.h	/^    const StructType* type() const { return Aggregate::type()->as<StructType>(); }$/;"	f	class:thorin::StructAgg
type	src/thorin/primop.h	/^    const TupleType* type() const { return Aggregate::type()->as<TupleType>(); }$/;"	f	class:thorin::Tuple
type	src/thorin/primop.h	/^    const TupleType* type() const { return MemOp::type()->as<TupleType>(); }$/;"	f	class:thorin::Alloc
type	src/thorin/primop.h	/^    const TupleType* type() const { return MemOp::type()->as<TupleType>(); }$/;"	f	class:thorin::Enter
type	src/thorin/primop.h	/^    const TupleType* type() const { return MemOp::type()->as<TupleType>(); }$/;"	f	class:thorin::Load
type	src/thorin/primop.h	/^    const VariantType* type() const { return PrimOp::type()->as<VariantType>(); }$/;"	f	class:thorin::Variant
type	src/thorin/type.h	/^    const PrimType* type(PrimTypeTag tag, size_t length = 1) {$/;"	f	class:thorin::TypeTable
type2str_	src/thorin/be/c.cpp	/^    TypeMap<std::string> type2str_;$/;"	m	class:thorin::CCodeGen	file:
type2tag	src/thorin/enums.h	/^template<class T> struct type2tag {};$/;"	s	namespace:thorin
type2type_	src/thorin/transform/mangle.h	/^    Type2Type type2type_;$/;"	m	class:thorin::Mangler
type_	src/thorin/def.h	/^    const Type* type_;$/;"	m	class:thorin::Def
type_decls_	src/thorin/be/c.cpp	/^    std::ostringstream type_decls_;$/;"	m	class:thorin::CCodeGen	file:
type_old2new_	src/thorin/transform/importer.h	/^    Type2Type type_old2new_;$/;"	m	class:thorin::Importer
types	src/thorin/util/type_table.h	/^    const TypeSet& types() const { return types_; }$/;"	f	class:thorin::TypeTableBase
types_	src/thorin/be/llvm/llvm.h	/^    TypeMap<llvm::Type*> types_;$/;"	m	class:thorin::CodeGen
types_	src/thorin/util/type_table.h	/^    TypeSet types_;$/;"	m	class:thorin::TypeTableBase
u16	src/thorin/util/types.h	/^typedef int16_t s16; typedef uint16_t u16; typedef SInt<s16, true> ps16; typedef UInt<u16, true> pu16; typedef SInt<s16, false> qs16; typedef UInt<u16, false> qu16;$/;"	t	namespace:thorin
u16_	src/thorin/util/types.h	/^    u8 u8_; u16 u16_; u32 u32_; u64 u64_;$/;"	m	union:thorin::Box
u32	src/thorin/util/types.h	/^typedef int32_t s32; typedef uint32_t u32; typedef SInt<s32, true> ps32; typedef UInt<u32, true> pu32; typedef SInt<s32, false> qs32; typedef UInt<u32, false> qu32;$/;"	t	namespace:thorin
u32_	src/thorin/util/types.h	/^    u8 u8_; u16 u16_; u32 u32_; u64 u64_;$/;"	m	union:thorin::Box
u64	src/thorin/util/types.h	/^typedef int64_t s64; typedef uint64_t u64; typedef SInt<s64, true> ps64; typedef UInt<u64, true> pu64; typedef SInt<s64, false> qs64; typedef UInt<u64, false> qu64;$/;"	t	namespace:thorin
u64_	src/thorin/util/types.h	/^    u8 u8_; u16 u16_; u32 u32_; u64 u64_;$/;"	m	union:thorin::Box
u8	src/thorin/util/types.h	/^typedef  int8_t  s8; typedef  uint8_t  u8; typedef SInt< s8, true>  ps8; typedef UInt< u8, true>  pu8; typedef SInt< s8, false>  qs8; typedef UInt< u8, false>  qu8;$/;"	t	namespace:thorin
u8_	src/thorin/util/types.h	/^    u8 u8_; u16 u16_; u32 u32_; u64 u64_;$/;"	m	union:thorin::Box
unify	src/thorin/util/type_table.h	/^    template<class T> const T* unify(const T* type) { return unify_base(type)->template as<T>(); }$/;"	f	class:thorin::TypeTableBase
unify_base	src/thorin/util/type_table.h	/^const Type* TypeTableBase<Type>::unify_base(const Type* type) {$/;"	f	class:thorin::TypeTableBase
unique_name	src/thorin/def.cpp	/^std::string Def::unique_name() const {$/;"	f	class:thorin::Def
unique_queue	src/thorin/util/utility.h	/^class unique_queue {$/;"	c	namespace:thorin
unique_stack	src/thorin/util/utility.h	/^class unique_stack {$/;"	c	namespace:thorin
unit	src/thorin/type.h	/^    const TupleType* unit() { return unit_; } \/\/\/< Returns unit, i.e., an empty @p TupleType.$/;"	f	class:thorin::TypeTable
unit_	src/thorin/type.h	/^    const TupleType* unit_; \/\/\/< tuple().$/;"	m	class:thorin::TypeTable
unregister_use	src/thorin/def.cpp	/^void Def::unregister_use(size_t i) const {$/;"	f	class:thorin::Def
unregister_uses	src/thorin/def.cpp	/^void Def::unregister_uses() const {$/;"	f	class:thorin::Def
unset_op	src/thorin/def.cpp	/^void Def::unset_op(size_t i) {$/;"	f	class:thorin::Def
unset_ops	src/thorin/def.cpp	/^void Def::unset_ops() {$/;"	f	class:thorin::Def
unwrap_def	src/thorin/transform/flatten_tuples.cpp	/^static Continuation* unwrap_def(Def2Def& wrapped, Def2Def& unwrapped, const Def* new_def, const FnType* old_type, size_t max_tuple_size) {$/;"	f	namespace:thorin
up	src/thorin/util/stream.h	/^std::basic_ostream<charT,traits>& up(std::basic_ostream<charT,traits>& os) { detail::inc_indent(); return os; }$/;"	f	namespace:thorin
up_endl	src/thorin/util/stream.h	/^std::basic_ostream<charT,traits>& up_endl(std::basic_ostream<charT,traits>& os) { return os << up << endl; }$/;"	f	namespace:thorin
update	src/thorin/analyses/scope.cpp	/^Scope& Scope::update() {$/;"	f	class:thorin::Scope
update_arg	src/thorin/continuation.h	/^    Continuation* update_arg(size_t i, const Def* def) { return update_op(i+1, def); }$/;"	f	class:thorin::Continuation
update_callee	src/thorin/continuation.h	/^    Continuation* update_callee(const Def* def) { return update_op(0, def); }$/;"	f	class:thorin::Continuation
update_op	src/thorin/continuation.cpp	/^Continuation* Continuation::update_op(size_t i, const Def* def) {$/;"	f	class:thorin::Continuation
uptr_	src/thorin/def.h	/^        uintptr_t uptr_;$/;"	m	union:thorin::Use::__anon10
use_16_	src/thorin/be/c.cpp	/^    bool use_16_ = false;$/;"	m	class:thorin::CCodeGen	file:
use_64_	src/thorin/be/c.cpp	/^    bool use_64_ = false;$/;"	m	class:thorin::CCodeGen	file:
use_channels_	src/thorin/be/c.cpp	/^    bool use_channels_ = false;$/;"	m	class:thorin::CCodeGen	file:
use_lea	src/thorin/type.cpp	/^bool use_lea(const Type* type) { return type->isa<StructType>() || type->isa<ArrayType>(); }$/;"	f	namespace:thorin
uses	src/thorin/analyses/schedule.cpp	/^    const Uses& uses(const Def* def) const { return def2uses_.find(def)->second; }$/;"	f	class:thorin::Scheduler
uses	src/thorin/def.h	/^    const Uses& uses() const { return uses_; }$/;"	f	class:thorin::Def
uses_	src/thorin/def.h	/^    mutable Uses uses_;$/;"	m	class:thorin::Def
val	src/thorin/primop.h	/^    const Def* val() const { return op(2); }$/;"	f	class:thorin::Store
value	src/thorin/primop.h	/^    Box value() const { return box_; }$/;"	f	class:thorin::PrimLit
value	src/thorin/primop.h	/^    const Def* value() const { return op(2); }$/;"	f	class:thorin::Insert
value_type	src/thorin/util/array.h	/^    typedef T value_type;$/;"	t	class:thorin::Array
value_type	src/thorin/util/array.h	/^    typedef T value_type;$/;"	t	class:thorin::ArrayRef
value_type	src/thorin/util/hash.h	/^        typedef typename HashTable<Key, T, H>::value_type value_type;$/;"	t	class:thorin::detail::HashTable::iterator_base
value_type	src/thorin/util/hash.h	/^    typedef typename Super::value_type value_type;$/;"	t	class:thorin::HashMap
value_type	src/thorin/util/hash.h	/^    typedef typename Super::value_type value_type;$/;"	t	class:thorin::HashSet
value_type	src/thorin/util/hash.h	/^    typedef typename std::conditional<std::is_void<T>::value, Key, std::pair<Key, T>>::type value_type;$/;"	t	class:thorin::detail::HashTable
value_type	src/thorin/util/iterator.h	/^    typedef OutT value_type;$/;"	t	class:thorin::map_iterator
value_type	src/thorin/util/iterator.h	/^    typedef V value_type;$/;"	t	class:thorin::filter_iterator
var	src/thorin/type.h	/^    const Var* var(int depth) { return unify(new Var(*this, depth)); }$/;"	f	class:thorin::TypeTable
var_name	src/thorin/be/c.cpp	/^const std::string CCodeGen::var_name(const Def* def) {$/;"	f	class:thorin::CCodeGen
variant	src/thorin/world.h	/^    const Def* variant(const VariantType* variant_type, const Def* value, Debug dbg = {}) { return cse(new Variant(variant_type, value, dbg)); }$/;"	f	class:thorin::World
variant_type	src/thorin/type.h	/^    const VariantType* variant_type(Types ops) { return unify(new VariantType(*this, ops)); }$/;"	f	class:thorin::TypeTable
vec_todo_	src/thorin/be/llvm/llvm.h	/^    std::vector<std::tuple<u32, llvm::Function*, llvm::CallInst*>> vec_todo_;$/;"	m	class:thorin::CodeGen
vector	src/thorin/world.h	/^    const Def* vector(Defs args, Debug dbg = {}) {$/;"	f	class:thorin::World
vector_length	src/thorin/def.cpp	/^size_t vector_length(const Def* def) { return def->type()->as<VectorType>()->length(); }$/;"	f	namespace:thorin
vector_length	src/thorin/type.h	/^inline size_t vector_length(const Type* type) { return type->as<VectorType>()->length(); }$/;"	f	namespace:thorin
verify	src/thorin/analyses/cfg.cpp	/^void CFA::verify() {$/;"	f	class:thorin::CFA
verify	src/thorin/analyses/schedule.cpp	/^void Schedule::verify() {$/;"	f	class:thorin::Schedule
verify	src/thorin/analyses/verify.cpp	/^void verify(World& world) {$/;"	f	namespace:thorin
verify	src/thorin/continuation.h	/^    void verify() const {$/;"	f	class:thorin::Continuation
verify	src/thorin/util/hash.h	/^        inline void verify() const { assert(table_->id_ == id_); }$/;"	f	class:thorin::detail::HashTable::iterator_base
verify	src/thorin/util/hash.h	/^        inline void verify() const {}$/;"	f	class:thorin::detail::HashTable::iterator_base
verify	src/thorin/util/hash.h	/^        inline void verify(iterator_base i) const {$/;"	f	class:thorin::detail::HashTable::iterator_base
verify	src/thorin/util/hash.h	/^        inline void verify(iterator_base) const {}$/;"	f	class:thorin::detail::HashTable::iterator_base
verify_calls	src/thorin/analyses/verify.cpp	/^static void verify_calls(World& world) {$/;"	f	namespace:thorin
verify_closedness	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::verify_closedness() {$/;"	f	class:thorin::Cleaner
verify_mem	src/thorin/analyses/schedule.cpp	/^void verify_mem(World& world) {$/;"	f	namespace:thorin
verify_top_level	src/thorin/analyses/verify.cpp	/^static void verify_top_level(World& world) {$/;"	f	namespace:thorin
vhash	src/thorin/primop.cpp	/^uint64_t PrimLit::vhash() const { return hash_combine(Literal::vhash(), bcast<uint64_t, Box>(value())); }$/;"	f	class:thorin::PrimLit
vhash	src/thorin/primop.cpp	/^uint64_t PrimOp::vhash() const {$/;"	f	class:thorin::PrimOp
vhash	src/thorin/primop.cpp	/^uint64_t Slot::vhash() const { return hash_combine((int) tag(), gid()); }$/;"	f	class:thorin::Slot
vhash	src/thorin/type.cpp	/^uint64_t PtrType::vhash() const {$/;"	f	class:thorin::PtrType
vhash	src/thorin/type.cpp	/^uint64_t Var::vhash() const {$/;"	f	class:thorin::Var
vhash	src/thorin/util/type_table.h	/^uint64_t TypeBase<TypeTable>::vhash() const {$/;"	f	class:thorin::TypeBase
visit	src/thorin/analyses/looptree.cpp	/^    int visit(const CFNode* n, int counter) {$/;"	f	class:thorin::LoopTreeBuilder	file:
visit	src/thorin/util/hash.h	/^bool visit(HashSet<Key, H>& set, const Arg& key) {$/;"	f	namespace:thorin
visit	src/thorin/util/indexset.h	/^bool visit(IndexSet<Indexer, Key>& set, const Key& key) {$/;"	f	namespace:thorin
visit_capturing_intrinsics	src/thorin/continuation.cpp	/^bool visit_capturing_intrinsics(Continuation* cont, std::function<bool(Continuation*)> func, bool include_globals) {$/;"	f	namespace:thorin
visit_first	src/thorin/util/indexset.h	/^void visit_first(IndexSet<Indexer, Key>& set, const Key& key) {$/;"	f	namespace:thorin
visit_uses	src/thorin/continuation.cpp	/^bool visit_uses(Continuation* cont, std::function<bool(Continuation*)> func, bool include_globals) {$/;"	f	namespace:thorin
vrebuild	src/thorin/primop.cpp	/^const Def* Alloc::vrebuild(World& to, Defs ops, const Type* t) const {$/;"	f	class:thorin::Alloc
vrebuild	src/thorin/primop.cpp	/^const Def* ArithOp::vrebuild(World& to, Defs ops, const Type*  ) const { return to.arithop(arithop_tag(), ops[0], ops[1], debug()); }$/;"	f	class:thorin::ArithOp
vrebuild	src/thorin/primop.cpp	/^const Def* Assembly::vrebuild(World& to, Defs ops, const Type* t) const {$/;"	f	class:thorin::Assembly
vrebuild	src/thorin/primop.cpp	/^const Def* Bitcast::vrebuild(World& to, Defs ops, const Type* t) const { return to.bitcast(t, ops[0], debug()); }$/;"	f	class:thorin::Bitcast
vrebuild	src/thorin/primop.cpp	/^const Def* Bottom ::vrebuild(World& to, Defs,     const Type* t) const { return to.bottom(t, debug()); }$/;"	f	class:thorin::Bottom
vrebuild	src/thorin/primop.cpp	/^const Def* Cast   ::vrebuild(World& to, Defs ops, const Type* t) const { return to.cast(t, ops[0], debug()); }$/;"	f	class:thorin::Cast
vrebuild	src/thorin/primop.cpp	/^const Def* Closure::vrebuild(World& to, Defs ops, const Type* t) const { return to.closure(t->as<ClosureType>(), ops[0], ops[1], debug()); }$/;"	f	class:thorin::Closure
vrebuild	src/thorin/primop.cpp	/^const Def* Cmp    ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.cmp(cmp_tag(), ops[0], ops[1], debug()); }$/;"	f	class:thorin::Cmp
vrebuild	src/thorin/primop.cpp	/^const Def* DefiniteArray::vrebuild(World& to, Defs ops, const Type* t) const {$/;"	f	class:thorin::DefiniteArray
vrebuild	src/thorin/primop.cpp	/^const Def* Enter  ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.enter(ops[0], debug()); }$/;"	f	class:thorin::Enter
vrebuild	src/thorin/primop.cpp	/^const Def* Extract::vrebuild(World& to, Defs ops, const Type*  ) const { return to.extract(ops[0], ops[1], debug()); }$/;"	f	class:thorin::Extract
vrebuild	src/thorin/primop.cpp	/^const Def* Global ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.global(ops[0], is_mutable(), debug()); }$/;"	f	class:thorin::Global
vrebuild	src/thorin/primop.cpp	/^const Def* Hlt    ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.hlt(ops[0], debug()); }$/;"	f	class:thorin::Hlt
vrebuild	src/thorin/primop.cpp	/^const Def* IndefiniteArray::vrebuild(World& to, Defs ops, const Type* t) const {$/;"	f	class:thorin::IndefiniteArray
vrebuild	src/thorin/primop.cpp	/^const Def* Insert ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.insert(ops[0], ops[1], ops[2], debug()); }$/;"	f	class:thorin::Insert
vrebuild	src/thorin/primop.cpp	/^const Def* Known  ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.known(ops[0], debug()); }$/;"	f	class:thorin::Known
vrebuild	src/thorin/primop.cpp	/^const Def* LEA    ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.lea(ops[0], ops[1], debug()); }$/;"	f	class:thorin::LEA
vrebuild	src/thorin/primop.cpp	/^const Def* Load   ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.load(ops[0], ops[1], debug()); }$/;"	f	class:thorin::Load
vrebuild	src/thorin/primop.cpp	/^const Def* PrimLit::vrebuild(World& to, Defs,     const Type*  ) const { return to.literal(primtype_tag(), value(), debug()); }$/;"	f	class:thorin::PrimLit
vrebuild	src/thorin/primop.cpp	/^const Def* Run    ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.run(ops[0], debug()); }$/;"	f	class:thorin::Run
vrebuild	src/thorin/primop.cpp	/^const Def* Select ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.select(ops[0], ops[1], ops[2], debug()); }$/;"	f	class:thorin::Select
vrebuild	src/thorin/primop.cpp	/^const Def* SizeOf ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.size_of(ops[0]->type(), debug()); }$/;"	f	class:thorin::SizeOf
vrebuild	src/thorin/primop.cpp	/^const Def* Slot   ::vrebuild(World& to, Defs ops, const Type* t) const { return to.slot(t->as<PtrType>()->pointee(), ops[0], debug()); }$/;"	f	class:thorin::Slot
vrebuild	src/thorin/primop.cpp	/^const Def* Store  ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.store(ops[0], ops[1], ops[2], debug()); }$/;"	f	class:thorin::Store
vrebuild	src/thorin/primop.cpp	/^const Def* StructAgg::vrebuild(World& to, Defs ops, const Type* t) const {$/;"	f	class:thorin::StructAgg
vrebuild	src/thorin/primop.cpp	/^const Def* Top    ::vrebuild(World& to, Defs,     const Type* t) const { return to.top(t, debug()); }$/;"	f	class:thorin::Top
vrebuild	src/thorin/primop.cpp	/^const Def* Tuple  ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.tuple(ops, debug()); }$/;"	f	class:thorin::Tuple
vrebuild	src/thorin/primop.cpp	/^const Def* Variant::vrebuild(World& to, Defs ops, const Type* t) const { return to.variant(t->as<VariantType>(), ops[0], debug()); }$/;"	f	class:thorin::Variant
vrebuild	src/thorin/primop.cpp	/^const Def* Vector ::vrebuild(World& to, Defs ops, const Type*  ) const { return to.vector(ops, debug()); }$/;"	f	class:thorin::Vector
vrebuild	src/thorin/primop.h	/^    virtual const Def* vrebuild(World&, Defs, const Type*) const { return nullptr; } \/\/  = 0;$/;"	f	class:thorin::PrimOp
vrebuild	src/thorin/type.cpp	/^const Type* App                ::vrebuild(TypeTable& to, Types ops) const { return to.app(ops[0], ops[1]); }$/;"	f	class:thorin::App
vrebuild	src/thorin/type.cpp	/^const Type* ClosureType        ::vrebuild(TypeTable& to, Types ops) const { return to.closure_type(ops); }$/;"	f	class:thorin::ClosureType
vrebuild	src/thorin/type.cpp	/^const Type* DefiniteArrayType  ::vrebuild(TypeTable& to, Types ops) const { return to.definite_array_type(ops[0], dim()); }$/;"	f	class:thorin::DefiniteArrayType
vrebuild	src/thorin/type.cpp	/^const Type* FnType             ::vrebuild(TypeTable& to, Types ops) const { return to.fn_type(ops); }$/;"	f	class:thorin::FnType
vrebuild	src/thorin/type.cpp	/^const Type* FrameType          ::vrebuild(TypeTable& to, Types    ) const { return to.frame_type(); }$/;"	f	class:thorin::FrameType
vrebuild	src/thorin/type.cpp	/^const Type* IndefiniteArrayType::vrebuild(TypeTable& to, Types ops) const { return to.indefinite_array_type(ops[0]); }$/;"	f	class:thorin::IndefiniteArrayType
vrebuild	src/thorin/type.cpp	/^const Type* Lambda             ::vrebuild(TypeTable& to, Types ops) const { return to.lambda(ops[0], name()); }$/;"	f	class:thorin::Lambda
vrebuild	src/thorin/type.cpp	/^const Type* MemType            ::vrebuild(TypeTable& to, Types    ) const { return to.mem_type(); }$/;"	f	class:thorin::MemType
vrebuild	src/thorin/type.cpp	/^const Type* PrimType           ::vrebuild(TypeTable& to, Types    ) const { return to.type(primtype_tag(), length()); }$/;"	f	class:thorin::PrimType
vrebuild	src/thorin/type.cpp	/^const Type* PtrType::vrebuild(TypeTable& to, Types ops) const {$/;"	f	class:thorin::PtrType
vrebuild	src/thorin/type.cpp	/^const Type* StructType::vrebuild(TypeTable&, Types ops) const {$/;"	f	class:thorin::StructType
vrebuild	src/thorin/type.cpp	/^const Type* TupleType          ::vrebuild(TypeTable& to, Types ops) const { return to.tuple_type(ops); }$/;"	f	class:thorin::TupleType
vrebuild	src/thorin/type.cpp	/^const Type* Var                ::vrebuild(TypeTable& to, Types    ) const { return to.var(depth()); }$/;"	f	class:thorin::Var
vrebuild	src/thorin/type.cpp	/^const Type* VariantType        ::vrebuild(TypeTable& to, Types ops) const { return to.variant_type(ops); }$/;"	f	class:thorin::VariantType
vreduce	src/thorin/type.cpp	/^const Type* Lambda::vreduce(int depth, const Type* type, Type2Type& map) const {$/;"	f	class:thorin::Lambda
vreduce	src/thorin/type.cpp	/^const Type* StructType::vreduce(int depth, const Type* type, Type2Type& map) const {$/;"	f	class:thorin::StructType
vreduce	src/thorin/type.cpp	/^const Type* Var::vreduce(int depth, const Type* type, Type2Type&) const {$/;"	f	class:thorin::Var
vreduce	src/thorin/util/type_table.h	/^const TypeBase<TypeTable>* TypeBase<TypeTable>::vreduce(int depth, const TypeBase* type, Type2Type& map) const {$/;"	f	class:thorin::TypeBase
walk_scc	src/thorin/analyses/looptree.cpp	/^int LoopTreeBuilder<forward>::walk_scc(const CFNode* cur, Head* parent, int depth, int scc_counter) {$/;"	f	class:thorin::LoopTreeBuilder
within	src/thorin/transform/cleanup_world.cpp	/^void Cleaner::within(const Def* def) {$/;"	f	class:thorin::Cleaner
within	src/thorin/transform/mangle.h	/^    bool within(const Def* def) { return scope().contains(def) || defs_.contains(def); }$/;"	f	class:thorin::Mangler
word	src/thorin/util/indexset.h	/^        uint64_t word() const { return word_; }$/;"	f	class:thorin::IndexSet::reference
word_	src/thorin/util/indexset.h	/^        uint64_t& word_;$/;"	m	class:thorin::IndexSet::reference
world	src/thorin/analyses/schedule.h	/^    const World& world() const { return scope().world(); }$/;"	f	class:thorin::Schedule
world	src/thorin/analyses/scope.h	/^    World& world() const { return world_; }$/;"	f	class:thorin::Scope
world	src/thorin/analyses/verify.cpp	/^    World& world() { return world_; }$/;"	f	class:thorin::Cycles
world	src/thorin/be/c.cpp	/^    World& world() const { return world_; }$/;"	f	class:thorin::CCodeGen
world	src/thorin/be/llvm/llvm.h	/^    World& world() const { return world_; }$/;"	f	class:thorin::CodeGen
world	src/thorin/def.cpp	/^World& Def::world() const { return *static_cast<World*>(&type()->table()); }$/;"	f	class:thorin::Def
world	src/thorin/transform/cleanup_world.cpp	/^    World& world() { return world_; }$/;"	f	class:thorin::Cleaner
world	src/thorin/transform/importer.h	/^    World& world() { return world_; }$/;"	f	class:thorin::Importer
world	src/thorin/transform/mangle.h	/^    World& world() const { return scope_.world(); }$/;"	f	class:thorin::Mangler
world	src/thorin/transform/partial_evaluation.cpp	/^    World& world() { return callee_->world(); }$/;"	f	class:thorin::CondEval
world	src/thorin/transform/partial_evaluation.cpp	/^    World& world() { return world_; }$/;"	f	class:thorin::PartialEvaluator
world	src/thorin/util/ycomp.h	/^    const World& world() const { return scope().world(); }$/;"	f	class:thorin::YComp
world_	src/thorin/analyses/scope.h	/^    World& world_;$/;"	m	class:thorin::Scope
world_	src/thorin/analyses/verify.cpp	/^    World& world_;$/;"	m	class:thorin::Cycles	file:
world_	src/thorin/be/c.cpp	/^    World& world_;$/;"	m	class:thorin::CCodeGen	file:
world_	src/thorin/be/llvm/llvm.h	/^    World& world_;$/;"	m	class:thorin::CodeGen
world_	src/thorin/transform/cleanup_world.cpp	/^    World& world_;$/;"	m	class:thorin::Cleaner	file:
world_	src/thorin/transform/closure_conversion.cpp	/^    World& world_;$/;"	m	class:thorin::ClosureConversion	file:
world_	src/thorin/transform/importer.h	/^    World world_;$/;"	m	class:thorin::Importer
world_	src/thorin/transform/partial_evaluation.cpp	/^    World& world_;$/;"	m	class:thorin::PartialEvaluator	file:
world_	src/thorin/transform/resolve_loads.cpp	/^    World& world_;$/;"	m	class:thorin::ResolveLoads	file:
wrap_def	src/thorin/transform/flatten_tuples.cpp	/^static Continuation* wrap_def(Def2Def& wrapped, Def2Def& unwrapped, const Def* old_def, const FnType* new_type, size_t max_tuple_size) {$/;"	f	namespace:thorin
wrapped_type	src/thorin/transform/flatten_tuples.cpp	/^static const Type* wrapped_type(const FnType* fn_type, size_t max_tuple_size) {$/;"	f	namespace:thorin
write_thorin	src/thorin/analyses/schedule.cpp	/^void Schedule::write_thorin(const char* filename) const { std::ofstream file(filename); stream(file); }$/;"	f	class:thorin::Schedule
write_thorin	src/thorin/analyses/scope.cpp	/^void Scope::write_thorin(const char* filename) const { return schedule(*this).write_thorin(filename); }$/;"	f	class:thorin::Scope
write_thorin	src/thorin/world.cpp	/^void World::write_thorin(const char* filename) const { std::ofstream file(filename); stream(file); }$/;"	f	class:thorin::World
write_ycomp	src/thorin/util/ycomp.cpp	/^void YComp::write_ycomp(const char* filename) const {$/;"	f	class:thorin::YComp
ycomp	src/thorin/util/ycomp.cpp	/^void YComp::ycomp() const {$/;"	f	class:thorin::YComp
ycomp	src/thorin/util/ycomp.h	/^YCompScope<I, S> ycomp(std::ostream& out, YCompOrientation o, const Scope& scope, Range<I> range, S succs) {$/;"	f	namespace:thorin
zero	src/thorin/world.h	/^    const Def* zero(PrimTypeTag tag, Debug dbg = {}, size_t length = 1) { return literal(tag, 0, dbg, length); }$/;"	f	class:thorin::World
zero	src/thorin/world.h	/^    const Def* zero(const Type* type, Debug dbg = {}, size_t length = 1) { return zero(type->as<PrimType>()->primtype_tag(), dbg, length); }$/;"	f	class:thorin::World
~Array	src/thorin/util/array.h	/^    ~Array() { delete[] ptr_; }$/;"	f	class:thorin::Array
~BasicOption	src/thorin/util/args.h	/^    virtual ~BasicOption() {}$/;"	f	class:thorin::BasicOption
~CFA	src/thorin/analyses/cfg.cpp	/^CFA::~CFA() {$/;"	f	class:thorin::CFA
~CodeGen	src/thorin/be/llvm/llvm.h	/^    virtual ~CodeGen() {}$/;"	f	class:thorin::CodeGen
~Continuation	src/thorin/continuation.h	/^    virtual ~Continuation() { for (auto param : params()) delete param; }$/;"	f	class:thorin::Continuation
~Def	src/thorin/def.h	/^    virtual ~Def() {}$/;"	f	class:thorin::Def
~HashTable	src/thorin/util/hash.h	/^    ~HashTable() {$/;"	f	class:thorin::detail::HashTable
~KernelConfig	src/thorin/be/kernel_config.h	/^    virtual ~KernelConfig() {}$/;"	f	class:thorin::KernelConfig
~Push	src/thorin/util/utility.h	/^    ~Push() { ref_ = old_; }$/;"	f	struct:thorin::Push
~Scope	src/thorin/analyses/scope.cpp	/^Scope::~Scope() {}$/;"	f	class:thorin::Scope
~Streamable	src/thorin/util/stream.h	/^    virtual ~Streamable() {}$/;"	f	class:thorin::Streamable
~Table	src/thorin/util/symbol.h	/^        ~Table() {$/;"	f	struct:thorin::Symbol::Table
~TypeTableBase	src/thorin/util/type_table.h	/^    virtual ~TypeTableBase() { for (auto type : types_) delete type; }$/;"	f	class:thorin::TypeTableBase
~World	src/thorin/world.cpp	/^World::~World() {$/;"	f	class:thorin::World
~YComp	src/thorin/util/ycomp.h	/^    virtual ~YComp() {}$/;"	f	class:thorin::YComp
~YCompScope	src/thorin/util/ycomp.h	/^    ~YCompScope() {$/;"	f	class:thorin::YCompScope
